# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ApiKeyManagedResource',
    'ApiKeyManagedResourceEnvironment',
    'ApiKeyOwner',
    'BusinessMetadataAttributeDefinition',
    'BusinessMetadataBindingCredentials',
    'BusinessMetadataBindingSchemaRegistryCluster',
    'BusinessMetadataCredentials',
    'BusinessMetadataSchemaRegistryCluster',
    'ByokKeyAws',
    'ByokKeyAzure',
    'ClusterLinkDestinationKafkaCluster',
    'ClusterLinkDestinationKafkaClusterCredentials',
    'ClusterLinkLocalKafkaCluster',
    'ClusterLinkLocalKafkaClusterCredentials',
    'ClusterLinkRemoteKafkaCluster',
    'ClusterLinkRemoteKafkaClusterCredentials',
    'ClusterLinkSourceKafkaCluster',
    'ClusterLinkSourceKafkaClusterCredentials',
    'ConnectorEnvironment',
    'ConnectorKafkaCluster',
    'FlinkComputePoolEnvironment',
    'IdentityPoolIdentityProvider',
    'InvitationCreator',
    'InvitationUser',
    'KafkaAclCredentials',
    'KafkaAclKafkaCluster',
    'KafkaClientQuotaEnvironment',
    'KafkaClientQuotaKafkaCluster',
    'KafkaClientQuotaThroughput',
    'KafkaClusterBasic',
    'KafkaClusterByokKey',
    'KafkaClusterConfigCredentials',
    'KafkaClusterConfigKafkaCluster',
    'KafkaClusterDedicated',
    'KafkaClusterEnterprise',
    'KafkaClusterEnvironment',
    'KafkaClusterNetwork',
    'KafkaClusterStandard',
    'KafkaMirrorTopicClusterLink',
    'KafkaMirrorTopicKafkaCluster',
    'KafkaMirrorTopicKafkaClusterCredentials',
    'KafkaMirrorTopicSourceKafkaTopic',
    'KafkaTopicCredentials',
    'KafkaTopicKafkaCluster',
    'KsqlClusterCredentialIdentity',
    'KsqlClusterEnvironment',
    'KsqlClusterKafkaCluster',
    'NetworkAw',
    'NetworkAzure',
    'NetworkDnsConfig',
    'NetworkEnvironment',
    'NetworkGcp',
    'NetworkLinkEndpointEnvironment',
    'NetworkLinkEndpointNetwork',
    'NetworkLinkEndpointNetworkLinkService',
    'NetworkLinkServiceAccept',
    'NetworkLinkServiceEnvironment',
    'NetworkLinkServiceNetwork',
    'NetworkZoneInfo',
    'PeeringAws',
    'PeeringAzure',
    'PeeringEnvironment',
    'PeeringGcp',
    'PeeringNetwork',
    'PrivateLinkAccessAws',
    'PrivateLinkAccessAzure',
    'PrivateLinkAccessEnvironment',
    'PrivateLinkAccessGcp',
    'PrivateLinkAccessNetwork',
    'PrivateLinkAttachmentAw',
    'PrivateLinkAttachmentAzure',
    'PrivateLinkAttachmentConnectionAws',
    'PrivateLinkAttachmentConnectionAzure',
    'PrivateLinkAttachmentConnectionEnvironment',
    'PrivateLinkAttachmentConnectionGcp',
    'PrivateLinkAttachmentConnectionPrivateLinkAttachment',
    'PrivateLinkAttachmentEnvironment',
    'PrivateLinkAttachmentGcp',
    'SchemaCredentials',
    'SchemaExporterCredentials',
    'SchemaExporterDestinationSchemaRegistryCluster',
    'SchemaExporterDestinationSchemaRegistryClusterCredentials',
    'SchemaExporterSchemaRegistryCluster',
    'SchemaRegistryClusterConfigCredentials',
    'SchemaRegistryClusterConfigSchemaRegistryCluster',
    'SchemaRegistryClusterEnvironment',
    'SchemaRegistryClusterModeCredentials',
    'SchemaRegistryClusterModeSchemaRegistryCluster',
    'SchemaRegistryClusterRegion',
    'SchemaSchemaReference',
    'SchemaSchemaRegistryCluster',
    'SubjectConfigCredentials',
    'SubjectConfigSchemaRegistryCluster',
    'SubjectModeCredentials',
    'SubjectModeSchemaRegistryCluster',
    'TagBindingCredentials',
    'TagBindingSchemaRegistryCluster',
    'TagCredentials',
    'TagSchemaRegistryCluster',
    'TransitGatewayAttachmentAws',
    'TransitGatewayAttachmentEnvironment',
    'TransitGatewayAttachmentNetwork',
    'GetBusinessMetadataAttributeDefinitionResult',
    'GetBusinessMetadataBindingCredentialsResult',
    'GetBusinessMetadataBindingSchemaRegistryClusterResult',
    'GetBusinessMetadataCredentialsResult',
    'GetBusinessMetadataSchemaRegistryClusterResult',
    'GetByokKeyAwResult',
    'GetByokKeyAzureResult',
    'GetFlinkComputePoolEnvironmentResult',
    'GetIdentityPoolIdentityProviderResult',
    'GetInvitationCreatorResult',
    'GetInvitationUserResult',
    'GetKafkaClientQuotaEnvironmentResult',
    'GetKafkaClientQuotaKafkaClusterResult',
    'GetKafkaClientQuotaThroughputResult',
    'GetKafkaClusterBasicResult',
    'GetKafkaClusterByokKeyResult',
    'GetKafkaClusterDedicatedResult',
    'GetKafkaClusterEnterpriseResult',
    'GetKafkaClusterEnvironmentResult',
    'GetKafkaClusterNetworkResult',
    'GetKafkaClusterStandardResult',
    'GetKafkaTopicCredentialsResult',
    'GetKafkaTopicKafkaClusterResult',
    'GetKsqlClusterCredentialIdentityResult',
    'GetKsqlClusterEnvironmentResult',
    'GetKsqlClusterKafkaClusterResult',
    'GetNetworkAwResult',
    'GetNetworkAzureResult',
    'GetNetworkDnsConfigResult',
    'GetNetworkEnvironmentResult',
    'GetNetworkGcpResult',
    'GetNetworkLinkEndpointEnvironmentResult',
    'GetNetworkLinkEndpointNetworkResult',
    'GetNetworkLinkEndpointNetworkLinkServiceResult',
    'GetNetworkLinkServiceAcceptResult',
    'GetNetworkLinkServiceEnvironmentResult',
    'GetNetworkLinkServiceNetworkResult',
    'GetNetworkZoneInfoResult',
    'GetPeeringAwResult',
    'GetPeeringAzureResult',
    'GetPeeringEnvironmentResult',
    'GetPeeringGcpResult',
    'GetPeeringNetworkResult',
    'GetPrivateLinkAccessAwResult',
    'GetPrivateLinkAccessAzureResult',
    'GetPrivateLinkAccessEnvironmentResult',
    'GetPrivateLinkAccessGcpResult',
    'GetPrivateLinkAccessNetworkResult',
    'GetPrivateLinkAttachmentAwResult',
    'GetPrivateLinkAttachmentAzureResult',
    'GetPrivateLinkAttachmentConnectionAwResult',
    'GetPrivateLinkAttachmentConnectionAzureResult',
    'GetPrivateLinkAttachmentConnectionEnvironmentResult',
    'GetPrivateLinkAttachmentConnectionGcpResult',
    'GetPrivateLinkAttachmentConnectionPrivateLinkAttachmentResult',
    'GetPrivateLinkAttachmentEnvironmentResult',
    'GetPrivateLinkAttachmentGcpResult',
    'GetSchemaCredentialsResult',
    'GetSchemaRegistryClusterConfigCredentialsResult',
    'GetSchemaRegistryClusterConfigSchemaRegistryClusterResult',
    'GetSchemaRegistryClusterEnvironmentResult',
    'GetSchemaRegistryClusterModeCredentialsResult',
    'GetSchemaRegistryClusterModeSchemaRegistryClusterResult',
    'GetSchemaRegistryClusterRegionResult',
    'GetSchemaRegistryClustersClusterResult',
    'GetSchemaRegistryClustersClusterEnvironmentResult',
    'GetSchemaRegistryClustersClusterRegionResult',
    'GetSchemaSchemaReferenceResult',
    'GetSchemaSchemaRegistryClusterResult',
    'GetSchemasCredentialsResult',
    'GetSchemasFilterResult',
    'GetSchemasSchemaResult',
    'GetSchemasSchemaRegistryClusterResult',
    'GetSchemasSchemaSchemaReferenceResult',
    'GetSubjectConfigCredentialsResult',
    'GetSubjectConfigSchemaRegistryClusterResult',
    'GetSubjectModeCredentialsResult',
    'GetSubjectModeSchemaRegistryClusterResult',
    'GetTagBindingCredentialsResult',
    'GetTagBindingSchemaRegistryClusterResult',
    'GetTagCredentialsResult',
    'GetTagSchemaRegistryClusterResult',
    'GetTransitGatewayAttachmentAwResult',
    'GetTransitGatewayAttachmentEnvironmentResult',
    'GetTransitGatewayAttachmentNetworkResult',
]

@pulumi.output_type
class ApiKeyManagedResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiKeyManagedResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiKeyManagedResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiKeyManagedResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: str,
                 environment: 'outputs.ApiKeyManagedResourceEnvironment',
                 id: str,
                 kind: str):
        """
        :param str api_version: The API group and version of the managed resource that the API Key associated with, for example, `cmk/v2`.
        :param str id: The ID of the Environment that the managed resource belongs to, for example, `env-abc123`.
        :param str kind: The kind of the managed resource that the API Key associated with, for example, `Cluster`.
        """
        ApiKeyManagedResource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_version=api_version,
            environment=environment,
            id=id,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_version: Optional[str] = None,
             environment: Optional['outputs.ApiKeyManagedResourceEnvironment'] = None,
             id: Optional[str] = None,
             kind: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_version is None and 'apiVersion' in kwargs:
            api_version = kwargs['apiVersion']
        if api_version is None:
            raise TypeError("Missing 'api_version' argument")
        if environment is None:
            raise TypeError("Missing 'environment' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")

        _setter("api_version", api_version)
        _setter("environment", environment)
        _setter("id", id)
        _setter("kind", kind)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> str:
        """
        The API group and version of the managed resource that the API Key associated with, for example, `cmk/v2`.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter
    def environment(self) -> 'outputs.ApiKeyManagedResourceEnvironment':
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the managed resource belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The kind of the managed resource that the API Key associated with, for example, `Cluster`.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class ApiKeyManagedResourceEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the managed resource belongs to, for example, `env-abc123`.
        """
        ApiKeyManagedResourceEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the managed resource belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApiKeyOwner(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiKeyOwner. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiKeyOwner.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiKeyOwner.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: str,
                 id: str,
                 kind: str):
        """
        :param str api_version: The API group and version of the managed resource that the API Key associated with, for example, `cmk/v2`.
        :param str id: The ID of the Environment that the managed resource belongs to, for example, `env-abc123`.
        :param str kind: The kind of the managed resource that the API Key associated with, for example, `Cluster`.
        """
        ApiKeyOwner._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_version=api_version,
            id=id,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_version: Optional[str] = None,
             id: Optional[str] = None,
             kind: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_version is None and 'apiVersion' in kwargs:
            api_version = kwargs['apiVersion']
        if api_version is None:
            raise TypeError("Missing 'api_version' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")

        _setter("api_version", api_version)
        _setter("id", id)
        _setter("kind", kind)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> str:
        """
        The API group and version of the managed resource that the API Key associated with, for example, `cmk/v2`.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the managed resource belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The kind of the managed resource that the API Key associated with, for example, `Cluster`.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class BusinessMetadataAttributeDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"
        elif key == "isOptional":
            suggest = "is_optional"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessMetadataAttributeDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessMetadataAttributeDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessMetadataAttributeDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 default_value: Optional[str] = None,
                 description: Optional[str] = None,
                 is_optional: Optional[bool] = None,
                 options: Optional[Mapping[str, str]] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the attribute.
        :param str default_value: The default value of this attribute.
        :param str description: The description of the Business Metadata.
        :param bool is_optional: An optional flag to control whether the attribute should be optional or required. The default value is `false`.
        :param Mapping[str, str] options: (Optional Map) Block for the attribute options:
        :param str type: (Required String) The type of the attribute, it always returns `string`.
        """
        BusinessMetadataAttributeDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            default_value=default_value,
            description=description,
            is_optional=is_optional,
            options=options,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             default_value: Optional[str] = None,
             description: Optional[str] = None,
             is_optional: Optional[bool] = None,
             options: Optional[Mapping[str, str]] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if default_value is None and 'defaultValue' in kwargs:
            default_value = kwargs['defaultValue']
        if is_optional is None and 'isOptional' in kwargs:
            is_optional = kwargs['isOptional']

        _setter("name", name)
        if default_value is not None:
            _setter("default_value", default_value)
        if description is not None:
            _setter("description", description)
        if is_optional is not None:
            _setter("is_optional", is_optional)
        if options is not None:
            _setter("options", options)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        """
        The default value of this attribute.
        """
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the Business Metadata.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isOptional")
    def is_optional(self) -> Optional[bool]:
        """
        An optional flag to control whether the attribute should be optional or required. The default value is `false`.
        """
        return pulumi.get(self, "is_optional")

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, str]]:
        """
        (Optional Map) Block for the attribute options:
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        (Required String) The type of the attribute, it always returns `string`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class BusinessMetadataBindingCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
        """
        BusinessMetadataBindingCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class BusinessMetadataBindingSchemaRegistryCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        BusinessMetadataBindingSchemaRegistryCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BusinessMetadataCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        """
        BusinessMetadataCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        return pulumi.get(self, "secret")


@pulumi.output_type
class BusinessMetadataSchemaRegistryCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        BusinessMetadataSchemaRegistryCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ByokKeyAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyArn":
            suggest = "key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ByokKeyAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ByokKeyAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ByokKeyAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_arn: str,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str key_arn: The Amazon Resource Name (ARN) of an AWS KMS key.
        :param Sequence[str] roles: (Optional List of Strings) The Amazon Resource Names (ARNs) of IAM Roles created for this key-environment
        """
        ByokKeyAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_arn=key_arn,
            roles=roles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_arn: Optional[str] = None,
             roles: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_arn is None and 'keyArn' in kwargs:
            key_arn = kwargs['keyArn']
        if key_arn is None:
            raise TypeError("Missing 'key_arn' argument")

        _setter("key_arn", key_arn)
        if roles is not None:
            _setter("roles", roles)

    @property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of an AWS KMS key.
        """
        return pulumi.get(self, "key_arn")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        (Optional List of Strings) The Amazon Resource Names (ARNs) of IAM Roles created for this key-environment
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class ByokKeyAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyIdentifier":
            suggest = "key_identifier"
        elif key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "applicationId":
            suggest = "application_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ByokKeyAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ByokKeyAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ByokKeyAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_identifier: str,
                 key_vault_id: str,
                 tenant_id: str,
                 application_id: Optional[str] = None):
        """
        :param str key_identifier: The unique Key Object Identifier URL of an Azure Key Vault key.
        :param str key_vault_id: Key Vault ID containing the key.
        :param str tenant_id: Tenant ID (uuid) hosting the Key Vault containing the key.
        :param str application_id: (Optional String) The Application ID created for this key-environment combination.
        """
        ByokKeyAzure._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_identifier=key_identifier,
            key_vault_id=key_vault_id,
            tenant_id=tenant_id,
            application_id=application_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_identifier: Optional[str] = None,
             key_vault_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             application_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_identifier is None and 'keyIdentifier' in kwargs:
            key_identifier = kwargs['keyIdentifier']
        if key_identifier is None:
            raise TypeError("Missing 'key_identifier' argument")
        if key_vault_id is None and 'keyVaultId' in kwargs:
            key_vault_id = kwargs['keyVaultId']
        if key_vault_id is None:
            raise TypeError("Missing 'key_vault_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if application_id is None and 'applicationId' in kwargs:
            application_id = kwargs['applicationId']

        _setter("key_identifier", key_identifier)
        _setter("key_vault_id", key_vault_id)
        _setter("tenant_id", tenant_id)
        if application_id is not None:
            _setter("application_id", application_id)

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> str:
        """
        The unique Key Object Identifier URL of an Azure Key Vault key.
        """
        return pulumi.get(self, "key_identifier")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        Key Vault ID containing the key.
        """
        return pulumi.get(self, "key_vault_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Tenant ID (uuid) hosting the Key Vault containing the key.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        (Optional String) The Application ID created for this key-environment combination.
        """
        return pulumi.get(self, "application_id")


@pulumi.output_type
class ClusterLinkDestinationKafkaCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootstrapEndpoint":
            suggest = "bootstrap_endpoint"
        elif key == "restEndpoint":
            suggest = "rest_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterLinkDestinationKafkaCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterLinkDestinationKafkaCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterLinkDestinationKafkaCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 bootstrap_endpoint: Optional[str] = None,
                 credentials: Optional['outputs.ClusterLinkDestinationKafkaClusterCredentials'] = None,
                 rest_endpoint: Optional[str] = None):
        """
        :param str id: The ID of the remote Kafka cluster, for example, `lkc-abc123`.
        :param str bootstrap_endpoint: The bootstrap endpoint of the remote Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        :param str rest_endpoint: The REST endpoint of the remote Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        ClusterLinkDestinationKafkaCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            bootstrap_endpoint=bootstrap_endpoint,
            credentials=credentials,
            rest_endpoint=rest_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             bootstrap_endpoint: Optional[str] = None,
             credentials: Optional['outputs.ClusterLinkDestinationKafkaClusterCredentials'] = None,
             rest_endpoint: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if bootstrap_endpoint is None and 'bootstrapEndpoint' in kwargs:
            bootstrap_endpoint = kwargs['bootstrapEndpoint']
        if rest_endpoint is None and 'restEndpoint' in kwargs:
            rest_endpoint = kwargs['restEndpoint']

        _setter("id", id)
        if bootstrap_endpoint is not None:
            _setter("bootstrap_endpoint", bootstrap_endpoint)
        if credentials is not None:
            _setter("credentials", credentials)
        if rest_endpoint is not None:
            _setter("rest_endpoint", rest_endpoint)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the remote Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="bootstrapEndpoint")
    def bootstrap_endpoint(self) -> Optional[str]:
        """
        The bootstrap endpoint of the remote Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        """
        return pulumi.get(self, "bootstrap_endpoint")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.ClusterLinkDestinationKafkaClusterCredentials']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> Optional[str]:
        """
        The REST endpoint of the remote Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        return pulumi.get(self, "rest_endpoint")


@pulumi.output_type
class ClusterLinkDestinationKafkaClusterCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Kafka API Key.
        :param str secret: The Kafka API Secret.
        """
        ClusterLinkDestinationKafkaClusterCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Kafka API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ClusterLinkLocalKafkaCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootstrapEndpoint":
            suggest = "bootstrap_endpoint"
        elif key == "restEndpoint":
            suggest = "rest_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterLinkLocalKafkaCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterLinkLocalKafkaCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterLinkLocalKafkaCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 bootstrap_endpoint: Optional[str] = None,
                 credentials: Optional['outputs.ClusterLinkLocalKafkaClusterCredentials'] = None,
                 rest_endpoint: Optional[str] = None):
        """
        :param str id: The ID of the remote Kafka cluster, for example, `lkc-abc123`.
        :param str bootstrap_endpoint: The bootstrap endpoint of the remote Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        :param str rest_endpoint: The REST endpoint of the remote Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        ClusterLinkLocalKafkaCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            bootstrap_endpoint=bootstrap_endpoint,
            credentials=credentials,
            rest_endpoint=rest_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             bootstrap_endpoint: Optional[str] = None,
             credentials: Optional['outputs.ClusterLinkLocalKafkaClusterCredentials'] = None,
             rest_endpoint: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if bootstrap_endpoint is None and 'bootstrapEndpoint' in kwargs:
            bootstrap_endpoint = kwargs['bootstrapEndpoint']
        if rest_endpoint is None and 'restEndpoint' in kwargs:
            rest_endpoint = kwargs['restEndpoint']

        _setter("id", id)
        if bootstrap_endpoint is not None:
            _setter("bootstrap_endpoint", bootstrap_endpoint)
        if credentials is not None:
            _setter("credentials", credentials)
        if rest_endpoint is not None:
            _setter("rest_endpoint", rest_endpoint)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the remote Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="bootstrapEndpoint")
    def bootstrap_endpoint(self) -> Optional[str]:
        """
        The bootstrap endpoint of the remote Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        """
        return pulumi.get(self, "bootstrap_endpoint")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.ClusterLinkLocalKafkaClusterCredentials']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> Optional[str]:
        """
        The REST endpoint of the remote Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        return pulumi.get(self, "rest_endpoint")


@pulumi.output_type
class ClusterLinkLocalKafkaClusterCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Kafka API Key.
        :param str secret: The Kafka API Secret.
        """
        ClusterLinkLocalKafkaClusterCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Kafka API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ClusterLinkRemoteKafkaCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootstrapEndpoint":
            suggest = "bootstrap_endpoint"
        elif key == "restEndpoint":
            suggest = "rest_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterLinkRemoteKafkaCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterLinkRemoteKafkaCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterLinkRemoteKafkaCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 bootstrap_endpoint: Optional[str] = None,
                 credentials: Optional['outputs.ClusterLinkRemoteKafkaClusterCredentials'] = None,
                 rest_endpoint: Optional[str] = None):
        """
        :param str id: The ID of the remote Kafka cluster, for example, `lkc-abc123`.
        :param str bootstrap_endpoint: The bootstrap endpoint of the remote Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        :param str rest_endpoint: The REST endpoint of the remote Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        ClusterLinkRemoteKafkaCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            bootstrap_endpoint=bootstrap_endpoint,
            credentials=credentials,
            rest_endpoint=rest_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             bootstrap_endpoint: Optional[str] = None,
             credentials: Optional['outputs.ClusterLinkRemoteKafkaClusterCredentials'] = None,
             rest_endpoint: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if bootstrap_endpoint is None and 'bootstrapEndpoint' in kwargs:
            bootstrap_endpoint = kwargs['bootstrapEndpoint']
        if rest_endpoint is None and 'restEndpoint' in kwargs:
            rest_endpoint = kwargs['restEndpoint']

        _setter("id", id)
        if bootstrap_endpoint is not None:
            _setter("bootstrap_endpoint", bootstrap_endpoint)
        if credentials is not None:
            _setter("credentials", credentials)
        if rest_endpoint is not None:
            _setter("rest_endpoint", rest_endpoint)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the remote Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="bootstrapEndpoint")
    def bootstrap_endpoint(self) -> Optional[str]:
        """
        The bootstrap endpoint of the remote Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        """
        return pulumi.get(self, "bootstrap_endpoint")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.ClusterLinkRemoteKafkaClusterCredentials']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> Optional[str]:
        """
        The REST endpoint of the remote Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        return pulumi.get(self, "rest_endpoint")


@pulumi.output_type
class ClusterLinkRemoteKafkaClusterCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Kafka API Key.
        :param str secret: The Kafka API Secret.
        """
        ClusterLinkRemoteKafkaClusterCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Kafka API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ClusterLinkSourceKafkaCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootstrapEndpoint":
            suggest = "bootstrap_endpoint"
        elif key == "restEndpoint":
            suggest = "rest_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterLinkSourceKafkaCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterLinkSourceKafkaCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterLinkSourceKafkaCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 bootstrap_endpoint: Optional[str] = None,
                 credentials: Optional['outputs.ClusterLinkSourceKafkaClusterCredentials'] = None,
                 rest_endpoint: Optional[str] = None):
        """
        :param str id: The ID of the remote Kafka cluster, for example, `lkc-abc123`.
        :param str bootstrap_endpoint: The bootstrap endpoint of the remote Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        :param str rest_endpoint: The REST endpoint of the remote Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        ClusterLinkSourceKafkaCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            bootstrap_endpoint=bootstrap_endpoint,
            credentials=credentials,
            rest_endpoint=rest_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             bootstrap_endpoint: Optional[str] = None,
             credentials: Optional['outputs.ClusterLinkSourceKafkaClusterCredentials'] = None,
             rest_endpoint: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if bootstrap_endpoint is None and 'bootstrapEndpoint' in kwargs:
            bootstrap_endpoint = kwargs['bootstrapEndpoint']
        if rest_endpoint is None and 'restEndpoint' in kwargs:
            rest_endpoint = kwargs['restEndpoint']

        _setter("id", id)
        if bootstrap_endpoint is not None:
            _setter("bootstrap_endpoint", bootstrap_endpoint)
        if credentials is not None:
            _setter("credentials", credentials)
        if rest_endpoint is not None:
            _setter("rest_endpoint", rest_endpoint)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the remote Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="bootstrapEndpoint")
    def bootstrap_endpoint(self) -> Optional[str]:
        """
        The bootstrap endpoint of the remote Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        """
        return pulumi.get(self, "bootstrap_endpoint")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.ClusterLinkSourceKafkaClusterCredentials']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> Optional[str]:
        """
        The REST endpoint of the remote Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        return pulumi.get(self, "rest_endpoint")


@pulumi.output_type
class ClusterLinkSourceKafkaClusterCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Kafka API Key.
        :param str secret: The Kafka API Secret.
        """
        ClusterLinkSourceKafkaClusterCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Kafka API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ConnectorEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Kafka cluster that the connector belongs to, for example, `lkc-abc123`.
        """
        ConnectorEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Kafka cluster that the connector belongs to, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ConnectorKafkaCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Kafka cluster that the connector belongs to, for example, `lkc-abc123`.
        """
        ConnectorKafkaCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Kafka cluster that the connector belongs to, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class FlinkComputePoolEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Flink Compute Pool belongs to, for example, `env-abc123`.
        """
        FlinkComputePoolEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Flink Compute Pool belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class IdentityPoolIdentityProvider(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Identity Provider associated with the Identity Pool, for example, `op-abc123`.
        """
        IdentityPoolIdentityProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Identity Provider associated with the Identity Pool, for example, `op-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class InvitationCreator(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        :param str id: (Required String) The id of invitation creator.
        """
        InvitationCreator._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        (Required String) The id of invitation creator.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class InvitationUser(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        :param str id: (Required String) The id of invitation creator.
        """
        InvitationUser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        (Required String) The id of invitation creator.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KafkaAclCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Kafka API Key.
        :param str secret: The Kafka API Secret.
        """
        KafkaAclCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Kafka API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class KafkaAclKafkaCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        KafkaAclKafkaCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KafkaClientQuotaEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.
               
               > **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.
               
               > **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
        """
        KafkaClientQuotaEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.

        > **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.

        > **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KafkaClientQuotaKafkaCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.
               
               > **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.
               
               > **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
        """
        KafkaClientQuotaKafkaCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.

        > **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.

        > **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KafkaClientQuotaThroughput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "egressByteRate":
            suggest = "egress_byte_rate"
        elif key == "ingressByteRate":
            suggest = "ingress_byte_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClientQuotaThroughput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClientQuotaThroughput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClientQuotaThroughput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 egress_byte_rate: str,
                 ingress_byte_rate: str):
        """
        :param str egress_byte_rate: The egress throughput limit in bytes per second.
        :param str ingress_byte_rate: The ingress throughput limit in bytes per second.
        """
        KafkaClientQuotaThroughput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            egress_byte_rate=egress_byte_rate,
            ingress_byte_rate=ingress_byte_rate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             egress_byte_rate: Optional[str] = None,
             ingress_byte_rate: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if egress_byte_rate is None and 'egressByteRate' in kwargs:
            egress_byte_rate = kwargs['egressByteRate']
        if egress_byte_rate is None:
            raise TypeError("Missing 'egress_byte_rate' argument")
        if ingress_byte_rate is None and 'ingressByteRate' in kwargs:
            ingress_byte_rate = kwargs['ingressByteRate']
        if ingress_byte_rate is None:
            raise TypeError("Missing 'ingress_byte_rate' argument")

        _setter("egress_byte_rate", egress_byte_rate)
        _setter("ingress_byte_rate", ingress_byte_rate)

    @property
    @pulumi.getter(name="egressByteRate")
    def egress_byte_rate(self) -> str:
        """
        The egress throughput limit in bytes per second.
        """
        return pulumi.get(self, "egress_byte_rate")

    @property
    @pulumi.getter(name="ingressByteRate")
    def ingress_byte_rate(self) -> str:
        """
        The ingress throughput limit in bytes per second.
        """
        return pulumi.get(self, "ingress_byte_rate")


@pulumi.output_type
class KafkaClusterBasic(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class KafkaClusterByokKey(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Confluent key that is used to encrypt the data in the Kafka cluster, for example, `cck-lye5m`.
        """
        KafkaClusterByokKey._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Confluent key that is used to encrypt the data in the Kafka cluster, for example, `cck-lye5m`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KafkaClusterConfigCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Kafka API Key.
        :param str secret: The Kafka API Secret.
               
               > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Kafka API key, create a new Kafka API key, update the `credentials` block in all configuration files to use the new Kafka API key, run `pulumi up -target="confluent_kafka_cluster_config.orders"`, and remove the old Kafka API key. Alternatively, in case the old Kafka API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_kafka_cluster_config.orders" -out=rotate-kafka-api-key` and `pulumi up rotate-kafka-api-key` instead.
        """
        KafkaClusterConfigCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Kafka API Secret.

        > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Kafka API key, create a new Kafka API key, update the `credentials` block in all configuration files to use the new Kafka API key, run `pulumi up -target="confluent_kafka_cluster_config.orders"`, and remove the old Kafka API key. Alternatively, in case the old Kafka API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_kafka_cluster_config.orders" -out=rotate-kafka-api-key` and `pulumi up rotate-kafka-api-key` instead.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class KafkaClusterConfigKafkaCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Dedicated Kafka cluster, for example, `lkc-abc123`.
        """
        KafkaClusterConfigKafkaCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Dedicated Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KafkaClusterDedicated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKey":
            suggest = "encryption_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterDedicated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterDedicated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterDedicated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cku: int,
                 encryption_key: Optional[str] = None,
                 zones: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] zones: (Required List of String) The list of zones the cluster is in.
               On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
               On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones), for example, `us-central1-c`.
               On Azure, zones are Confluent-chosen names (for example, `1`, `2`, `3`) since Azure does not have universal zone identifiers.
        """
        KafkaClusterDedicated._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cku=cku,
            encryption_key=encryption_key,
            zones=zones,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cku: Optional[int] = None,
             encryption_key: Optional[str] = None,
             zones: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cku is None:
            raise TypeError("Missing 'cku' argument")
        if encryption_key is None and 'encryptionKey' in kwargs:
            encryption_key = kwargs['encryptionKey']

        _setter("cku", cku)
        if encryption_key is not None:
            _setter("encryption_key", encryption_key)
        if zones is not None:
            _setter("zones", zones)

    @property
    @pulumi.getter
    def cku(self) -> int:
        return pulumi.get(self, "cku")

    @property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> Optional[str]:
        return pulumi.get(self, "encryption_key")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[str]]:
        """
        (Required List of String) The list of zones the cluster is in.
        On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
        On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones), for example, `us-central1-c`.
        On Azure, zones are Confluent-chosen names (for example, `1`, `2`, `3`) since Azure does not have universal zone identifiers.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class KafkaClusterEnterprise(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class KafkaClusterEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Confluent key that is used to encrypt the data in the Kafka cluster, for example, `cck-lye5m`.
        """
        KafkaClusterEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Confluent key that is used to encrypt the data in the Kafka cluster, for example, `cck-lye5m`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KafkaClusterNetwork(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Confluent key that is used to encrypt the data in the Kafka cluster, for example, `cck-lye5m`.
        """
        KafkaClusterNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Confluent key that is used to encrypt the data in the Kafka cluster, for example, `cck-lye5m`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KafkaClusterStandard(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class KafkaMirrorTopicClusterLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkName":
            suggest = "link_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaMirrorTopicClusterLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaMirrorTopicClusterLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaMirrorTopicClusterLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 link_name: str):
        """
        :param str link_name: The name of the cluster link to attach to the mirror topic, for example, `my-cluster-link`.
        """
        KafkaMirrorTopicClusterLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            link_name=link_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             link_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if link_name is None and 'linkName' in kwargs:
            link_name = kwargs['linkName']
        if link_name is None:
            raise TypeError("Missing 'link_name' argument")

        _setter("link_name", link_name)

    @property
    @pulumi.getter(name="linkName")
    def link_name(self) -> str:
        """
        The name of the cluster link to attach to the mirror topic, for example, `my-cluster-link`.
        """
        return pulumi.get(self, "link_name")


@pulumi.output_type
class KafkaMirrorTopicKafkaCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restEndpoint":
            suggest = "rest_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaMirrorTopicKafkaCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaMirrorTopicKafkaCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaMirrorTopicKafkaCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 credentials: Optional['outputs.KafkaMirrorTopicKafkaClusterCredentials'] = None,
                 rest_endpoint: Optional[str] = None):
        """
        :param str id: The ID of the destination Kafka cluster, for example, `lkc-abc123`.
        :param str rest_endpoint: The REST endpoint of the destination Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        KafkaMirrorTopicKafkaCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            credentials=credentials,
            rest_endpoint=rest_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             credentials: Optional['outputs.KafkaMirrorTopicKafkaClusterCredentials'] = None,
             rest_endpoint: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if rest_endpoint is None and 'restEndpoint' in kwargs:
            rest_endpoint = kwargs['restEndpoint']

        _setter("id", id)
        if credentials is not None:
            _setter("credentials", credentials)
        if rest_endpoint is not None:
            _setter("rest_endpoint", rest_endpoint)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the destination Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.KafkaMirrorTopicKafkaClusterCredentials']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> Optional[str]:
        """
        The REST endpoint of the destination Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        return pulumi.get(self, "rest_endpoint")


@pulumi.output_type
class KafkaMirrorTopicKafkaClusterCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Kafka API Key.
        :param str secret: The Kafka API Secret.
        """
        KafkaMirrorTopicKafkaClusterCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Kafka API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class KafkaMirrorTopicSourceKafkaTopic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicName":
            suggest = "topic_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaMirrorTopicSourceKafkaTopic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaMirrorTopicSourceKafkaTopic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaMirrorTopicSourceKafkaTopic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic_name: str):
        """
        :param str topic_name: The name of the topic on the source cluster to be mirrored over the cluster link, for example, `orders`. A topic with the exact same name must exist on the source cluster, and no topic with this name should exist on the destination cluster.
        """
        KafkaMirrorTopicSourceKafkaTopic._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            topic_name=topic_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             topic_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if topic_name is None and 'topicName' in kwargs:
            topic_name = kwargs['topicName']
        if topic_name is None:
            raise TypeError("Missing 'topic_name' argument")

        _setter("topic_name", topic_name)

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> str:
        """
        The name of the topic on the source cluster to be mirrored over the cluster link, for example, `orders`. A topic with the exact same name must exist on the source cluster, and no topic with this name should exist on the destination cluster.
        """
        return pulumi.get(self, "topic_name")


@pulumi.output_type
class KafkaTopicCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Kafka API Key.
        :param str secret: The Kafka API Secret.
               
               > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Kafka API key, create a new Kafka API key, update the `credentials` block in all configuration files to use the new Kafka API key, run `pulumi up -target="confluent_kafka_topic.orders"`, and remove the old Kafka API key. Alternatively, in case the old Kafka API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_kafka_topic.orders" -out=rotate-kafka-api-key` and `pulumi up rotate-kafka-api-key` instead.
        """
        KafkaTopicCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Kafka API Secret.

        > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Kafka API key, create a new Kafka API key, update the `credentials` block in all configuration files to use the new Kafka API key, run `pulumi up -target="confluent_kafka_topic.orders"`, and remove the old Kafka API key. Alternatively, in case the old Kafka API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_kafka_topic.orders" -out=rotate-kafka-api-key` and `pulumi up rotate-kafka-api-key` instead.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class KafkaTopicKafkaCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        KafkaTopicKafkaCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KsqlClusterCredentialIdentity(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the associated service or user account, for example, `sa-abc123`.
        """
        KsqlClusterCredentialIdentity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the associated service or user account, for example, `sa-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KsqlClusterEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the associated service or user account, for example, `sa-abc123`.
        """
        KsqlClusterEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the associated service or user account, for example, `sa-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KsqlClusterKafkaCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the associated service or user account, for example, `sa-abc123`.
        """
        KsqlClusterKafkaCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the associated service or user account, for example, `sa-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NetworkAw(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkEndpointService":
            suggest = "private_link_endpoint_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAw. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAw.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAw.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account: Optional[str] = None,
                 private_link_endpoint_service: Optional[str] = None,
                 vpc: Optional[str] = None):
        """
        :param str account: (Required String) The AWS account ID associated with the Confluent Cloud VPC.
        :param str private_link_endpoint_service: (Optional String) The endpoint service of the Confluent Cloud VPC (used for PrivateLink) if available.
        :param str vpc: (Required String) The Confluent Cloud VPC ID.
        """
        NetworkAw._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account=account,
            private_link_endpoint_service=private_link_endpoint_service,
            vpc=vpc,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account: Optional[str] = None,
             private_link_endpoint_service: Optional[str] = None,
             vpc: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_link_endpoint_service is None and 'privateLinkEndpointService' in kwargs:
            private_link_endpoint_service = kwargs['privateLinkEndpointService']

        if account is not None:
            _setter("account", account)
        if private_link_endpoint_service is not None:
            _setter("private_link_endpoint_service", private_link_endpoint_service)
        if vpc is not None:
            _setter("vpc", vpc)

    @property
    @pulumi.getter
    def account(self) -> Optional[str]:
        """
        (Required String) The AWS account ID associated with the Confluent Cloud VPC.
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter(name="privateLinkEndpointService")
    def private_link_endpoint_service(self) -> Optional[str]:
        """
        (Optional String) The endpoint service of the Confluent Cloud VPC (used for PrivateLink) if available.
        """
        return pulumi.get(self, "private_link_endpoint_service")

    @property
    @pulumi.getter
    def vpc(self) -> Optional[str]:
        """
        (Required String) The Confluent Cloud VPC ID.
        """
        return pulumi.get(self, "vpc")


@pulumi.output_type
class NetworkAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkServiceAliases":
            suggest = "private_link_service_aliases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_link_service_aliases: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] private_link_service_aliases: (Optional Map) The mapping of zones to Private Link Service Aliases if available. Keys are zone names, for example, `1` and values are [Azure Private Link Service Aliases](https://docs.microsoft.com/en-us/azure/private-link/private-link-service-overview#share-your-service), for example, `s-nk99e-privatelink-1.8c43dcd0-695c-1234-bc35-11fe6abb303a.centralus.azure.privatelinkservice`.
        """
        NetworkAzure._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_link_service_aliases=private_link_service_aliases,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_link_service_aliases: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_link_service_aliases is None and 'privateLinkServiceAliases' in kwargs:
            private_link_service_aliases = kwargs['privateLinkServiceAliases']

        if private_link_service_aliases is not None:
            _setter("private_link_service_aliases", private_link_service_aliases)

    @property
    @pulumi.getter(name="privateLinkServiceAliases")
    def private_link_service_aliases(self) -> Optional[Mapping[str, str]]:
        """
        (Optional Map) The mapping of zones to Private Link Service Aliases if available. Keys are zone names, for example, `1` and values are [Azure Private Link Service Aliases](https://docs.microsoft.com/en-us/azure/private-link/private-link-service-overview#share-your-service), for example, `s-nk99e-privatelink-1.8c43dcd0-695c-1234-bc35-11fe6abb303a.centralus.azure.privatelinkservice`.
        """
        return pulumi.get(self, "private_link_service_aliases")


@pulumi.output_type
class NetworkDnsConfig(dict):
    def __init__(__self__, *,
                 resolution: str):
        """
        :param str resolution: Network DNS resolution.
               When resolution is `CHASED_PRIVATE`, clusters in this network require both public and private DNS to resolve cluster endpoints.
               When resolution is `PRIVATE`, clusters in this network only require private DNS to resolve cluster endpoints.
        """
        NetworkDnsConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resolution=resolution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resolution: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resolution is None:
            raise TypeError("Missing 'resolution' argument")

        _setter("resolution", resolution)

    @property
    @pulumi.getter
    def resolution(self) -> str:
        """
        Network DNS resolution.
        When resolution is `CHASED_PRIVATE`, clusters in this network require both public and private DNS to resolve cluster endpoints.
        When resolution is `PRIVATE`, clusters in this network only require private DNS to resolve cluster endpoints.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class NetworkEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Network belongs to, for example, `env-abc123`.
        """
        NetworkEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Network belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NetworkGcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateServiceConnectServiceAttachments":
            suggest = "private_service_connect_service_attachments"
        elif key == "vpcNetwork":
            suggest = "vpc_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkGcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkGcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkGcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_service_connect_service_attachments: Optional[Mapping[str, str]] = None,
                 project: Optional[str] = None,
                 vpc_network: Optional[str] = None):
        """
        :param Mapping[str, str] private_service_connect_service_attachments: (Optional Map) The mapping of zones to Private Service Connect Service Attachments if available. Keys are zones and values are [GCP Private Service Connect service attachment](https://cloud.google.com/vpc/docs/configure-private-service-connect-producer#api_7).
        :param str project: (Required String) The GCP Project ID associated with the Confluent Cloud VPC.
        :param str vpc_network: (Required String) The network name of the Confluent Cloud VPC.
        """
        NetworkGcp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_service_connect_service_attachments=private_service_connect_service_attachments,
            project=project,
            vpc_network=vpc_network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_service_connect_service_attachments: Optional[Mapping[str, str]] = None,
             project: Optional[str] = None,
             vpc_network: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_service_connect_service_attachments is None and 'privateServiceConnectServiceAttachments' in kwargs:
            private_service_connect_service_attachments = kwargs['privateServiceConnectServiceAttachments']
        if vpc_network is None and 'vpcNetwork' in kwargs:
            vpc_network = kwargs['vpcNetwork']

        if private_service_connect_service_attachments is not None:
            _setter("private_service_connect_service_attachments", private_service_connect_service_attachments)
        if project is not None:
            _setter("project", project)
        if vpc_network is not None:
            _setter("vpc_network", vpc_network)

    @property
    @pulumi.getter(name="privateServiceConnectServiceAttachments")
    def private_service_connect_service_attachments(self) -> Optional[Mapping[str, str]]:
        """
        (Optional Map) The mapping of zones to Private Service Connect Service Attachments if available. Keys are zones and values are [GCP Private Service Connect service attachment](https://cloud.google.com/vpc/docs/configure-private-service-connect-producer#api_7).
        """
        return pulumi.get(self, "private_service_connect_service_attachments")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        (Required String) The GCP Project ID associated with the Confluent Cloud VPC.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> Optional[str]:
        """
        (Required String) The network name of the Confluent Cloud VPC.
        """
        return pulumi.get(self, "vpc_network")


@pulumi.output_type
class NetworkLinkEndpointEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        NetworkLinkEndpointEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NetworkLinkEndpointNetwork(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        NetworkLinkEndpointNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NetworkLinkEndpointNetworkLinkService(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        NetworkLinkEndpointNetworkLinkService._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NetworkLinkServiceAccept(dict):
    def __init__(__self__, *,
                 environments: Optional[Sequence[str]] = None,
                 networks: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] environments: List of environments ids from which connections can be accepted. All networks within the list of environment will be allowed.
        :param Sequence[str] networks: List of network ids from which connections can be accepted.
        """
        NetworkLinkServiceAccept._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            environments=environments,
            networks=networks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             environments: Optional[Sequence[str]] = None,
             networks: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if environments is not None:
            _setter("environments", environments)
        if networks is not None:
            _setter("networks", networks)

    @property
    @pulumi.getter
    def environments(self) -> Optional[Sequence[str]]:
        """
        List of environments ids from which connections can be accepted. All networks within the list of environment will be allowed.
        """
        return pulumi.get(self, "environments")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[str]]:
        """
        List of network ids from which connections can be accepted.
        """
        return pulumi.get(self, "networks")


@pulumi.output_type
class NetworkLinkServiceEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Network that the Network Link Service belongs to, for example, `n-abc123`.
        """
        NetworkLinkServiceEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Network that the Network Link Service belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NetworkLinkServiceNetwork(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Network that the Network Link Service belongs to, for example, `n-abc123`.
        """
        NetworkLinkServiceNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Network that the Network Link Service belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NetworkZoneInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkZoneInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkZoneInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkZoneInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 zone_id: Optional[str] = None):
        """
        :param str cidr: The IPv4 CIDR block to be used for the network. Must be `/27`. Required for VPC peering and AWS TransitGateway.
               
               > **Note:** The `zone_info` configuration block and `reserved_cidr` are in a [Limited Availability lifecycle stage](https://docs.confluent.io/cloud/current/api.html#section/Versioning/API-Lifecycle-Policy), and it's available only for AWS networks with PEERING connection type.
        :param str zone_id: Cloud provider zone ID.
        """
        NetworkZoneInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if cidr is not None:
            _setter("cidr", cidr)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        """
        The IPv4 CIDR block to be used for the network. Must be `/27`. Required for VPC peering and AWS TransitGateway.

        > **Note:** The `zone_info` configuration block and `reserved_cidr` are in a [Limited Availability lifecycle stage](https://docs.confluent.io/cloud/current/api.html#section/Versioning/API-Lifecycle-Policy), and it's available only for AWS networks with PEERING connection type.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        Cloud provider zone ID.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class PeeringAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerRegion":
            suggest = "customer_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PeeringAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PeeringAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PeeringAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account: str,
                 customer_region: str,
                 routes: Sequence[str],
                 vpc: str):
        """
        :param str account: The AWS Account ID of the peer VPC owner. You can find your AWS Account ID [here](https://console.aws.amazon.com/billing/home?#/account) under **My Account** section of the AWS Management Console. Must be a **12 character string**.
        :param str customer_region: The region of the Azure peer VNet.
        :param Sequence[str] routes: The AWS VPC CIDR blocks or subsets. This must be from the supported CIDR blocks and must not overlap with your Confluent Cloud CIDR block or any other network peering connection VPC CIDR (learn more about the requirements [here](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html#vpc-peering-on-aws)). You can find AWS VPC CIDR [here](https://console.aws.amazon.com/vpc/) under **Your VPCs > Target VPC > Details** section of the AWS Management Console.
        :param str vpc: The AWS VPC ID of the peer VPC that you're peering with Confluent Cloud. You can find your AWS VPC ID [here](https://console.aws.amazon.com/vpc/) under **Your VPCs** section of the AWS Management Console. Must start with `vpc-`.
        """
        PeeringAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account=account,
            customer_region=customer_region,
            routes=routes,
            vpc=vpc,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account: Optional[str] = None,
             customer_region: Optional[str] = None,
             routes: Optional[Sequence[str]] = None,
             vpc: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account is None:
            raise TypeError("Missing 'account' argument")
        if customer_region is None and 'customerRegion' in kwargs:
            customer_region = kwargs['customerRegion']
        if customer_region is None:
            raise TypeError("Missing 'customer_region' argument")
        if routes is None:
            raise TypeError("Missing 'routes' argument")
        if vpc is None:
            raise TypeError("Missing 'vpc' argument")

        _setter("account", account)
        _setter("customer_region", customer_region)
        _setter("routes", routes)
        _setter("vpc", vpc)

    @property
    @pulumi.getter
    def account(self) -> str:
        """
        The AWS Account ID of the peer VPC owner. You can find your AWS Account ID [here](https://console.aws.amazon.com/billing/home?#/account) under **My Account** section of the AWS Management Console. Must be a **12 character string**.
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter(name="customerRegion")
    def customer_region(self) -> str:
        """
        The region of the Azure peer VNet.
        """
        return pulumi.get(self, "customer_region")

    @property
    @pulumi.getter
    def routes(self) -> Sequence[str]:
        """
        The AWS VPC CIDR blocks or subsets. This must be from the supported CIDR blocks and must not overlap with your Confluent Cloud CIDR block or any other network peering connection VPC CIDR (learn more about the requirements [here](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html#vpc-peering-on-aws)). You can find AWS VPC CIDR [here](https://console.aws.amazon.com/vpc/) under **Your VPCs > Target VPC > Details** section of the AWS Management Console.
        """
        return pulumi.get(self, "routes")

    @property
    @pulumi.getter
    def vpc(self) -> str:
        """
        The AWS VPC ID of the peer VPC that you're peering with Confluent Cloud. You can find your AWS VPC ID [here](https://console.aws.amazon.com/vpc/) under **Your VPCs** section of the AWS Management Console. Must start with `vpc-`.
        """
        return pulumi.get(self, "vpc")


@pulumi.output_type
class PeeringAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerRegion":
            suggest = "customer_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PeeringAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PeeringAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PeeringAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_region: str,
                 tenant: str,
                 vnet: str):
        """
        :param str customer_region: The region of the Azure peer VNet.
        :param str tenant: The Tenant ID that represents an organization in Azure Active Directory. You can find your Azure Tenant ID in the [Azure Portal under Azure Active Directory](https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/Overview). Must be a valid **32 character UUID string**.
        :param str vnet: The resource (composite) ID of the peer Virtual Network that you're peering with Confluent Cloud, in the format `/subscriptions/<Subscription ID>/resourceGroups/<Resource Group Name>/providers/Microsoft.Network/virtualNetworks/<VNet name>`. You can find Subscription ID, Resource Group Name and your VNet name under **Virtual Networks > Target VNet > Essentials** section of your [Microsoft Azure Portal](https://portal.azure.com/).
        """
        PeeringAzure._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            customer_region=customer_region,
            tenant=tenant,
            vnet=vnet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             customer_region: Optional[str] = None,
             tenant: Optional[str] = None,
             vnet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if customer_region is None and 'customerRegion' in kwargs:
            customer_region = kwargs['customerRegion']
        if customer_region is None:
            raise TypeError("Missing 'customer_region' argument")
        if tenant is None:
            raise TypeError("Missing 'tenant' argument")
        if vnet is None:
            raise TypeError("Missing 'vnet' argument")

        _setter("customer_region", customer_region)
        _setter("tenant", tenant)
        _setter("vnet", vnet)

    @property
    @pulumi.getter(name="customerRegion")
    def customer_region(self) -> str:
        """
        The region of the Azure peer VNet.
        """
        return pulumi.get(self, "customer_region")

    @property
    @pulumi.getter
    def tenant(self) -> str:
        """
        The Tenant ID that represents an organization in Azure Active Directory. You can find your Azure Tenant ID in the [Azure Portal under Azure Active Directory](https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/Overview). Must be a valid **32 character UUID string**.
        """
        return pulumi.get(self, "tenant")

    @property
    @pulumi.getter
    def vnet(self) -> str:
        """
        The resource (composite) ID of the peer Virtual Network that you're peering with Confluent Cloud, in the format `/subscriptions/<Subscription ID>/resourceGroups/<Resource Group Name>/providers/Microsoft.Network/virtualNetworks/<VNet name>`. You can find Subscription ID, Resource Group Name and your VNet name under **Virtual Networks > Target VNet > Essentials** section of your [Microsoft Azure Portal](https://portal.azure.com/).
        """
        return pulumi.get(self, "vnet")


@pulumi.output_type
class PeeringEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Network that the Peering belongs to, for example, `n-abc123`.
        """
        PeeringEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Network that the Peering belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PeeringGcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcNetwork":
            suggest = "vpc_network"
        elif key == "importCustomRoutes":
            suggest = "import_custom_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PeeringGcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PeeringGcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PeeringGcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project: str,
                 vpc_network: str,
                 import_custom_routes: Optional[bool] = None):
        """
        :param str project: The GCP Project ID. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).
        :param str vpc_network: The VPC network name that you're peering to Confluent Cloud. You can find your VPC network name under **VPC Networks** section of your [Google Cloud Console](https://console.cloud.google.com/networking/networks/list).
        :param bool import_custom_routes: The Import Custom Routes option enables connectivity to a Confluent Cloud cluster in Google Cloud from customer premise or other clouds, such as AWS and Azure, through a customer VPC that is peered with Confluent Cloud in the same region. Defaults to `false`. Learn more about considerations / limitations of the Import Custom Routes option [here](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html#import-custom-routes).
               
               > **Note:** Exactly one from the `aws`, `azure`, and `gcp` configuration blocks must be specified.
               
               > **Note:** Learn more about VPC Peering requirements on AWS [here](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html#vpc-peering-on-aws).
               
               > **Note:** Learn more about VNet Peering requirements on Azure [here](https://docs.confluent.io/cloud/current/networking/peering/azure-peering.html#vnet-peering-on-az).
               
               > **Note:** Learn more about VPC Peering requirements on Google Cloud Platform [here](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html#vpc-peering-on-gcp).
        """
        PeeringGcp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project=project,
            vpc_network=vpc_network,
            import_custom_routes=import_custom_routes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project: Optional[str] = None,
             vpc_network: Optional[str] = None,
             import_custom_routes: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if project is None:
            raise TypeError("Missing 'project' argument")
        if vpc_network is None and 'vpcNetwork' in kwargs:
            vpc_network = kwargs['vpcNetwork']
        if vpc_network is None:
            raise TypeError("Missing 'vpc_network' argument")
        if import_custom_routes is None and 'importCustomRoutes' in kwargs:
            import_custom_routes = kwargs['importCustomRoutes']

        _setter("project", project)
        _setter("vpc_network", vpc_network)
        if import_custom_routes is not None:
            _setter("import_custom_routes", import_custom_routes)

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        The GCP Project ID. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> str:
        """
        The VPC network name that you're peering to Confluent Cloud. You can find your VPC network name under **VPC Networks** section of your [Google Cloud Console](https://console.cloud.google.com/networking/networks/list).
        """
        return pulumi.get(self, "vpc_network")

    @property
    @pulumi.getter(name="importCustomRoutes")
    def import_custom_routes(self) -> Optional[bool]:
        """
        The Import Custom Routes option enables connectivity to a Confluent Cloud cluster in Google Cloud from customer premise or other clouds, such as AWS and Azure, through a customer VPC that is peered with Confluent Cloud in the same region. Defaults to `false`. Learn more about considerations / limitations of the Import Custom Routes option [here](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html#import-custom-routes).

        > **Note:** Exactly one from the `aws`, `azure`, and `gcp` configuration blocks must be specified.

        > **Note:** Learn more about VPC Peering requirements on AWS [here](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html#vpc-peering-on-aws).

        > **Note:** Learn more about VNet Peering requirements on Azure [here](https://docs.confluent.io/cloud/current/networking/peering/azure-peering.html#vnet-peering-on-az).

        > **Note:** Learn more about VPC Peering requirements on Google Cloud Platform [here](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html#vpc-peering-on-gcp).
        """
        return pulumi.get(self, "import_custom_routes")


@pulumi.output_type
class PeeringNetwork(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Network that the Peering belongs to, for example, `n-abc123`.
        """
        PeeringNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Network that the Peering belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkAccessAws(dict):
    def __init__(__self__, *,
                 account: str):
        """
        :param str account: The AWS account ID to enable for the Private Link Access. You can find your AWS account ID [here] (https://console.aws.amazon.com/billing/home?#/account) under **My Account** in your AWS Management Console. Must be a **12 character string**.
        """
        PrivateLinkAccessAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account=account,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account is None:
            raise TypeError("Missing 'account' argument")

        _setter("account", account)

    @property
    @pulumi.getter
    def account(self) -> str:
        """
        The AWS account ID to enable for the Private Link Access. You can find your AWS account ID [here] (https://console.aws.amazon.com/billing/home?#/account) under **My Account** in your AWS Management Console. Must be a **12 character string**.
        """
        return pulumi.get(self, "account")


@pulumi.output_type
class PrivateLinkAccessAzure(dict):
    def __init__(__self__, *,
                 subscription: str):
        """
        :param str subscription: The Azure subscription ID to enable for the Private Link Access. You can find your Azure subscription ID in the subscription section of your [Microsoft Azure Portal] (https://portal.azure.com/#blade/Microsoft_Azure_Billing/SubscriptionsBlade). Must be a valid **32 character UUID string**.
        """
        PrivateLinkAccessAzure._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subscription=subscription,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subscription: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subscription is None:
            raise TypeError("Missing 'subscription' argument")

        _setter("subscription", subscription)

    @property
    @pulumi.getter
    def subscription(self) -> str:
        """
        The Azure subscription ID to enable for the Private Link Access. You can find your Azure subscription ID in the subscription section of your [Microsoft Azure Portal] (https://portal.azure.com/#blade/Microsoft_Azure_Billing/SubscriptionsBlade). Must be a valid **32 character UUID string**.
        """
        return pulumi.get(self, "subscription")


@pulumi.output_type
class PrivateLinkAccessEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Network that the Private Link Access belongs to, for example, `n-abc123`.
        """
        PrivateLinkAccessEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Network that the Private Link Access belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkAccessGcp(dict):
    def __init__(__self__, *,
                 project: str):
        """
        :param str project: The GCP project ID to allow for Private Service Connect access. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).
               
               > **Note:** Exactly one from the `aws`, `azure`, `gcp` configuration blocks must be specified.
               
               > **Note:** Learn more about Private Link Access limitations on AWS [here](https://docs.confluent.io/cloud/current/networking/private-links/aws-privatelink.html#limitations).
               
               > **Note:** Learn more about Private Link Access limitations on Azure [here](https://docs.confluent.io/cloud/current/networking/private-links/azure-privatelink.html#limitations).
        """
        PrivateLinkAccessGcp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project=project,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if project is None:
            raise TypeError("Missing 'project' argument")

        _setter("project", project)

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        The GCP project ID to allow for Private Service Connect access. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).

        > **Note:** Exactly one from the `aws`, `azure`, `gcp` configuration blocks must be specified.

        > **Note:** Learn more about Private Link Access limitations on AWS [here](https://docs.confluent.io/cloud/current/networking/private-links/aws-privatelink.html#limitations).

        > **Note:** Learn more about Private Link Access limitations on Azure [here](https://docs.confluent.io/cloud/current/networking/private-links/azure-privatelink.html#limitations).
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class PrivateLinkAccessNetwork(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Network that the Private Link Access belongs to, for example, `n-abc123`.
        """
        PrivateLinkAccessNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Network that the Private Link Access belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkAttachmentAw(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcEndpointServiceName":
            suggest = "vpc_endpoint_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkAttachmentAw. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkAttachmentAw.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkAttachmentAw.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vpc_endpoint_service_name: Optional[str] = None):
        """
        :param str vpc_endpoint_service_name: (Required String) AWS VPC Endpoint Service that can be used to establish connections for all zones, for example `com.amazonaws.vpce.us-west-2.vpce-svc-0d3be37e21708ecd3`.
        """
        PrivateLinkAttachmentAw._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            vpc_endpoint_service_name=vpc_endpoint_service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             vpc_endpoint_service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if vpc_endpoint_service_name is None and 'vpcEndpointServiceName' in kwargs:
            vpc_endpoint_service_name = kwargs['vpcEndpointServiceName']

        if vpc_endpoint_service_name is not None:
            _setter("vpc_endpoint_service_name", vpc_endpoint_service_name)

    @property
    @pulumi.getter(name="vpcEndpointServiceName")
    def vpc_endpoint_service_name(self) -> Optional[str]:
        """
        (Required String) AWS VPC Endpoint Service that can be used to establish connections for all zones, for example `com.amazonaws.vpce.us-west-2.vpce-svc-0d3be37e21708ecd3`.
        """
        return pulumi.get(self, "vpc_endpoint_service_name")


@pulumi.output_type
class PrivateLinkAttachmentAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkServiceAlias":
            suggest = "private_link_service_alias"
        elif key == "privateLinkServiceResourceId":
            suggest = "private_link_service_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkAttachmentAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkAttachmentAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkAttachmentAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_link_service_alias: Optional[str] = None,
                 private_link_service_resource_id: Optional[str] = None,
                 zone: Optional[str] = None):
        PrivateLinkAttachmentAzure._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_link_service_alias=private_link_service_alias,
            private_link_service_resource_id=private_link_service_resource_id,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_link_service_alias: Optional[str] = None,
             private_link_service_resource_id: Optional[str] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_link_service_alias is None and 'privateLinkServiceAlias' in kwargs:
            private_link_service_alias = kwargs['privateLinkServiceAlias']
        if private_link_service_resource_id is None and 'privateLinkServiceResourceId' in kwargs:
            private_link_service_resource_id = kwargs['privateLinkServiceResourceId']

        if private_link_service_alias is not None:
            _setter("private_link_service_alias", private_link_service_alias)
        if private_link_service_resource_id is not None:
            _setter("private_link_service_resource_id", private_link_service_resource_id)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="privateLinkServiceAlias")
    def private_link_service_alias(self) -> Optional[str]:
        return pulumi.get(self, "private_link_service_alias")

    @property
    @pulumi.getter(name="privateLinkServiceResourceId")
    def private_link_service_resource_id(self) -> Optional[str]:
        return pulumi.get(self, "private_link_service_resource_id")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        return pulumi.get(self, "zone")


@pulumi.output_type
class PrivateLinkAttachmentConnectionAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcEndpointId":
            suggest = "vpc_endpoint_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkAttachmentConnectionAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkAttachmentConnectionAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkAttachmentConnectionAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vpc_endpoint_id: str):
        """
        :param str vpc_endpoint_id: Id of a VPC Endpoint that is connected to the VPC Endpoint service.
        """
        PrivateLinkAttachmentConnectionAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            vpc_endpoint_id=vpc_endpoint_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             vpc_endpoint_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if vpc_endpoint_id is None and 'vpcEndpointId' in kwargs:
            vpc_endpoint_id = kwargs['vpcEndpointId']
        if vpc_endpoint_id is None:
            raise TypeError("Missing 'vpc_endpoint_id' argument")

        _setter("vpc_endpoint_id", vpc_endpoint_id)

    @property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> str:
        """
        Id of a VPC Endpoint that is connected to the VPC Endpoint service.
        """
        return pulumi.get(self, "vpc_endpoint_id")


@pulumi.output_type
class PrivateLinkAttachmentConnectionAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateEndpointResourceId":
            suggest = "private_endpoint_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkAttachmentConnectionAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkAttachmentConnectionAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkAttachmentConnectionAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_endpoint_resource_id: str):
        PrivateLinkAttachmentConnectionAzure._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_endpoint_resource_id=private_endpoint_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_endpoint_resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_endpoint_resource_id is None and 'privateEndpointResourceId' in kwargs:
            private_endpoint_resource_id = kwargs['privateEndpointResourceId']
        if private_endpoint_resource_id is None:
            raise TypeError("Missing 'private_endpoint_resource_id' argument")

        _setter("private_endpoint_resource_id", private_endpoint_resource_id)

    @property
    @pulumi.getter(name="privateEndpointResourceId")
    def private_endpoint_resource_id(self) -> str:
        return pulumi.get(self, "private_endpoint_resource_id")


@pulumi.output_type
class PrivateLinkAttachmentConnectionEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The unique identifier for the private link attachment.
        """
        PrivateLinkAttachmentConnectionEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier for the private link attachment.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkAttachmentConnectionGcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateServiceConnectConnectionId":
            suggest = "private_service_connect_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkAttachmentConnectionGcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkAttachmentConnectionGcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkAttachmentConnectionGcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_service_connect_connection_id: str):
        PrivateLinkAttachmentConnectionGcp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_service_connect_connection_id=private_service_connect_connection_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_service_connect_connection_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_service_connect_connection_id is None and 'privateServiceConnectConnectionId' in kwargs:
            private_service_connect_connection_id = kwargs['privateServiceConnectConnectionId']
        if private_service_connect_connection_id is None:
            raise TypeError("Missing 'private_service_connect_connection_id' argument")

        _setter("private_service_connect_connection_id", private_service_connect_connection_id)

    @property
    @pulumi.getter(name="privateServiceConnectConnectionId")
    def private_service_connect_connection_id(self) -> str:
        return pulumi.get(self, "private_service_connect_connection_id")


@pulumi.output_type
class PrivateLinkAttachmentConnectionPrivateLinkAttachment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The unique identifier for the private link attachment.
        """
        PrivateLinkAttachmentConnectionPrivateLinkAttachment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier for the private link attachment.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkAttachmentEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Private Link Attachment belongs to, for example `env-xyz456`.
        """
        PrivateLinkAttachmentEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Private Link Attachment belongs to, for example `env-xyz456`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkAttachmentGcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateServiceConnectServiceAttachment":
            suggest = "private_service_connect_service_attachment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkAttachmentGcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkAttachmentGcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkAttachmentGcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_service_connect_service_attachment: Optional[str] = None,
                 zone: Optional[str] = None):
        PrivateLinkAttachmentGcp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_service_connect_service_attachment=private_service_connect_service_attachment,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_service_connect_service_attachment: Optional[str] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_service_connect_service_attachment is None and 'privateServiceConnectServiceAttachment' in kwargs:
            private_service_connect_service_attachment = kwargs['privateServiceConnectServiceAttachment']

        if private_service_connect_service_attachment is not None:
            _setter("private_service_connect_service_attachment", private_service_connect_service_attachment)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="privateServiceConnectServiceAttachment")
    def private_service_connect_service_attachment(self) -> Optional[str]:
        return pulumi.get(self, "private_service_connect_service_attachment")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        return pulumi.get(self, "zone")


@pulumi.output_type
class SchemaCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        """
        SchemaCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        return pulumi.get(self, "secret")


@pulumi.output_type
class SchemaExporterCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
        """
        SchemaExporterCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class SchemaExporterDestinationSchemaRegistryCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restEndpoint":
            suggest = "rest_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SchemaExporterDestinationSchemaRegistryCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SchemaExporterDestinationSchemaRegistryCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SchemaExporterDestinationSchemaRegistryCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SchemaExporterDestinationSchemaRegistryClusterCredentials',
                 rest_endpoint: str):
        """
        :param str rest_endpoint: The REST endpoint of the destination Schema Registry cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        SchemaExporterDestinationSchemaRegistryCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            rest_endpoint=rest_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: Optional['outputs.SchemaExporterDestinationSchemaRegistryClusterCredentials'] = None,
             rest_endpoint: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")
        if rest_endpoint is None and 'restEndpoint' in kwargs:
            rest_endpoint = kwargs['restEndpoint']
        if rest_endpoint is None:
            raise TypeError("Missing 'rest_endpoint' argument")

        _setter("credentials", credentials)
        _setter("rest_endpoint", rest_endpoint)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SchemaExporterDestinationSchemaRegistryClusterCredentials':
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> str:
        """
        The REST endpoint of the destination Schema Registry cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        return pulumi.get(self, "rest_endpoint")


@pulumi.output_type
class SchemaExporterDestinationSchemaRegistryClusterCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
        """
        SchemaExporterDestinationSchemaRegistryClusterCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class SchemaExporterSchemaRegistryCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        SchemaExporterSchemaRegistryCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SchemaRegistryClusterConfigCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        """
        SchemaRegistryClusterConfigCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        return pulumi.get(self, "secret")


@pulumi.output_type
class SchemaRegistryClusterConfigSchemaRegistryCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        SchemaRegistryClusterConfigSchemaRegistryCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SchemaRegistryClusterEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry region that the Schema Registry cluster belongs to, for example, `sgreg-1`. See [Schema Registry Regions](https://docs.confluent.io/cloud/current/stream-governance/packages.html#stream-governance-regions) to find a corresponding region ID based on desired cloud provider region and types of the billing package.
        """
        SchemaRegistryClusterEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry region that the Schema Registry cluster belongs to, for example, `sgreg-1`. See [Schema Registry Regions](https://docs.confluent.io/cloud/current/stream-governance/packages.html#stream-governance-regions) to find a corresponding region ID based on desired cloud provider region and types of the billing package.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SchemaRegistryClusterModeCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        """
        SchemaRegistryClusterModeCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        return pulumi.get(self, "secret")


@pulumi.output_type
class SchemaRegistryClusterModeSchemaRegistryCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        SchemaRegistryClusterModeSchemaRegistryCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SchemaRegistryClusterRegion(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry region that the Schema Registry cluster belongs to, for example, `sgreg-1`. See [Schema Registry Regions](https://docs.confluent.io/cloud/current/stream-governance/packages.html#stream-governance-regions) to find a corresponding region ID based on desired cloud provider region and types of the billing package.
        """
        SchemaRegistryClusterRegion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry region that the Schema Registry cluster belongs to, for example, `sgreg-1`. See [Schema Registry Regions](https://docs.confluent.io/cloud/current/stream-governance/packages.html#stream-governance-regions) to find a corresponding region ID based on desired cloud provider region and types of the billing package.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SchemaSchemaReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subjectName":
            suggest = "subject_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SchemaSchemaReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SchemaSchemaReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SchemaSchemaReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 subject_name: str,
                 version: int):
        """
        :param str name: The name of the subject, representing the subject under which the referenced schema is registered.
        :param str subject_name: The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
        :param int version: The version, representing the exact version of the schema under the registered subject.
        """
        SchemaSchemaReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            subject_name=subject_name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             subject_name: Optional[str] = None,
             version: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if subject_name is None and 'subjectName' in kwargs:
            subject_name = kwargs['subjectName']
        if subject_name is None:
            raise TypeError("Missing 'subject_name' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("name", name)
        _setter("subject_name", subject_name)
        _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the subject, representing the subject under which the referenced schema is registered.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> str:
        """
        The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
        """
        return pulumi.get(self, "subject_name")

    @property
    @pulumi.getter
    def version(self) -> int:
        """
        The version, representing the exact version of the schema under the registered subject.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SchemaSchemaRegistryCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        SchemaSchemaRegistryCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SubjectConfigCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        """
        SubjectConfigCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        return pulumi.get(self, "secret")


@pulumi.output_type
class SubjectConfigSchemaRegistryCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        SubjectConfigSchemaRegistryCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SubjectModeCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        """
        SubjectModeCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        return pulumi.get(self, "secret")


@pulumi.output_type
class SubjectModeSchemaRegistryCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        SubjectModeSchemaRegistryCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class TagBindingCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
        """
        TagBindingCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class TagBindingSchemaRegistryCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        TagBindingSchemaRegistryCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class TagCredentials(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
        """
        TagCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class TagSchemaRegistryCluster(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        TagSchemaRegistryCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class TransitGatewayAttachmentAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ramResourceShareArn":
            suggest = "ram_resource_share_arn"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "transitGatewayAttachmentId":
            suggest = "transit_gateway_attachment_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransitGatewayAttachmentAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransitGatewayAttachmentAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransitGatewayAttachmentAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ram_resource_share_arn: str,
                 routes: Sequence[str],
                 transit_gateway_id: str,
                 transit_gateway_attachment_id: Optional[str] = None):
        """
        :param str ram_resource_share_arn: The Amazon Resource Name (ARN) of the Resource Access Manager (RAM) Resource Share of the transit gateway your Confluent Cloud network attaches to.
        :param Sequence[str] routes: List of destination routes for traffic from Confluent VPC to customer VPC via Transit Gateway.
               
               > **Note:** Learn more about Transit Gateway Attachment limitations on AWS [here](https://docs.confluent.io/cloud/current/networking/aws-transit-gateway.html#limitations).
        :param str transit_gateway_id: The ID of the AWS Transit Gateway that you want Confluent CLoud to be attached to. Must start with `tgw-`.
        :param str transit_gateway_attachment_id: (Required String) The ID of the AWS Transit Gateway VPC Attachment that attaches Confluent VPC to Transit Gateway.
        """
        TransitGatewayAttachmentAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ram_resource_share_arn=ram_resource_share_arn,
            routes=routes,
            transit_gateway_id=transit_gateway_id,
            transit_gateway_attachment_id=transit_gateway_attachment_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ram_resource_share_arn: Optional[str] = None,
             routes: Optional[Sequence[str]] = None,
             transit_gateway_id: Optional[str] = None,
             transit_gateway_attachment_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ram_resource_share_arn is None and 'ramResourceShareArn' in kwargs:
            ram_resource_share_arn = kwargs['ramResourceShareArn']
        if ram_resource_share_arn is None:
            raise TypeError("Missing 'ram_resource_share_arn' argument")
        if routes is None:
            raise TypeError("Missing 'routes' argument")
        if transit_gateway_id is None and 'transitGatewayId' in kwargs:
            transit_gateway_id = kwargs['transitGatewayId']
        if transit_gateway_id is None:
            raise TypeError("Missing 'transit_gateway_id' argument")
        if transit_gateway_attachment_id is None and 'transitGatewayAttachmentId' in kwargs:
            transit_gateway_attachment_id = kwargs['transitGatewayAttachmentId']

        _setter("ram_resource_share_arn", ram_resource_share_arn)
        _setter("routes", routes)
        _setter("transit_gateway_id", transit_gateway_id)
        if transit_gateway_attachment_id is not None:
            _setter("transit_gateway_attachment_id", transit_gateway_attachment_id)

    @property
    @pulumi.getter(name="ramResourceShareArn")
    def ram_resource_share_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the Resource Access Manager (RAM) Resource Share of the transit gateway your Confluent Cloud network attaches to.
        """
        return pulumi.get(self, "ram_resource_share_arn")

    @property
    @pulumi.getter
    def routes(self) -> Sequence[str]:
        """
        List of destination routes for traffic from Confluent VPC to customer VPC via Transit Gateway.

        > **Note:** Learn more about Transit Gateway Attachment limitations on AWS [here](https://docs.confluent.io/cloud/current/networking/aws-transit-gateway.html#limitations).
        """
        return pulumi.get(self, "routes")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> str:
        """
        The ID of the AWS Transit Gateway that you want Confluent CLoud to be attached to. Must start with `tgw-`.
        """
        return pulumi.get(self, "transit_gateway_id")

    @property
    @pulumi.getter(name="transitGatewayAttachmentId")
    def transit_gateway_attachment_id(self) -> Optional[str]:
        """
        (Required String) The ID of the AWS Transit Gateway VPC Attachment that attaches Confluent VPC to Transit Gateway.
        """
        return pulumi.get(self, "transit_gateway_attachment_id")


@pulumi.output_type
class TransitGatewayAttachmentEnvironment(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Network that the Transit Gateway Attachment belongs to, for example, `n-abc123`.
        """
        TransitGatewayAttachmentEnvironment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Network that the Transit Gateway Attachment belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class TransitGatewayAttachmentNetwork(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Network that the Transit Gateway Attachment belongs to, for example, `n-abc123`.
        """
        TransitGatewayAttachmentNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Network that the Transit Gateway Attachment belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetBusinessMetadataAttributeDefinitionResult(dict):
    def __init__(__self__, *,
                 default_value: str,
                 description: str,
                 is_optional: bool,
                 name: str,
                 options: Mapping[str, str],
                 type: str):
        """
        :param str default_value: (Optional String) The default value of this attribute.
        :param str description: (Optional String) The description of this attribute.
        :param bool is_optional: (Optional Boolean) An optional flag to control whether the attribute should be optional or required.
        :param str name: The name of the Business Metadata, for example, `PII`. The name must not be empty and consist of a letter followed by a sequence of letter, number, space, or _ characters.
               
               > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
        :param Mapping[str, str] options: (Optional Map) Block for the attribute options:
        :param str type: (Required String) The type of the attribute, it always returns `string`.
        """
        GetBusinessMetadataAttributeDefinitionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_value=default_value,
            description=description,
            is_optional=is_optional,
            name=name,
            options=options,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_value: Optional[str] = None,
             description: Optional[str] = None,
             is_optional: Optional[bool] = None,
             name: Optional[str] = None,
             options: Optional[Mapping[str, str]] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_value is None and 'defaultValue' in kwargs:
            default_value = kwargs['defaultValue']
        if default_value is None:
            raise TypeError("Missing 'default_value' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if is_optional is None and 'isOptional' in kwargs:
            is_optional = kwargs['isOptional']
        if is_optional is None:
            raise TypeError("Missing 'is_optional' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if options is None:
            raise TypeError("Missing 'options' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("default_value", default_value)
        _setter("description", description)
        _setter("is_optional", is_optional)
        _setter("name", name)
        _setter("options", options)
        _setter("type", type)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> str:
        """
        (Optional String) The default value of this attribute.
        """
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        (Optional String) The description of this attribute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isOptional")
    def is_optional(self) -> bool:
        """
        (Optional Boolean) An optional flag to control whether the attribute should be optional or required.
        """
        return pulumi.get(self, "is_optional")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Business Metadata, for example, `PII`. The name must not be empty and consist of a letter followed by a sequence of letter, number, space, or _ characters.

        > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def options(self) -> Mapping[str, str]:
        """
        (Optional Map) Block for the attribute options:
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        (Required String) The type of the attribute, it always returns `string`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetBusinessMetadataBindingCredentialsResult(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
               
               > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
        """
        GetBusinessMetadataBindingCredentialsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.

        > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetBusinessMetadataBindingSchemaRegistryClusterResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        GetBusinessMetadataBindingSchemaRegistryClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetBusinessMetadataCredentialsResult(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
        """
        GetBusinessMetadataCredentialsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetBusinessMetadataSchemaRegistryClusterResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        GetBusinessMetadataSchemaRegistryClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetByokKeyAwResult(dict):
    def __init__(__self__, *,
                 key_arn: str,
                 roles: Sequence[str]):
        """
        :param str key_arn: (Required String) The Amazon Resource Name (ARN) of an AWS KMS key.
        :param Sequence[str] roles: (Optional List of Strings) The Amazon Resource Names (ARNs) of IAM Roles created for this key-environment combination.
        """
        GetByokKeyAwResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_arn=key_arn,
            roles=roles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_arn: Optional[str] = None,
             roles: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_arn is None and 'keyArn' in kwargs:
            key_arn = kwargs['keyArn']
        if key_arn is None:
            raise TypeError("Missing 'key_arn' argument")
        if roles is None:
            raise TypeError("Missing 'roles' argument")

        _setter("key_arn", key_arn)
        _setter("roles", roles)

    @property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> str:
        """
        (Required String) The Amazon Resource Name (ARN) of an AWS KMS key.
        """
        return pulumi.get(self, "key_arn")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        """
        (Optional List of Strings) The Amazon Resource Names (ARNs) of IAM Roles created for this key-environment combination.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetByokKeyAzureResult(dict):
    def __init__(__self__, *,
                 application_id: str,
                 key_identifier: str,
                 key_vault_id: str,
                 tenant_id: str):
        """
        :param str application_id: (Optional String) The Application ID created for this key-environment combination.
        :param str key_identifier: (Required String) The unique Key Object Identifier URL of an Azure Key Vault key.
        :param str key_vault_id: (Required String) Key Vault ID containing the key.
        :param str tenant_id: (Required String) Tenant ID (uuid) hosting the Key Vault containing the key.
        """
        GetByokKeyAzureResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_id=application_id,
            key_identifier=key_identifier,
            key_vault_id=key_vault_id,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_id: Optional[str] = None,
             key_identifier: Optional[str] = None,
             key_vault_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if application_id is None and 'applicationId' in kwargs:
            application_id = kwargs['applicationId']
        if application_id is None:
            raise TypeError("Missing 'application_id' argument")
        if key_identifier is None and 'keyIdentifier' in kwargs:
            key_identifier = kwargs['keyIdentifier']
        if key_identifier is None:
            raise TypeError("Missing 'key_identifier' argument")
        if key_vault_id is None and 'keyVaultId' in kwargs:
            key_vault_id = kwargs['keyVaultId']
        if key_vault_id is None:
            raise TypeError("Missing 'key_vault_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")

        _setter("application_id", application_id)
        _setter("key_identifier", key_identifier)
        _setter("key_vault_id", key_vault_id)
        _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> str:
        """
        (Optional String) The Application ID created for this key-environment combination.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> str:
        """
        (Required String) The unique Key Object Identifier URL of an Azure Key Vault key.
        """
        return pulumi.get(self, "key_identifier")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        (Required String) Key Vault ID containing the key.
        """
        return pulumi.get(self, "key_vault_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        (Required String) Tenant ID (uuid) hosting the Key Vault containing the key.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetFlinkComputePoolEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Flink Compute Pool belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetFlinkComputePoolEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Flink Compute Pool belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetIdentityPoolIdentityProviderResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Identity Provider associated with the Identity Pool, for example, `op-abc123`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetIdentityPoolIdentityProviderResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Identity Provider associated with the Identity Pool, for example, `op-abc123`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetInvitationCreatorResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Invitation, for example, `i-zyw30`.
        """
        GetInvitationCreatorResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Invitation, for example, `i-zyw30`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetInvitationUserResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Invitation, for example, `i-zyw30`.
        """
        GetInvitationUserResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Invitation, for example, `i-zyw30`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetKafkaClientQuotaEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Kafka Client Quota (for example, `cq-abc123`).
        """
        GetKafkaClientQuotaEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Kafka Client Quota (for example, `cq-abc123`).
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetKafkaClientQuotaKafkaClusterResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Kafka Client Quota (for example, `cq-abc123`).
        """
        GetKafkaClientQuotaKafkaClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Kafka Client Quota (for example, `cq-abc123`).
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetKafkaClientQuotaThroughputResult(dict):
    def __init__(__self__, *,
                 egress_byte_rate: str,
                 ingress_byte_rate: str):
        """
        :param str egress_byte_rate: (Required String) The egress throughput limit in bytes per second.
        :param str ingress_byte_rate: (Required String) The ingress throughput limit in bytes per second.
        """
        GetKafkaClientQuotaThroughputResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            egress_byte_rate=egress_byte_rate,
            ingress_byte_rate=ingress_byte_rate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             egress_byte_rate: Optional[str] = None,
             ingress_byte_rate: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if egress_byte_rate is None and 'egressByteRate' in kwargs:
            egress_byte_rate = kwargs['egressByteRate']
        if egress_byte_rate is None:
            raise TypeError("Missing 'egress_byte_rate' argument")
        if ingress_byte_rate is None and 'ingressByteRate' in kwargs:
            ingress_byte_rate = kwargs['ingressByteRate']
        if ingress_byte_rate is None:
            raise TypeError("Missing 'ingress_byte_rate' argument")

        _setter("egress_byte_rate", egress_byte_rate)
        _setter("ingress_byte_rate", ingress_byte_rate)

    @property
    @pulumi.getter(name="egressByteRate")
    def egress_byte_rate(self) -> str:
        """
        (Required String) The egress throughput limit in bytes per second.
        """
        return pulumi.get(self, "egress_byte_rate")

    @property
    @pulumi.getter(name="ingressByteRate")
    def ingress_byte_rate(self) -> str:
        """
        (Required String) The ingress throughput limit in bytes per second.
        """
        return pulumi.get(self, "ingress_byte_rate")


@pulumi.output_type
class GetKafkaClusterBasicResult(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class GetKafkaClusterByokKeyResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Kafka cluster belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetKafkaClusterByokKeyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Kafka cluster belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetKafkaClusterDedicatedResult(dict):
    def __init__(__self__, *,
                 cku: int,
                 encryption_key: str,
                 zones: Sequence[str]):
        """
        :param int cku: (Required Number) The number of Confluent Kafka Units (CKUs) for Dedicated cluster types. The minimum number of CKUs for `SINGLE_ZONE` dedicated clusters is `1` whereas `MULTI_ZONE` dedicated clusters must have more than `2` CKUs.
        :param Sequence[str] zones: (Required List of String) The list of zones the cluster is in.
               On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
               On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones), for example, `us-central1-c`.
               On Azure, zones are Confluent-chosen names (for example, `1`, `2`, `3`) since Azure does not have universal zone identifiers.
        """
        GetKafkaClusterDedicatedResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cku=cku,
            encryption_key=encryption_key,
            zones=zones,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cku: Optional[int] = None,
             encryption_key: Optional[str] = None,
             zones: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cku is None:
            raise TypeError("Missing 'cku' argument")
        if encryption_key is None and 'encryptionKey' in kwargs:
            encryption_key = kwargs['encryptionKey']
        if encryption_key is None:
            raise TypeError("Missing 'encryption_key' argument")
        if zones is None:
            raise TypeError("Missing 'zones' argument")

        _setter("cku", cku)
        _setter("encryption_key", encryption_key)
        _setter("zones", zones)

    @property
    @pulumi.getter
    def cku(self) -> int:
        """
        (Required Number) The number of Confluent Kafka Units (CKUs) for Dedicated cluster types. The minimum number of CKUs for `SINGLE_ZONE` dedicated clusters is `1` whereas `MULTI_ZONE` dedicated clusters must have more than `2` CKUs.
        """
        return pulumi.get(self, "cku")

    @property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> str:
        return pulumi.get(self, "encryption_key")

    @property
    @pulumi.getter
    def zones(self) -> Sequence[str]:
        """
        (Required List of String) The list of zones the cluster is in.
        On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
        On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones), for example, `us-central1-c`.
        On Azure, zones are Confluent-chosen names (for example, `1`, `2`, `3`) since Azure does not have universal zone identifiers.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class GetKafkaClusterEnterpriseResult(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class GetKafkaClusterEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Kafka cluster belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetKafkaClusterEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Kafka cluster belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetKafkaClusterNetworkResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Kafka cluster belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetKafkaClusterNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Kafka cluster belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetKafkaClusterStandardResult(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class GetKafkaTopicCredentialsResult(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Kafka API Key.
        """
        GetKafkaTopicCredentialsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetKafkaTopicKafkaClusterResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        GetKafkaTopicKafkaClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetKsqlClusterCredentialIdentityResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the ksqlDB cluster belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetKsqlClusterCredentialIdentityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the ksqlDB cluster belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetKsqlClusterEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the ksqlDB cluster belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetKsqlClusterEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the ksqlDB cluster belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetKsqlClusterKafkaClusterResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the ksqlDB cluster belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetKsqlClusterKafkaClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the ksqlDB cluster belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNetworkAwResult(dict):
    def __init__(__self__, *,
                 account: str,
                 private_link_endpoint_service: str,
                 vpc: str):
        """
        :param str account: (Required String) The AWS account ID associated with the Confluent Cloud VPC.
        :param str private_link_endpoint_service: (Optional String) The endpoint service of the Confluent Cloud VPC (used for PrivateLink) if available.
        :param str vpc: (Required String) The Confluent Cloud VPC ID.
        """
        GetNetworkAwResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account=account,
            private_link_endpoint_service=private_link_endpoint_service,
            vpc=vpc,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account: Optional[str] = None,
             private_link_endpoint_service: Optional[str] = None,
             vpc: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account is None:
            raise TypeError("Missing 'account' argument")
        if private_link_endpoint_service is None and 'privateLinkEndpointService' in kwargs:
            private_link_endpoint_service = kwargs['privateLinkEndpointService']
        if private_link_endpoint_service is None:
            raise TypeError("Missing 'private_link_endpoint_service' argument")
        if vpc is None:
            raise TypeError("Missing 'vpc' argument")

        _setter("account", account)
        _setter("private_link_endpoint_service", private_link_endpoint_service)
        _setter("vpc", vpc)

    @property
    @pulumi.getter
    def account(self) -> str:
        """
        (Required String) The AWS account ID associated with the Confluent Cloud VPC.
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter(name="privateLinkEndpointService")
    def private_link_endpoint_service(self) -> str:
        """
        (Optional String) The endpoint service of the Confluent Cloud VPC (used for PrivateLink) if available.
        """
        return pulumi.get(self, "private_link_endpoint_service")

    @property
    @pulumi.getter
    def vpc(self) -> str:
        """
        (Required String) The Confluent Cloud VPC ID.
        """
        return pulumi.get(self, "vpc")


@pulumi.output_type
class GetNetworkAzureResult(dict):
    def __init__(__self__, *,
                 private_link_service_aliases: Mapping[str, str]):
        """
        :param Mapping[str, str] private_link_service_aliases: (Optional Map) The mapping of zones to Private Link Service Aliases if available. Keys are zones and values are [Azure Private Link Service Aliases](https://docs.microsoft.com/en-us/azure/private-link/private-link-service-overview#share-your-service).
        """
        GetNetworkAzureResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_link_service_aliases=private_link_service_aliases,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_link_service_aliases: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_link_service_aliases is None and 'privateLinkServiceAliases' in kwargs:
            private_link_service_aliases = kwargs['privateLinkServiceAliases']
        if private_link_service_aliases is None:
            raise TypeError("Missing 'private_link_service_aliases' argument")

        _setter("private_link_service_aliases", private_link_service_aliases)

    @property
    @pulumi.getter(name="privateLinkServiceAliases")
    def private_link_service_aliases(self) -> Mapping[str, str]:
        """
        (Optional Map) The mapping of zones to Private Link Service Aliases if available. Keys are zones and values are [Azure Private Link Service Aliases](https://docs.microsoft.com/en-us/azure/private-link/private-link-service-overview#share-your-service).
        """
        return pulumi.get(self, "private_link_service_aliases")


@pulumi.output_type
class GetNetworkDnsConfigResult(dict):
    def __init__(__self__, *,
                 resolution: str):
        """
        :param str resolution: (Required String) Network DNS resolution.
               When resolution is `CHASED_PRIVATE`, clusters in this network require both public and private DNS to resolve cluster endpoints.
               When resolution is `PRIVATE`, clusters in this network only require private DNS to resolve cluster endpoints.
        """
        GetNetworkDnsConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resolution=resolution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resolution: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resolution is None:
            raise TypeError("Missing 'resolution' argument")

        _setter("resolution", resolution)

    @property
    @pulumi.getter
    def resolution(self) -> str:
        """
        (Required String) Network DNS resolution.
        When resolution is `CHASED_PRIVATE`, clusters in this network require both public and private DNS to resolve cluster endpoints.
        When resolution is `PRIVATE`, clusters in this network only require private DNS to resolve cluster endpoints.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class GetNetworkEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Network belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetNetworkEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Network belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNetworkGcpResult(dict):
    def __init__(__self__, *,
                 private_service_connect_service_attachments: Mapping[str, str],
                 project: str,
                 vpc_network: str):
        """
        :param Mapping[str, str] private_service_connect_service_attachments: (Optional Map) The mapping of zones to Private Service Connect Service Attachments if available. Keys are zones and values are [GCP Private Service Connect service attachment](https://cloud.google.com/vpc/docs/configure-private-service-connect-producer#api_7).
        :param str project: (Required String) The GCP Project ID associated with the Confluent Cloud VPC.
        :param str vpc_network: (Required String) The network name of the Confluent Cloud VPC.
        """
        GetNetworkGcpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_service_connect_service_attachments=private_service_connect_service_attachments,
            project=project,
            vpc_network=vpc_network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_service_connect_service_attachments: Optional[Mapping[str, str]] = None,
             project: Optional[str] = None,
             vpc_network: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_service_connect_service_attachments is None and 'privateServiceConnectServiceAttachments' in kwargs:
            private_service_connect_service_attachments = kwargs['privateServiceConnectServiceAttachments']
        if private_service_connect_service_attachments is None:
            raise TypeError("Missing 'private_service_connect_service_attachments' argument")
        if project is None:
            raise TypeError("Missing 'project' argument")
        if vpc_network is None and 'vpcNetwork' in kwargs:
            vpc_network = kwargs['vpcNetwork']
        if vpc_network is None:
            raise TypeError("Missing 'vpc_network' argument")

        _setter("private_service_connect_service_attachments", private_service_connect_service_attachments)
        _setter("project", project)
        _setter("vpc_network", vpc_network)

    @property
    @pulumi.getter(name="privateServiceConnectServiceAttachments")
    def private_service_connect_service_attachments(self) -> Mapping[str, str]:
        """
        (Optional Map) The mapping of zones to Private Service Connect Service Attachments if available. Keys are zones and values are [GCP Private Service Connect service attachment](https://cloud.google.com/vpc/docs/configure-private-service-connect-producer#api_7).
        """
        return pulumi.get(self, "private_service_connect_service_attachments")

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        (Required String) The GCP Project ID associated with the Confluent Cloud VPC.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> str:
        """
        (Required String) The network name of the Confluent Cloud VPC.
        """
        return pulumi.get(self, "vpc_network")


@pulumi.output_type
class GetNetworkLinkEndpointEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        GetNetworkLinkEndpointEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNetworkLinkEndpointNetworkResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        GetNetworkLinkEndpointNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNetworkLinkEndpointNetworkLinkServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        GetNetworkLinkEndpointNetworkLinkServiceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNetworkLinkServiceAcceptResult(dict):
    def __init__(__self__, *,
                 environments: Sequence[str],
                 networks: Sequence[str]):
        """
        :param Sequence[str] environments: (Optional List of Strings) List of environments ids from which connections can be accepted. All networks within the list of environment will be allowed.
        :param Sequence[str] networks: (Optional List of Strings) List of network ids from which connections can be accepted.
        """
        GetNetworkLinkServiceAcceptResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            environments=environments,
            networks=networks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             environments: Optional[Sequence[str]] = None,
             networks: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if environments is None:
            raise TypeError("Missing 'environments' argument")
        if networks is None:
            raise TypeError("Missing 'networks' argument")

        _setter("environments", environments)
        _setter("networks", networks)

    @property
    @pulumi.getter
    def environments(self) -> Sequence[str]:
        """
        (Optional List of Strings) List of environments ids from which connections can be accepted. All networks within the list of environment will be allowed.
        """
        return pulumi.get(self, "environments")

    @property
    @pulumi.getter
    def networks(self) -> Sequence[str]:
        """
        (Optional List of Strings) List of network ids from which connections can be accepted.
        """
        return pulumi.get(self, "networks")


@pulumi.output_type
class GetNetworkLinkServiceEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Network Link Service belongs to, for example, `env-1234`.
        """
        GetNetworkLinkServiceEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Network Link Service belongs to, for example, `env-1234`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNetworkLinkServiceNetworkResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Network Link Service belongs to, for example, `env-1234`.
        """
        GetNetworkLinkServiceNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Network Link Service belongs to, for example, `env-1234`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNetworkZoneInfoResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 zone_id: str):
        """
        :param str cidr: (Required String) The IPv4 CIDR block to be used for the network. Must be `/27`. Required for VPC peering and AWS TransitGateway.
        :param str zone_id: (Required String) Cloud provider zone ID.
        """
        GetNetworkZoneInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']
        if zone_id is None:
            raise TypeError("Missing 'zone_id' argument")

        _setter("cidr", cidr)
        _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        (Required String) The IPv4 CIDR block to be used for the network. Must be `/27`. Required for VPC peering and AWS TransitGateway.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        (Required String) Cloud provider zone ID.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetPeeringAwResult(dict):
    def __init__(__self__, *,
                 account: str,
                 customer_region: str,
                 routes: Sequence[str],
                 vpc: str):
        """
        :param str account: (Required String) The AWS Account ID of the peer VPC owner. You can find your AWS Account ID [here](https://console.aws.amazon.com/billing/home?#/account) under **My Account** section of the AWS Management Console. Must be a **12 character string**.
        :param str customer_region: (Required String) The region of the Azure peer VNet.
        :param Sequence[str] routes: (Required String) The AWS VPC CIDR blocks or subsets. This must be from the supported CIDR blocks and must not overlap with your Confluent Cloud CIDR block or any other network peering connection VPC CIDR (learn more about the requirements [here](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html#vpc-peering-on-aws)). You can find AWS VPC CIDR [here](https://console.aws.amazon.com/vpc/) under **Your VPCs > Target VPC > Details** section of the AWS Management Console.
        :param str vpc: (Required String) The AWS VPC ID of the peer VPC that you're peering with Confluent Cloud. You can find your AWS VPC ID [here](https://console.aws.amazon.com/vpc/) under **Your VPCs** section of the AWS Management Console. Must start with `vpc-`.
        """
        GetPeeringAwResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account=account,
            customer_region=customer_region,
            routes=routes,
            vpc=vpc,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account: Optional[str] = None,
             customer_region: Optional[str] = None,
             routes: Optional[Sequence[str]] = None,
             vpc: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account is None:
            raise TypeError("Missing 'account' argument")
        if customer_region is None and 'customerRegion' in kwargs:
            customer_region = kwargs['customerRegion']
        if customer_region is None:
            raise TypeError("Missing 'customer_region' argument")
        if routes is None:
            raise TypeError("Missing 'routes' argument")
        if vpc is None:
            raise TypeError("Missing 'vpc' argument")

        _setter("account", account)
        _setter("customer_region", customer_region)
        _setter("routes", routes)
        _setter("vpc", vpc)

    @property
    @pulumi.getter
    def account(self) -> str:
        """
        (Required String) The AWS Account ID of the peer VPC owner. You can find your AWS Account ID [here](https://console.aws.amazon.com/billing/home?#/account) under **My Account** section of the AWS Management Console. Must be a **12 character string**.
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter(name="customerRegion")
    def customer_region(self) -> str:
        """
        (Required String) The region of the Azure peer VNet.
        """
        return pulumi.get(self, "customer_region")

    @property
    @pulumi.getter
    def routes(self) -> Sequence[str]:
        """
        (Required String) The AWS VPC CIDR blocks or subsets. This must be from the supported CIDR blocks and must not overlap with your Confluent Cloud CIDR block or any other network peering connection VPC CIDR (learn more about the requirements [here](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html#vpc-peering-on-aws)). You can find AWS VPC CIDR [here](https://console.aws.amazon.com/vpc/) under **Your VPCs > Target VPC > Details** section of the AWS Management Console.
        """
        return pulumi.get(self, "routes")

    @property
    @pulumi.getter
    def vpc(self) -> str:
        """
        (Required String) The AWS VPC ID of the peer VPC that you're peering with Confluent Cloud. You can find your AWS VPC ID [here](https://console.aws.amazon.com/vpc/) under **Your VPCs** section of the AWS Management Console. Must start with `vpc-`.
        """
        return pulumi.get(self, "vpc")


@pulumi.output_type
class GetPeeringAzureResult(dict):
    def __init__(__self__, *,
                 customer_region: str,
                 tenant: str,
                 vnet: str):
        """
        :param str customer_region: (Required String) The region of the Azure peer VNet.
        :param str tenant: (Required String) The Tenant ID that represents an organization in Azure Active Directory. You can find your Azure Tenant ID in the [Azure Portal under Azure Active Directory](https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/Overview). Must be a valid **32 character UUID string**.
        :param str vnet: (Required String) The resource (composite) ID of the peer Virtual Network that you're peering with Confluent Cloud, in the format `/subscriptions/<Subscription ID>/resourceGroups/<Resource Group Name>/providers/Microsoft.Network/virtualNetworks/<VNet name>`. You can find Subscription ID, Resource Group Name and your VNet name under **Virtual Networks > Target VNet > Essentials** section of your [Microsoft Azure Portal](https://portal.azure.com/).
        """
        GetPeeringAzureResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            customer_region=customer_region,
            tenant=tenant,
            vnet=vnet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             customer_region: Optional[str] = None,
             tenant: Optional[str] = None,
             vnet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if customer_region is None and 'customerRegion' in kwargs:
            customer_region = kwargs['customerRegion']
        if customer_region is None:
            raise TypeError("Missing 'customer_region' argument")
        if tenant is None:
            raise TypeError("Missing 'tenant' argument")
        if vnet is None:
            raise TypeError("Missing 'vnet' argument")

        _setter("customer_region", customer_region)
        _setter("tenant", tenant)
        _setter("vnet", vnet)

    @property
    @pulumi.getter(name="customerRegion")
    def customer_region(self) -> str:
        """
        (Required String) The region of the Azure peer VNet.
        """
        return pulumi.get(self, "customer_region")

    @property
    @pulumi.getter
    def tenant(self) -> str:
        """
        (Required String) The Tenant ID that represents an organization in Azure Active Directory. You can find your Azure Tenant ID in the [Azure Portal under Azure Active Directory](https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/Overview). Must be a valid **32 character UUID string**.
        """
        return pulumi.get(self, "tenant")

    @property
    @pulumi.getter
    def vnet(self) -> str:
        """
        (Required String) The resource (composite) ID of the peer Virtual Network that you're peering with Confluent Cloud, in the format `/subscriptions/<Subscription ID>/resourceGroups/<Resource Group Name>/providers/Microsoft.Network/virtualNetworks/<VNet name>`. You can find Subscription ID, Resource Group Name and your VNet name under **Virtual Networks > Target VNet > Essentials** section of your [Microsoft Azure Portal](https://portal.azure.com/).
        """
        return pulumi.get(self, "vnet")


@pulumi.output_type
class GetPeeringEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Peering belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetPeeringEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Peering belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPeeringGcpResult(dict):
    def __init__(__self__, *,
                 import_custom_routes: bool,
                 project: str,
                 vpc_network: str):
        """
        :param bool import_custom_routes: (Optional Boolean) The Import Custom Routes option enables connectivity to a Confluent Cloud cluster in Google Cloud from customer premise or other clouds, such as AWS and Azure, through a customer VPC that is peered with Confluent Cloud in the same region. Defaults to `false`. Learn more about considerations / limitations of the Import Custom Routes option [here](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html#import-custom-routes).
        :param str project: (Required String) The GCP Project ID. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).
        :param str vpc_network: (Required String) The VPC network name that you're peering to Confluent Cloud. You can find your VPC network name under **VPC Networks** section of your [Google Cloud Console](https://console.cloud.google.com/networking/networks/list).
        """
        GetPeeringGcpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            import_custom_routes=import_custom_routes,
            project=project,
            vpc_network=vpc_network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             import_custom_routes: Optional[bool] = None,
             project: Optional[str] = None,
             vpc_network: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if import_custom_routes is None and 'importCustomRoutes' in kwargs:
            import_custom_routes = kwargs['importCustomRoutes']
        if import_custom_routes is None:
            raise TypeError("Missing 'import_custom_routes' argument")
        if project is None:
            raise TypeError("Missing 'project' argument")
        if vpc_network is None and 'vpcNetwork' in kwargs:
            vpc_network = kwargs['vpcNetwork']
        if vpc_network is None:
            raise TypeError("Missing 'vpc_network' argument")

        _setter("import_custom_routes", import_custom_routes)
        _setter("project", project)
        _setter("vpc_network", vpc_network)

    @property
    @pulumi.getter(name="importCustomRoutes")
    def import_custom_routes(self) -> bool:
        """
        (Optional Boolean) The Import Custom Routes option enables connectivity to a Confluent Cloud cluster in Google Cloud from customer premise or other clouds, such as AWS and Azure, through a customer VPC that is peered with Confluent Cloud in the same region. Defaults to `false`. Learn more about considerations / limitations of the Import Custom Routes option [here](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html#import-custom-routes).
        """
        return pulumi.get(self, "import_custom_routes")

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        (Required String) The GCP Project ID. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> str:
        """
        (Required String) The VPC network name that you're peering to Confluent Cloud. You can find your VPC network name under **VPC Networks** section of your [Google Cloud Console](https://console.cloud.google.com/networking/networks/list).
        """
        return pulumi.get(self, "vpc_network")


@pulumi.output_type
class GetPeeringNetworkResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Peering belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetPeeringNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Peering belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPrivateLinkAccessAwResult(dict):
    def __init__(__self__, *,
                 account: str):
        """
        :param str account: (Required String) The AWS account ID to enable for the Private Link Access. You can find your AWS account ID [here](https://console.aws.amazon.com/billing/home?#/account) under **My Account** in your AWS Management Console. Must be a **12 character string**.
        """
        GetPrivateLinkAccessAwResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account=account,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account is None:
            raise TypeError("Missing 'account' argument")

        _setter("account", account)

    @property
    @pulumi.getter
    def account(self) -> str:
        """
        (Required String) The AWS account ID to enable for the Private Link Access. You can find your AWS account ID [here](https://console.aws.amazon.com/billing/home?#/account) under **My Account** in your AWS Management Console. Must be a **12 character string**.
        """
        return pulumi.get(self, "account")


@pulumi.output_type
class GetPrivateLinkAccessAzureResult(dict):
    def __init__(__self__, *,
                 subscription: str):
        """
        :param str subscription: (Required String) The Azure subscription ID to enable for the Private Link Access. You can find your Azure subscription ID in the subscription section of your [Microsoft Azure Portal](https://portal.azure.com/#blade/Microsoft_Azure_Billing/SubscriptionsBlade). Must be a valid **32 character UUID string**.
        """
        GetPrivateLinkAccessAzureResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subscription=subscription,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subscription: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subscription is None:
            raise TypeError("Missing 'subscription' argument")

        _setter("subscription", subscription)

    @property
    @pulumi.getter
    def subscription(self) -> str:
        """
        (Required String) The Azure subscription ID to enable for the Private Link Access. You can find your Azure subscription ID in the subscription section of your [Microsoft Azure Portal](https://portal.azure.com/#blade/Microsoft_Azure_Billing/SubscriptionsBlade). Must be a valid **32 character UUID string**.
        """
        return pulumi.get(self, "subscription")


@pulumi.output_type
class GetPrivateLinkAccessEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Private Link Access belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetPrivateLinkAccessEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Private Link Access belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPrivateLinkAccessGcpResult(dict):
    def __init__(__self__, *,
                 project: str):
        """
        :param str project: (Required String) The GCP project ID to allow for Private Service Connect access. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).
        """
        GetPrivateLinkAccessGcpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project=project,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if project is None:
            raise TypeError("Missing 'project' argument")

        _setter("project", project)

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        (Required String) The GCP project ID to allow for Private Service Connect access. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class GetPrivateLinkAccessNetworkResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Private Link Access belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetPrivateLinkAccessNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Private Link Access belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPrivateLinkAttachmentAwResult(dict):
    def __init__(__self__, *,
                 vpc_endpoint_service_name: str):
        """
        :param str vpc_endpoint_service_name: (Required String) AWS VPC Endpoint Service that can be used to establish connections for all zones, for example `com.amazonaws.vpce.us-west-2.vpce-svc-0d3be37e21708ecd3`.
        """
        GetPrivateLinkAttachmentAwResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            vpc_endpoint_service_name=vpc_endpoint_service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             vpc_endpoint_service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if vpc_endpoint_service_name is None and 'vpcEndpointServiceName' in kwargs:
            vpc_endpoint_service_name = kwargs['vpcEndpointServiceName']
        if vpc_endpoint_service_name is None:
            raise TypeError("Missing 'vpc_endpoint_service_name' argument")

        _setter("vpc_endpoint_service_name", vpc_endpoint_service_name)

    @property
    @pulumi.getter(name="vpcEndpointServiceName")
    def vpc_endpoint_service_name(self) -> str:
        """
        (Required String) AWS VPC Endpoint Service that can be used to establish connections for all zones, for example `com.amazonaws.vpce.us-west-2.vpce-svc-0d3be37e21708ecd3`.
        """
        return pulumi.get(self, "vpc_endpoint_service_name")


@pulumi.output_type
class GetPrivateLinkAttachmentAzureResult(dict):
    def __init__(__self__, *,
                 private_link_service_alias: str,
                 private_link_service_resource_id: str,
                 zone: str):
        GetPrivateLinkAttachmentAzureResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_link_service_alias=private_link_service_alias,
            private_link_service_resource_id=private_link_service_resource_id,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_link_service_alias: Optional[str] = None,
             private_link_service_resource_id: Optional[str] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_link_service_alias is None and 'privateLinkServiceAlias' in kwargs:
            private_link_service_alias = kwargs['privateLinkServiceAlias']
        if private_link_service_alias is None:
            raise TypeError("Missing 'private_link_service_alias' argument")
        if private_link_service_resource_id is None and 'privateLinkServiceResourceId' in kwargs:
            private_link_service_resource_id = kwargs['privateLinkServiceResourceId']
        if private_link_service_resource_id is None:
            raise TypeError("Missing 'private_link_service_resource_id' argument")
        if zone is None:
            raise TypeError("Missing 'zone' argument")

        _setter("private_link_service_alias", private_link_service_alias)
        _setter("private_link_service_resource_id", private_link_service_resource_id)
        _setter("zone", zone)

    @property
    @pulumi.getter(name="privateLinkServiceAlias")
    def private_link_service_alias(self) -> str:
        return pulumi.get(self, "private_link_service_alias")

    @property
    @pulumi.getter(name="privateLinkServiceResourceId")
    def private_link_service_resource_id(self) -> str:
        return pulumi.get(self, "private_link_service_resource_id")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetPrivateLinkAttachmentConnectionAwResult(dict):
    def __init__(__self__, *,
                 vpc_endpoint_id: str):
        """
        :param str vpc_endpoint_id: (Required String) Id of a VPC Endpoint that is connected to the VPC Endpoint service.
        """
        GetPrivateLinkAttachmentConnectionAwResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            vpc_endpoint_id=vpc_endpoint_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             vpc_endpoint_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if vpc_endpoint_id is None and 'vpcEndpointId' in kwargs:
            vpc_endpoint_id = kwargs['vpcEndpointId']
        if vpc_endpoint_id is None:
            raise TypeError("Missing 'vpc_endpoint_id' argument")

        _setter("vpc_endpoint_id", vpc_endpoint_id)

    @property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> str:
        """
        (Required String) Id of a VPC Endpoint that is connected to the VPC Endpoint service.
        """
        return pulumi.get(self, "vpc_endpoint_id")


@pulumi.output_type
class GetPrivateLinkAttachmentConnectionAzureResult(dict):
    def __init__(__self__, *,
                 private_endpoint_resource_id: str):
        GetPrivateLinkAttachmentConnectionAzureResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_endpoint_resource_id=private_endpoint_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_endpoint_resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_endpoint_resource_id is None and 'privateEndpointResourceId' in kwargs:
            private_endpoint_resource_id = kwargs['privateEndpointResourceId']
        if private_endpoint_resource_id is None:
            raise TypeError("Missing 'private_endpoint_resource_id' argument")

        _setter("private_endpoint_resource_id", private_endpoint_resource_id)

    @property
    @pulumi.getter(name="privateEndpointResourceId")
    def private_endpoint_resource_id(self) -> str:
        return pulumi.get(self, "private_endpoint_resource_id")


@pulumi.output_type
class GetPrivateLinkAttachmentConnectionEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Private Link Attachment Connection belongs to, for example `env-xyz456`.
        """
        GetPrivateLinkAttachmentConnectionEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Private Link Attachment Connection belongs to, for example `env-xyz456`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPrivateLinkAttachmentConnectionGcpResult(dict):
    def __init__(__self__, *,
                 private_service_connect_connection_id: str):
        GetPrivateLinkAttachmentConnectionGcpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_service_connect_connection_id=private_service_connect_connection_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_service_connect_connection_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_service_connect_connection_id is None and 'privateServiceConnectConnectionId' in kwargs:
            private_service_connect_connection_id = kwargs['privateServiceConnectConnectionId']
        if private_service_connect_connection_id is None:
            raise TypeError("Missing 'private_service_connect_connection_id' argument")

        _setter("private_service_connect_connection_id", private_service_connect_connection_id)

    @property
    @pulumi.getter(name="privateServiceConnectConnectionId")
    def private_service_connect_connection_id(self) -> str:
        return pulumi.get(self, "private_service_connect_connection_id")


@pulumi.output_type
class GetPrivateLinkAttachmentConnectionPrivateLinkAttachmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Private Link Attachment Connection belongs to, for example `env-xyz456`.
        """
        GetPrivateLinkAttachmentConnectionPrivateLinkAttachmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Private Link Attachment Connection belongs to, for example `env-xyz456`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPrivateLinkAttachmentEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Private Link Attachment belongs to, for example `env-xyz456`.
        """
        GetPrivateLinkAttachmentEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Private Link Attachment belongs to, for example `env-xyz456`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPrivateLinkAttachmentGcpResult(dict):
    def __init__(__self__, *,
                 private_service_connect_service_attachment: str,
                 zone: str):
        GetPrivateLinkAttachmentGcpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_service_connect_service_attachment=private_service_connect_service_attachment,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_service_connect_service_attachment: Optional[str] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_service_connect_service_attachment is None and 'privateServiceConnectServiceAttachment' in kwargs:
            private_service_connect_service_attachment = kwargs['privateServiceConnectServiceAttachment']
        if private_service_connect_service_attachment is None:
            raise TypeError("Missing 'private_service_connect_service_attachment' argument")
        if zone is None:
            raise TypeError("Missing 'zone' argument")

        _setter("private_service_connect_service_attachment", private_service_connect_service_attachment)
        _setter("zone", zone)

    @property
    @pulumi.getter(name="privateServiceConnectServiceAttachment")
    def private_service_connect_service_attachment(self) -> str:
        return pulumi.get(self, "private_service_connect_service_attachment")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetSchemaCredentialsResult(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
        """
        GetSchemaCredentialsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetSchemaRegistryClusterConfigCredentialsResult(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
        """
        GetSchemaRegistryClusterConfigCredentialsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetSchemaRegistryClusterConfigSchemaRegistryClusterResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        GetSchemaRegistryClusterConfigSchemaRegistryClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetSchemaRegistryClusterEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Schema Registry cluster belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetSchemaRegistryClusterEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Schema Registry cluster belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetSchemaRegistryClusterModeCredentialsResult(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
               
               > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
        """
        GetSchemaRegistryClusterModeCredentialsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.

        > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetSchemaRegistryClusterModeSchemaRegistryClusterResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        GetSchemaRegistryClusterModeSchemaRegistryClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetSchemaRegistryClusterRegionResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Schema Registry cluster belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetSchemaRegistryClusterRegionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Schema Registry cluster belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetSchemaRegistryClustersClusterResult(dict):
    def __init__(__self__, *,
                 api_version: str,
                 display_name: str,
                 environment: 'outputs.GetSchemaRegistryClustersClusterEnvironmentResult',
                 id: str,
                 kind: str,
                 package: str,
                 regions: Sequence['outputs.GetSchemaRegistryClustersClusterRegionResult'],
                 resource_name: str,
                 rest_endpoint: str):
        """
        :param str api_version: (Required String) An API Version of the schema version of the Schema Registry cluster, for example, `stream-governance/v2`.
        :param str display_name: (Required String) The name of the Schema Registry cluster, for example, `Stream Governance Package`.
        :param 'GetSchemaRegistryClustersClusterEnvironmentArgs' environment: (Required Object) exports the following attributes:
        :param str id: (Required String) The ID of the Schema Registry region that the Schema Registry cluster belongs to, for example, `sgreg-1`. See Schema Registry Regions.
        :param str kind: (Required String) A kind of the Schema Registry cluster, for example, `Cluster`.
        :param str package: (Required String) The type of the billing package. Accepted values are: `ESSENTIALS` and `ADVANCED`.
        :param Sequence['GetSchemaRegistryClustersClusterRegionArgs'] regions: (Required Configuration Block) supports the following:
        :param str resource_name: (Required String) The Confluent Resource Name of the Schema Registry cluster, for example, `crn://confluent.cloud/organization=1111aaaa-11aa-11aa-11aa-111111aaaaaa/environment=env-abc123/schema-registry=lsrc-abc123`.
        :param str rest_endpoint: (Required String) The HTTP endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-west-2.aws.confluent.cloud`.
        """
        GetSchemaRegistryClustersClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_version=api_version,
            display_name=display_name,
            environment=environment,
            id=id,
            kind=kind,
            package=package,
            regions=regions,
            resource_name=resource_name,
            rest_endpoint=rest_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_version: Optional[str] = None,
             display_name: Optional[str] = None,
             environment: Optional['outputs.GetSchemaRegistryClustersClusterEnvironmentResult'] = None,
             id: Optional[str] = None,
             kind: Optional[str] = None,
             package: Optional[str] = None,
             regions: Optional[Sequence['outputs.GetSchemaRegistryClustersClusterRegionResult']] = None,
             resource_name: Optional[str] = None,
             rest_endpoint: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_version is None and 'apiVersion' in kwargs:
            api_version = kwargs['apiVersion']
        if api_version is None:
            raise TypeError("Missing 'api_version' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if environment is None:
            raise TypeError("Missing 'environment' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if package is None:
            raise TypeError("Missing 'package' argument")
        if regions is None:
            raise TypeError("Missing 'regions' argument")
        if resource_name is None and 'resourceName' in kwargs:
            resource_name = kwargs['resourceName']
        if resource_name is None:
            raise TypeError("Missing 'resource_name' argument")
        if rest_endpoint is None and 'restEndpoint' in kwargs:
            rest_endpoint = kwargs['restEndpoint']
        if rest_endpoint is None:
            raise TypeError("Missing 'rest_endpoint' argument")

        _setter("api_version", api_version)
        _setter("display_name", display_name)
        _setter("environment", environment)
        _setter("id", id)
        _setter("kind", kind)
        _setter("package", package)
        _setter("regions", regions)
        _setter("resource_name", resource_name)
        _setter("rest_endpoint", rest_endpoint)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> str:
        """
        (Required String) An API Version of the schema version of the Schema Registry cluster, for example, `stream-governance/v2`.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        (Required String) The name of the Schema Registry cluster, for example, `Stream Governance Package`.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def environment(self) -> 'outputs.GetSchemaRegistryClustersClusterEnvironmentResult':
        """
        (Required Object) exports the following attributes:
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        (Required String) The ID of the Schema Registry region that the Schema Registry cluster belongs to, for example, `sgreg-1`. See Schema Registry Regions.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        (Required String) A kind of the Schema Registry cluster, for example, `Cluster`.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def package(self) -> str:
        """
        (Required String) The type of the billing package. Accepted values are: `ESSENTIALS` and `ADVANCED`.
        """
        return pulumi.get(self, "package")

    @property
    @pulumi.getter
    def regions(self) -> Sequence['outputs.GetSchemaRegistryClustersClusterRegionResult']:
        """
        (Required Configuration Block) supports the following:
        """
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        (Required String) The Confluent Resource Name of the Schema Registry cluster, for example, `crn://confluent.cloud/organization=1111aaaa-11aa-11aa-11aa-111111aaaaaa/environment=env-abc123/schema-registry=lsrc-abc123`.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> str:
        """
        (Required String) The HTTP endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-west-2.aws.confluent.cloud`.
        """
        return pulumi.get(self, "rest_endpoint")


@pulumi.output_type
class GetSchemaRegistryClustersClusterEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: (Required String) The ID of the Schema Registry region that the Schema Registry cluster belongs to, for example, `sgreg-1`. See Schema Registry Regions.
        """
        GetSchemaRegistryClustersClusterEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        (Required String) The ID of the Schema Registry region that the Schema Registry cluster belongs to, for example, `sgreg-1`. See Schema Registry Regions.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetSchemaRegistryClustersClusterRegionResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: (Required String) The ID of the Schema Registry region that the Schema Registry cluster belongs to, for example, `sgreg-1`. See Schema Registry Regions.
        """
        GetSchemaRegistryClustersClusterRegionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        (Required String) The ID of the Schema Registry region that the Schema Registry cluster belongs to, for example, `sgreg-1`. See Schema Registry Regions.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetSchemaSchemaReferenceResult(dict):
    def __init__(__self__, *,
                 name: str,
                 subject_name: str,
                 version: int):
        """
        :param str name: (Required String) The name of the subject, representing the subject under which the referenced schema is registered.
        :param str subject_name: The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`. Schemas evolve safely, following a compatibility mode defined, under a subject name.
        :param int version: (Required Integer) The version of the Schema, for example, `4`.
        """
        GetSchemaSchemaReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            subject_name=subject_name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             subject_name: Optional[str] = None,
             version: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if subject_name is None and 'subjectName' in kwargs:
            subject_name = kwargs['subjectName']
        if subject_name is None:
            raise TypeError("Missing 'subject_name' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("name", name)
        _setter("subject_name", subject_name)
        _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Required String) The name of the subject, representing the subject under which the referenced schema is registered.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> str:
        """
        The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`. Schemas evolve safely, following a compatibility mode defined, under a subject name.
        """
        return pulumi.get(self, "subject_name")

    @property
    @pulumi.getter
    def version(self) -> int:
        """
        (Required Integer) The version of the Schema, for example, `4`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSchemaSchemaRegistryClusterResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        GetSchemaSchemaRegistryClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetSchemasCredentialsResult(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
        """
        GetSchemasCredentialsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetSchemasFilterResult(dict):
    def __init__(__self__, *,
                 deleted: Optional[bool] = None,
                 latest_only: Optional[bool] = None,
                 subject_prefix: Optional[str] = None):
        """
        :param bool deleted: The boolean flag to control whether to return soft deleted schemas. Defaults to `false`.
        :param bool latest_only: The boolean flag to control whether to return latest schema versions only for each matching subject. Defaults to `false`.
        :param str subject_prefix: The prefix of the subjects (in other words, the namespaces), representing the subjects under which the schemas are registered.
        """
        GetSchemasFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            deleted=deleted,
            latest_only=latest_only,
            subject_prefix=subject_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             deleted: Optional[bool] = None,
             latest_only: Optional[bool] = None,
             subject_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if latest_only is None and 'latestOnly' in kwargs:
            latest_only = kwargs['latestOnly']
        if subject_prefix is None and 'subjectPrefix' in kwargs:
            subject_prefix = kwargs['subjectPrefix']

        if deleted is not None:
            _setter("deleted", deleted)
        if latest_only is not None:
            _setter("latest_only", latest_only)
        if subject_prefix is not None:
            _setter("subject_prefix", subject_prefix)

    @property
    @pulumi.getter
    def deleted(self) -> Optional[bool]:
        """
        The boolean flag to control whether to return soft deleted schemas. Defaults to `false`.
        """
        return pulumi.get(self, "deleted")

    @property
    @pulumi.getter(name="latestOnly")
    def latest_only(self) -> Optional[bool]:
        """
        The boolean flag to control whether to return latest schema versions only for each matching subject. Defaults to `false`.
        """
        return pulumi.get(self, "latest_only")

    @property
    @pulumi.getter(name="subjectPrefix")
    def subject_prefix(self) -> Optional[str]:
        """
        The prefix of the subjects (in other words, the namespaces), representing the subjects under which the schemas are registered.
        """
        return pulumi.get(self, "subject_prefix")


@pulumi.output_type
class GetSchemasSchemaResult(dict):
    def __init__(__self__, *,
                 format: str,
                 schema: str,
                 schema_identifier: int,
                 schema_references: Sequence['outputs.GetSchemasSchemaSchemaReferenceResult'],
                 subject_name: str,
                 version: int):
        """
        :param str format: (Required String) The format of the schema. Accepted values are: `AVRO`, `PROTOBUF`, and `JSON`.
        :param str schema: (Required String) The schema string.
        :param int schema_identifier: (Required String) The ID of the Schema, for example: `lsrc-abc123/test-subject/100003`.
        :param Sequence['GetSchemasSchemaSchemaReferenceArgs'] schema_references: (Optional List) The list of referenced schemas (see [Schema References](https://docs.confluent.io/platform/current/schema-registry/serdes-develop/index.html#schema-references) for more details):
        :param str subject_name: (Required String) The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
        :param int version: (Required Integer) The version of the Schema, for example, `4`.
        """
        GetSchemasSchemaResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format=format,
            schema=schema,
            schema_identifier=schema_identifier,
            schema_references=schema_references,
            subject_name=subject_name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format: Optional[str] = None,
             schema: Optional[str] = None,
             schema_identifier: Optional[int] = None,
             schema_references: Optional[Sequence['outputs.GetSchemasSchemaSchemaReferenceResult']] = None,
             subject_name: Optional[str] = None,
             version: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if format is None:
            raise TypeError("Missing 'format' argument")
        if schema is None:
            raise TypeError("Missing 'schema' argument")
        if schema_identifier is None and 'schemaIdentifier' in kwargs:
            schema_identifier = kwargs['schemaIdentifier']
        if schema_identifier is None:
            raise TypeError("Missing 'schema_identifier' argument")
        if schema_references is None and 'schemaReferences' in kwargs:
            schema_references = kwargs['schemaReferences']
        if schema_references is None:
            raise TypeError("Missing 'schema_references' argument")
        if subject_name is None and 'subjectName' in kwargs:
            subject_name = kwargs['subjectName']
        if subject_name is None:
            raise TypeError("Missing 'subject_name' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("format", format)
        _setter("schema", schema)
        _setter("schema_identifier", schema_identifier)
        _setter("schema_references", schema_references)
        _setter("subject_name", subject_name)
        _setter("version", version)

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        (Required String) The format of the schema. Accepted values are: `AVRO`, `PROTOBUF`, and `JSON`.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def schema(self) -> str:
        """
        (Required String) The schema string.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="schemaIdentifier")
    def schema_identifier(self) -> int:
        """
        (Required String) The ID of the Schema, for example: `lsrc-abc123/test-subject/100003`.
        """
        return pulumi.get(self, "schema_identifier")

    @property
    @pulumi.getter(name="schemaReferences")
    def schema_references(self) -> Sequence['outputs.GetSchemasSchemaSchemaReferenceResult']:
        """
        (Optional List) The list of referenced schemas (see [Schema References](https://docs.confluent.io/platform/current/schema-registry/serdes-develop/index.html#schema-references) for more details):
        """
        return pulumi.get(self, "schema_references")

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> str:
        """
        (Required String) The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
        """
        return pulumi.get(self, "subject_name")

    @property
    @pulumi.getter
    def version(self) -> int:
        """
        (Required Integer) The version of the Schema, for example, `4`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSchemasSchemaRegistryClusterResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        GetSchemasSchemaRegistryClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetSchemasSchemaSchemaReferenceResult(dict):
    def __init__(__self__, *,
                 name: str,
                 subject_name: str,
                 version: int):
        """
        :param str name: (Required String) The name of the subject, representing the subject under which the referenced schema is registered.
        :param str subject_name: (Required String) The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
        :param int version: (Required Integer) The version of the Schema, for example, `4`.
        """
        GetSchemasSchemaSchemaReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            subject_name=subject_name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             subject_name: Optional[str] = None,
             version: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if subject_name is None and 'subjectName' in kwargs:
            subject_name = kwargs['subjectName']
        if subject_name is None:
            raise TypeError("Missing 'subject_name' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("name", name)
        _setter("subject_name", subject_name)
        _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Required String) The name of the subject, representing the subject under which the referenced schema is registered.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> str:
        """
        (Required String) The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
        """
        return pulumi.get(self, "subject_name")

    @property
    @pulumi.getter
    def version(self) -> int:
        """
        (Required Integer) The version of the Schema, for example, `4`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSubjectConfigCredentialsResult(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
        """
        GetSubjectConfigCredentialsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetSubjectConfigSchemaRegistryClusterResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        GetSubjectConfigSchemaRegistryClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetSubjectModeCredentialsResult(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
        """
        GetSubjectModeCredentialsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetSubjectModeSchemaRegistryClusterResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        GetSubjectModeSchemaRegistryClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetTagBindingCredentialsResult(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
        """
        GetTagBindingCredentialsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetTagBindingSchemaRegistryClusterResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        GetTagBindingSchemaRegistryClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetTagCredentialsResult(dict):
    def __init__(__self__, *,
                 key: str,
                 secret: str):
        """
        :param str key: The Schema Registry API Key.
        :param str secret: The Schema Registry API Secret.
        """
        GetTagCredentialsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("key", key)
        _setter("secret", secret)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetTagSchemaRegistryClusterResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        GetTagSchemaRegistryClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetTransitGatewayAttachmentAwResult(dict):
    def __init__(__self__, *,
                 ram_resource_share_arn: str,
                 routes: Sequence[str],
                 transit_gateway_attachment_id: str,
                 transit_gateway_id: str):
        """
        :param str ram_resource_share_arn: (Required String) The Amazon Resource Name (ARN) of the Resource Access Manager (RAM) Resource Share of the transit gateway your Confluent Cloud network attaches to.
        :param Sequence[str] routes: (Required List of String) List of destination routes for traffic from Confluent VPC to customer VPC via Transit Gateway.
        :param str transit_gateway_attachment_id: (Required String) The ID of the AWS Transit Gateway VPC Attachment that attaches Confluent VPC to Transit Gateway.
        :param str transit_gateway_id: (Required String) The ID of the AWS Transit Gateway that you want Confluent CLoud to be attached to. Must start with `tgw-`.
        """
        GetTransitGatewayAttachmentAwResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ram_resource_share_arn=ram_resource_share_arn,
            routes=routes,
            transit_gateway_attachment_id=transit_gateway_attachment_id,
            transit_gateway_id=transit_gateway_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ram_resource_share_arn: Optional[str] = None,
             routes: Optional[Sequence[str]] = None,
             transit_gateway_attachment_id: Optional[str] = None,
             transit_gateway_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ram_resource_share_arn is None and 'ramResourceShareArn' in kwargs:
            ram_resource_share_arn = kwargs['ramResourceShareArn']
        if ram_resource_share_arn is None:
            raise TypeError("Missing 'ram_resource_share_arn' argument")
        if routes is None:
            raise TypeError("Missing 'routes' argument")
        if transit_gateway_attachment_id is None and 'transitGatewayAttachmentId' in kwargs:
            transit_gateway_attachment_id = kwargs['transitGatewayAttachmentId']
        if transit_gateway_attachment_id is None:
            raise TypeError("Missing 'transit_gateway_attachment_id' argument")
        if transit_gateway_id is None and 'transitGatewayId' in kwargs:
            transit_gateway_id = kwargs['transitGatewayId']
        if transit_gateway_id is None:
            raise TypeError("Missing 'transit_gateway_id' argument")

        _setter("ram_resource_share_arn", ram_resource_share_arn)
        _setter("routes", routes)
        _setter("transit_gateway_attachment_id", transit_gateway_attachment_id)
        _setter("transit_gateway_id", transit_gateway_id)

    @property
    @pulumi.getter(name="ramResourceShareArn")
    def ram_resource_share_arn(self) -> str:
        """
        (Required String) The Amazon Resource Name (ARN) of the Resource Access Manager (RAM) Resource Share of the transit gateway your Confluent Cloud network attaches to.
        """
        return pulumi.get(self, "ram_resource_share_arn")

    @property
    @pulumi.getter
    def routes(self) -> Sequence[str]:
        """
        (Required List of String) List of destination routes for traffic from Confluent VPC to customer VPC via Transit Gateway.
        """
        return pulumi.get(self, "routes")

    @property
    @pulumi.getter(name="transitGatewayAttachmentId")
    def transit_gateway_attachment_id(self) -> str:
        """
        (Required String) The ID of the AWS Transit Gateway VPC Attachment that attaches Confluent VPC to Transit Gateway.
        """
        return pulumi.get(self, "transit_gateway_attachment_id")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> str:
        """
        (Required String) The ID of the AWS Transit Gateway that you want Confluent CLoud to be attached to. Must start with `tgw-`.
        """
        return pulumi.get(self, "transit_gateway_id")


@pulumi.output_type
class GetTransitGatewayAttachmentEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Transit Gateway Attachment belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetTransitGatewayAttachmentEnvironmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Transit Gateway Attachment belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetTransitGatewayAttachmentNetworkResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the Environment that the Transit Gateway Attachment belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        GetTransitGatewayAttachmentNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Environment that the Transit Gateway Attachment belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")


