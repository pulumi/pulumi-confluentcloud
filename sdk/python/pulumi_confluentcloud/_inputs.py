# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AccessPointAwsEgressPrivateLinkEndpointArgs',
    'AccessPointAwsEgressPrivateLinkEndpointArgsDict',
    'AccessPointAwsIngressPrivateLinkEndpointArgs',
    'AccessPointAwsIngressPrivateLinkEndpointArgsDict',
    'AccessPointAwsPrivateNetworkInterfaceArgs',
    'AccessPointAwsPrivateNetworkInterfaceArgsDict',
    'AccessPointAzureEgressPrivateLinkEndpointArgs',
    'AccessPointAzureEgressPrivateLinkEndpointArgsDict',
    'AccessPointEnvironmentArgs',
    'AccessPointEnvironmentArgsDict',
    'AccessPointGatewayArgs',
    'AccessPointGatewayArgsDict',
    'AccessPointGcpEgressPrivateServiceConnectEndpointArgs',
    'AccessPointGcpEgressPrivateServiceConnectEndpointArgsDict',
    'ApiKeyManagedResourceArgs',
    'ApiKeyManagedResourceArgsDict',
    'ApiKeyManagedResourceEnvironmentArgs',
    'ApiKeyManagedResourceEnvironmentArgsDict',
    'ApiKeyOwnerArgs',
    'ApiKeyOwnerArgsDict',
    'BusinessMetadataAttributeDefinitionArgs',
    'BusinessMetadataAttributeDefinitionArgsDict',
    'BusinessMetadataBindingCredentialsArgs',
    'BusinessMetadataBindingCredentialsArgsDict',
    'BusinessMetadataBindingSchemaRegistryClusterArgs',
    'BusinessMetadataBindingSchemaRegistryClusterArgsDict',
    'BusinessMetadataCredentialsArgs',
    'BusinessMetadataCredentialsArgsDict',
    'BusinessMetadataSchemaRegistryClusterArgs',
    'BusinessMetadataSchemaRegistryClusterArgsDict',
    'ByokKeyAwsArgs',
    'ByokKeyAwsArgsDict',
    'ByokKeyAzureArgs',
    'ByokKeyAzureArgsDict',
    'ByokKeyGcpArgs',
    'ByokKeyGcpArgsDict',
    'CatalogEntityAttributesCredentialsArgs',
    'CatalogEntityAttributesCredentialsArgsDict',
    'CatalogEntityAttributesSchemaRegistryClusterArgs',
    'CatalogEntityAttributesSchemaRegistryClusterArgsDict',
    'CatalogIntegrationAwsGlueArgs',
    'CatalogIntegrationAwsGlueArgsDict',
    'CatalogIntegrationCredentialsArgs',
    'CatalogIntegrationCredentialsArgsDict',
    'CatalogIntegrationEnvironmentArgs',
    'CatalogIntegrationEnvironmentArgsDict',
    'CatalogIntegrationKafkaClusterArgs',
    'CatalogIntegrationKafkaClusterArgsDict',
    'CatalogIntegrationSnowflakeArgs',
    'CatalogIntegrationSnowflakeArgsDict',
    'CertificatePoolCertificateAuthorityArgs',
    'CertificatePoolCertificateAuthorityArgsDict',
    'ClusterLinkDestinationKafkaClusterArgs',
    'ClusterLinkDestinationKafkaClusterArgsDict',
    'ClusterLinkDestinationKafkaClusterCredentialsArgs',
    'ClusterLinkDestinationKafkaClusterCredentialsArgsDict',
    'ClusterLinkLocalKafkaClusterArgs',
    'ClusterLinkLocalKafkaClusterArgsDict',
    'ClusterLinkLocalKafkaClusterCredentialsArgs',
    'ClusterLinkLocalKafkaClusterCredentialsArgsDict',
    'ClusterLinkRemoteKafkaClusterArgs',
    'ClusterLinkRemoteKafkaClusterArgsDict',
    'ClusterLinkRemoteKafkaClusterCredentialsArgs',
    'ClusterLinkRemoteKafkaClusterCredentialsArgsDict',
    'ClusterLinkSourceKafkaClusterArgs',
    'ClusterLinkSourceKafkaClusterArgsDict',
    'ClusterLinkSourceKafkaClusterCredentialsArgs',
    'ClusterLinkSourceKafkaClusterCredentialsArgsDict',
    'ConnectArtifactEnvironmentArgs',
    'ConnectArtifactEnvironmentArgsDict',
    'ConnectorEnvironmentArgs',
    'ConnectorEnvironmentArgsDict',
    'ConnectorKafkaClusterArgs',
    'ConnectorKafkaClusterArgsDict',
    'ConnectorOffsetArgs',
    'ConnectorOffsetArgsDict',
    'CustomConnectorPluginVersionConnectorClassArgs',
    'CustomConnectorPluginVersionConnectorClassArgsDict',
    'CustomConnectorPluginVersionEnvironmentArgs',
    'CustomConnectorPluginVersionEnvironmentArgsDict',
    'DnsForwarderEnvironmentArgs',
    'DnsForwarderEnvironmentArgsDict',
    'DnsForwarderForwardViaGcpDnsZonesArgs',
    'DnsForwarderForwardViaGcpDnsZonesArgsDict',
    'DnsForwarderForwardViaIpArgs',
    'DnsForwarderForwardViaIpArgsDict',
    'DnsForwarderGatewayArgs',
    'DnsForwarderGatewayArgsDict',
    'DnsRecordEnvironmentArgs',
    'DnsRecordEnvironmentArgsDict',
    'DnsRecordGatewayArgs',
    'DnsRecordGatewayArgsDict',
    'DnsRecordPrivateLinkAccessPointArgs',
    'DnsRecordPrivateLinkAccessPointArgsDict',
    'EnvironmentStreamGovernanceArgs',
    'EnvironmentStreamGovernanceArgsDict',
    'FlinkArtifactEnvironmentArgs',
    'FlinkArtifactEnvironmentArgsDict',
    'FlinkArtifactVersionArgs',
    'FlinkArtifactVersionArgsDict',
    'FlinkComputePoolEnvironmentArgs',
    'FlinkComputePoolEnvironmentArgsDict',
    'FlinkConnectionComputePoolArgs',
    'FlinkConnectionComputePoolArgsDict',
    'FlinkConnectionCredentialsArgs',
    'FlinkConnectionCredentialsArgsDict',
    'FlinkConnectionEnvironmentArgs',
    'FlinkConnectionEnvironmentArgsDict',
    'FlinkConnectionOrganizationArgs',
    'FlinkConnectionOrganizationArgsDict',
    'FlinkConnectionPrincipalArgs',
    'FlinkConnectionPrincipalArgsDict',
    'FlinkStatementComputePoolArgs',
    'FlinkStatementComputePoolArgsDict',
    'FlinkStatementCredentialsArgs',
    'FlinkStatementCredentialsArgsDict',
    'FlinkStatementEnvironmentArgs',
    'FlinkStatementEnvironmentArgsDict',
    'FlinkStatementOrganizationArgs',
    'FlinkStatementOrganizationArgsDict',
    'FlinkStatementPrincipalArgs',
    'FlinkStatementPrincipalArgsDict',
    'GatewayAwsEgressPrivateLinkGatewayArgs',
    'GatewayAwsEgressPrivateLinkGatewayArgsDict',
    'GatewayAwsIngressPrivateLinkGatewayArgs',
    'GatewayAwsIngressPrivateLinkGatewayArgsDict',
    'GatewayAwsPrivateNetworkInterfaceGatewayArgs',
    'GatewayAwsPrivateNetworkInterfaceGatewayArgsDict',
    'GatewayAzureEgressPrivateLinkGatewayArgs',
    'GatewayAzureEgressPrivateLinkGatewayArgsDict',
    'GatewayEnvironmentArgs',
    'GatewayEnvironmentArgsDict',
    'IdentityPoolIdentityProviderArgs',
    'IdentityPoolIdentityProviderArgsDict',
    'InvitationCreatorArgs',
    'InvitationCreatorArgsDict',
    'InvitationUserArgs',
    'InvitationUserArgsDict',
    'KafkaAclCredentialsArgs',
    'KafkaAclCredentialsArgsDict',
    'KafkaAclKafkaClusterArgs',
    'KafkaAclKafkaClusterArgsDict',
    'KafkaClientQuotaEnvironmentArgs',
    'KafkaClientQuotaEnvironmentArgsDict',
    'KafkaClientQuotaKafkaClusterArgs',
    'KafkaClientQuotaKafkaClusterArgsDict',
    'KafkaClientQuotaThroughputArgs',
    'KafkaClientQuotaThroughputArgsDict',
    'KafkaClusterBasicArgs',
    'KafkaClusterBasicArgsDict',
    'KafkaClusterByokKeyArgs',
    'KafkaClusterByokKeyArgsDict',
    'KafkaClusterConfigCredentialsArgs',
    'KafkaClusterConfigCredentialsArgsDict',
    'KafkaClusterConfigKafkaClusterArgs',
    'KafkaClusterConfigKafkaClusterArgsDict',
    'KafkaClusterDedicatedArgs',
    'KafkaClusterDedicatedArgsDict',
    'KafkaClusterEndpointArgs',
    'KafkaClusterEndpointArgsDict',
    'KafkaClusterEnterpriseArgs',
    'KafkaClusterEnterpriseArgsDict',
    'KafkaClusterEnvironmentArgs',
    'KafkaClusterEnvironmentArgsDict',
    'KafkaClusterFreightArgs',
    'KafkaClusterFreightArgsDict',
    'KafkaClusterNetworkArgs',
    'KafkaClusterNetworkArgsDict',
    'KafkaClusterStandardArgs',
    'KafkaClusterStandardArgsDict',
    'KafkaMirrorTopicClusterLinkArgs',
    'KafkaMirrorTopicClusterLinkArgsDict',
    'KafkaMirrorTopicKafkaClusterArgs',
    'KafkaMirrorTopicKafkaClusterArgsDict',
    'KafkaMirrorTopicKafkaClusterCredentialsArgs',
    'KafkaMirrorTopicKafkaClusterCredentialsArgsDict',
    'KafkaMirrorTopicSourceKafkaTopicArgs',
    'KafkaMirrorTopicSourceKafkaTopicArgsDict',
    'KafkaTopicCredentialsArgs',
    'KafkaTopicCredentialsArgsDict',
    'KafkaTopicKafkaClusterArgs',
    'KafkaTopicKafkaClusterArgsDict',
    'KsqlClusterCredentialIdentityArgs',
    'KsqlClusterCredentialIdentityArgsDict',
    'KsqlClusterEnvironmentArgs',
    'KsqlClusterEnvironmentArgsDict',
    'KsqlClusterKafkaClusterArgs',
    'KsqlClusterKafkaClusterArgsDict',
    'NetworkAwArgs',
    'NetworkAwArgsDict',
    'NetworkAzureArgs',
    'NetworkAzureArgsDict',
    'NetworkDnsConfigArgs',
    'NetworkDnsConfigArgsDict',
    'NetworkEnvironmentArgs',
    'NetworkEnvironmentArgsDict',
    'NetworkGatewayArgs',
    'NetworkGatewayArgsDict',
    'NetworkGcpArgs',
    'NetworkGcpArgsDict',
    'NetworkLinkEndpointEnvironmentArgs',
    'NetworkLinkEndpointEnvironmentArgsDict',
    'NetworkLinkEndpointNetworkArgs',
    'NetworkLinkEndpointNetworkArgsDict',
    'NetworkLinkEndpointNetworkLinkServiceArgs',
    'NetworkLinkEndpointNetworkLinkServiceArgsDict',
    'NetworkLinkServiceAcceptArgs',
    'NetworkLinkServiceAcceptArgsDict',
    'NetworkLinkServiceEnvironmentArgs',
    'NetworkLinkServiceEnvironmentArgsDict',
    'NetworkLinkServiceNetworkArgs',
    'NetworkLinkServiceNetworkArgsDict',
    'NetworkZoneInfoArgs',
    'NetworkZoneInfoArgsDict',
    'PeeringAwsArgs',
    'PeeringAwsArgsDict',
    'PeeringAzureArgs',
    'PeeringAzureArgsDict',
    'PeeringEnvironmentArgs',
    'PeeringEnvironmentArgsDict',
    'PeeringGcpArgs',
    'PeeringGcpArgsDict',
    'PeeringNetworkArgs',
    'PeeringNetworkArgsDict',
    'PluginEnvironmentArgs',
    'PluginEnvironmentArgsDict',
    'PrivateLinkAccessAwsArgs',
    'PrivateLinkAccessAwsArgsDict',
    'PrivateLinkAccessAzureArgs',
    'PrivateLinkAccessAzureArgsDict',
    'PrivateLinkAccessEnvironmentArgs',
    'PrivateLinkAccessEnvironmentArgsDict',
    'PrivateLinkAccessGcpArgs',
    'PrivateLinkAccessGcpArgsDict',
    'PrivateLinkAccessNetworkArgs',
    'PrivateLinkAccessNetworkArgsDict',
    'PrivateLinkAttachmentAwArgs',
    'PrivateLinkAttachmentAwArgsDict',
    'PrivateLinkAttachmentAzureArgs',
    'PrivateLinkAttachmentAzureArgsDict',
    'PrivateLinkAttachmentConnectionAwsArgs',
    'PrivateLinkAttachmentConnectionAwsArgsDict',
    'PrivateLinkAttachmentConnectionAzureArgs',
    'PrivateLinkAttachmentConnectionAzureArgsDict',
    'PrivateLinkAttachmentConnectionEnvironmentArgs',
    'PrivateLinkAttachmentConnectionEnvironmentArgsDict',
    'PrivateLinkAttachmentConnectionGcpArgs',
    'PrivateLinkAttachmentConnectionGcpArgsDict',
    'PrivateLinkAttachmentConnectionPrivateLinkAttachmentArgs',
    'PrivateLinkAttachmentConnectionPrivateLinkAttachmentArgsDict',
    'PrivateLinkAttachmentEnvironmentArgs',
    'PrivateLinkAttachmentEnvironmentArgsDict',
    'PrivateLinkAttachmentGcpArgs',
    'PrivateLinkAttachmentGcpArgsDict',
    'ProviderIntegrationAuthorizationAzureArgs',
    'ProviderIntegrationAuthorizationAzureArgsDict',
    'ProviderIntegrationAuthorizationEnvironmentArgs',
    'ProviderIntegrationAuthorizationEnvironmentArgsDict',
    'ProviderIntegrationAuthorizationGcpArgs',
    'ProviderIntegrationAuthorizationGcpArgsDict',
    'ProviderIntegrationAwsArgs',
    'ProviderIntegrationAwsArgsDict',
    'ProviderIntegrationEnvironmentArgs',
    'ProviderIntegrationEnvironmentArgsDict',
    'ProviderIntegrationSetupEnvironmentArgs',
    'ProviderIntegrationSetupEnvironmentArgsDict',
    'ProviderOauthArgs',
    'ProviderOauthArgsDict',
    'SchemaCredentialsArgs',
    'SchemaCredentialsArgsDict',
    'SchemaExporterCredentialsArgs',
    'SchemaExporterCredentialsArgsDict',
    'SchemaExporterDestinationSchemaRegistryClusterArgs',
    'SchemaExporterDestinationSchemaRegistryClusterArgsDict',
    'SchemaExporterDestinationSchemaRegistryClusterCredentialsArgs',
    'SchemaExporterDestinationSchemaRegistryClusterCredentialsArgsDict',
    'SchemaExporterSchemaRegistryClusterArgs',
    'SchemaExporterSchemaRegistryClusterArgsDict',
    'SchemaMetadataArgs',
    'SchemaMetadataArgsDict',
    'SchemaMetadataTagArgs',
    'SchemaMetadataTagArgsDict',
    'SchemaRegistryClusterConfigCredentialsArgs',
    'SchemaRegistryClusterConfigCredentialsArgsDict',
    'SchemaRegistryClusterConfigSchemaRegistryClusterArgs',
    'SchemaRegistryClusterConfigSchemaRegistryClusterArgsDict',
    'SchemaRegistryClusterModeCredentialsArgs',
    'SchemaRegistryClusterModeCredentialsArgsDict',
    'SchemaRegistryClusterModeSchemaRegistryClusterArgs',
    'SchemaRegistryClusterModeSchemaRegistryClusterArgsDict',
    'SchemaRegistryDekCredentialsArgs',
    'SchemaRegistryDekCredentialsArgsDict',
    'SchemaRegistryDekSchemaRegistryClusterArgs',
    'SchemaRegistryDekSchemaRegistryClusterArgsDict',
    'SchemaRegistryKekCredentialsArgs',
    'SchemaRegistryKekCredentialsArgsDict',
    'SchemaRegistryKekSchemaRegistryClusterArgs',
    'SchemaRegistryKekSchemaRegistryClusterArgsDict',
    'SchemaRulesetArgs',
    'SchemaRulesetArgsDict',
    'SchemaRulesetDomainRuleArgs',
    'SchemaRulesetDomainRuleArgsDict',
    'SchemaRulesetMigrationRuleArgs',
    'SchemaRulesetMigrationRuleArgsDict',
    'SchemaSchemaReferenceArgs',
    'SchemaSchemaReferenceArgsDict',
    'SchemaSchemaRegistryClusterArgs',
    'SchemaSchemaRegistryClusterArgsDict',
    'SubjectConfigCredentialsArgs',
    'SubjectConfigCredentialsArgsDict',
    'SubjectConfigSchemaRegistryClusterArgs',
    'SubjectConfigSchemaRegistryClusterArgsDict',
    'SubjectModeCredentialsArgs',
    'SubjectModeCredentialsArgsDict',
    'SubjectModeSchemaRegistryClusterArgs',
    'SubjectModeSchemaRegistryClusterArgsDict',
    'TableflowTopicAzureDataLakeStorageGen2Args',
    'TableflowTopicAzureDataLakeStorageGen2ArgsDict',
    'TableflowTopicByobAwsArgs',
    'TableflowTopicByobAwsArgsDict',
    'TableflowTopicCredentialsArgs',
    'TableflowTopicCredentialsArgsDict',
    'TableflowTopicEnvironmentArgs',
    'TableflowTopicEnvironmentArgsDict',
    'TableflowTopicErrorHandlingArgs',
    'TableflowTopicErrorHandlingArgsDict',
    'TableflowTopicKafkaClusterArgs',
    'TableflowTopicKafkaClusterArgsDict',
    'TableflowTopicManagedStorageArgs',
    'TableflowTopicManagedStorageArgsDict',
    'TagBindingCredentialsArgs',
    'TagBindingCredentialsArgsDict',
    'TagBindingSchemaRegistryClusterArgs',
    'TagBindingSchemaRegistryClusterArgsDict',
    'TagCredentialsArgs',
    'TagCredentialsArgsDict',
    'TagSchemaRegistryClusterArgs',
    'TagSchemaRegistryClusterArgsDict',
    'TransitGatewayAttachmentAwsArgs',
    'TransitGatewayAttachmentAwsArgsDict',
    'TransitGatewayAttachmentEnvironmentArgs',
    'TransitGatewayAttachmentEnvironmentArgsDict',
    'TransitGatewayAttachmentNetworkArgs',
    'TransitGatewayAttachmentNetworkArgsDict',
    'GetAccessPointEnvironmentArgs',
    'GetAccessPointEnvironmentArgsDict',
    'GetAccessPointGcpEgressPrivateServiceConnectEndpointArgs',
    'GetAccessPointGcpEgressPrivateServiceConnectEndpointArgsDict',
    'GetBusinessMetadataBindingCredentialsArgs',
    'GetBusinessMetadataBindingCredentialsArgsDict',
    'GetBusinessMetadataBindingSchemaRegistryClusterArgs',
    'GetBusinessMetadataBindingSchemaRegistryClusterArgsDict',
    'GetBusinessMetadataCredentialsArgs',
    'GetBusinessMetadataCredentialsArgsDict',
    'GetBusinessMetadataSchemaRegistryClusterArgs',
    'GetBusinessMetadataSchemaRegistryClusterArgsDict',
    'GetCatalogIntegrationCredentialsArgs',
    'GetCatalogIntegrationCredentialsArgsDict',
    'GetCatalogIntegrationEnvironmentArgs',
    'GetCatalogIntegrationEnvironmentArgsDict',
    'GetCatalogIntegrationKafkaClusterArgs',
    'GetCatalogIntegrationKafkaClusterArgsDict',
    'GetCertificatePoolCertificateAuthorityArgs',
    'GetCertificatePoolCertificateAuthorityArgsDict',
    'GetClusterLinkCredentialsArgs',
    'GetClusterLinkCredentialsArgsDict',
    'GetClusterLinkKafkaClusterArgs',
    'GetClusterLinkKafkaClusterArgsDict',
    'GetConnectArtifactEnvironmentArgs',
    'GetConnectArtifactEnvironmentArgsDict',
    'GetDnsRecordEnvironmentArgs',
    'GetDnsRecordEnvironmentArgsDict',
    'GetEndpointFilterArgs',
    'GetEndpointFilterArgsDict',
    'GetEndpointFilterEnvironmentArgs',
    'GetEndpointFilterEnvironmentArgsDict',
    'GetEnvironmentStreamGovernanceArgs',
    'GetEnvironmentStreamGovernanceArgsDict',
    'GetFlinkArtifactEnvironmentArgs',
    'GetFlinkArtifactEnvironmentArgsDict',
    'GetFlinkComputePoolEnvironmentArgs',
    'GetFlinkComputePoolEnvironmentArgsDict',
    'GetFlinkConnectionComputePoolArgs',
    'GetFlinkConnectionComputePoolArgsDict',
    'GetFlinkConnectionCredentialsArgs',
    'GetFlinkConnectionCredentialsArgsDict',
    'GetFlinkConnectionEnvironmentArgs',
    'GetFlinkConnectionEnvironmentArgsDict',
    'GetFlinkConnectionOrganizationArgs',
    'GetFlinkConnectionOrganizationArgsDict',
    'GetFlinkConnectionPrincipalArgs',
    'GetFlinkConnectionPrincipalArgsDict',
    'GetGatewayEnvironmentArgs',
    'GetGatewayEnvironmentArgsDict',
    'GetGatewaysEnvironmentArgs',
    'GetGatewaysEnvironmentArgsDict',
    'GetGatewaysFilterArgs',
    'GetGatewaysFilterArgsDict',
    'GetIdentityPoolIdentityProviderArgs',
    'GetIdentityPoolIdentityProviderArgsDict',
    'GetIpAddressesFilterArgs',
    'GetIpAddressesFilterArgsDict',
    'GetKafkaClusterBasicArgs',
    'GetKafkaClusterBasicArgsDict',
    'GetKafkaClusterDedicatedArgs',
    'GetKafkaClusterDedicatedArgsDict',
    'GetKafkaClusterEnterpriseArgs',
    'GetKafkaClusterEnterpriseArgsDict',
    'GetKafkaClusterEnvironmentArgs',
    'GetKafkaClusterEnvironmentArgsDict',
    'GetKafkaClusterFreightArgs',
    'GetKafkaClusterFreightArgsDict',
    'GetKafkaClusterStandardArgs',
    'GetKafkaClusterStandardArgsDict',
    'GetKafkaClustersEnvironmentArgs',
    'GetKafkaClustersEnvironmentArgsDict',
    'GetKafkaTopicCredentialsArgs',
    'GetKafkaTopicCredentialsArgsDict',
    'GetKafkaTopicKafkaClusterArgs',
    'GetKafkaTopicKafkaClusterArgsDict',
    'GetKsqlClusterEnvironmentArgs',
    'GetKsqlClusterEnvironmentArgsDict',
    'GetNetworkAwArgs',
    'GetNetworkAwArgsDict',
    'GetNetworkAzureArgs',
    'GetNetworkAzureArgsDict',
    'GetNetworkDnsConfigArgs',
    'GetNetworkDnsConfigArgsDict',
    'GetNetworkEnvironmentArgs',
    'GetNetworkEnvironmentArgsDict',
    'GetNetworkGcpArgs',
    'GetNetworkGcpArgsDict',
    'GetNetworkLinkEndpointEnvironmentArgs',
    'GetNetworkLinkEndpointEnvironmentArgsDict',
    'GetNetworkLinkServiceAcceptArgs',
    'GetNetworkLinkServiceAcceptArgsDict',
    'GetNetworkLinkServiceEnvironmentArgs',
    'GetNetworkLinkServiceEnvironmentArgsDict',
    'GetPeeringEnvironmentArgs',
    'GetPeeringEnvironmentArgsDict',
    'GetPrivateLinkAccessEnvironmentArgs',
    'GetPrivateLinkAccessEnvironmentArgsDict',
    'GetPrivateLinkAttachmentConnectionEnvironmentArgs',
    'GetPrivateLinkAttachmentConnectionEnvironmentArgsDict',
    'GetPrivateLinkAttachmentEnvironmentArgs',
    'GetPrivateLinkAttachmentEnvironmentArgsDict',
    'GetProviderIntegrationAuthorizationEnvironmentArgs',
    'GetProviderIntegrationAuthorizationEnvironmentArgsDict',
    'GetProviderIntegrationEnvironmentArgs',
    'GetProviderIntegrationEnvironmentArgsDict',
    'GetProviderIntegrationSetupEnvironmentArgs',
    'GetProviderIntegrationSetupEnvironmentArgsDict',
    'GetSchemaCredentialsArgs',
    'GetSchemaCredentialsArgsDict',
    'GetSchemaMetadataArgs',
    'GetSchemaMetadataArgsDict',
    'GetSchemaMetadataTagArgs',
    'GetSchemaMetadataTagArgsDict',
    'GetSchemaRegistryClusterConfigCredentialsArgs',
    'GetSchemaRegistryClusterConfigCredentialsArgsDict',
    'GetSchemaRegistryClusterConfigSchemaRegistryClusterArgs',
    'GetSchemaRegistryClusterConfigSchemaRegistryClusterArgsDict',
    'GetSchemaRegistryClusterEnvironmentArgs',
    'GetSchemaRegistryClusterEnvironmentArgsDict',
    'GetSchemaRegistryClusterModeCredentialsArgs',
    'GetSchemaRegistryClusterModeCredentialsArgsDict',
    'GetSchemaRegistryClusterModeSchemaRegistryClusterArgs',
    'GetSchemaRegistryClusterModeSchemaRegistryClusterArgsDict',
    'GetSchemaRegistryClustersEnvironmentArgs',
    'GetSchemaRegistryClustersEnvironmentArgsDict',
    'GetSchemaRegistryDekCredentialsArgs',
    'GetSchemaRegistryDekCredentialsArgsDict',
    'GetSchemaRegistryDekSchemaRegistryClusterArgs',
    'GetSchemaRegistryDekSchemaRegistryClusterArgsDict',
    'GetSchemaRegistryKekCredentialsArgs',
    'GetSchemaRegistryKekCredentialsArgsDict',
    'GetSchemaRegistryKekSchemaRegistryClusterArgs',
    'GetSchemaRegistryKekSchemaRegistryClusterArgsDict',
    'GetSchemaRulesetArgs',
    'GetSchemaRulesetArgsDict',
    'GetSchemaRulesetDomainRuleArgs',
    'GetSchemaRulesetDomainRuleArgsDict',
    'GetSchemaRulesetMigrationRuleArgs',
    'GetSchemaRulesetMigrationRuleArgsDict',
    'GetSchemaSchemaRegistryClusterArgs',
    'GetSchemaSchemaRegistryClusterArgsDict',
    'GetSchemasCredentialsArgs',
    'GetSchemasCredentialsArgsDict',
    'GetSchemasFilterArgs',
    'GetSchemasFilterArgsDict',
    'GetSchemasSchemaRegistryClusterArgs',
    'GetSchemasSchemaRegistryClusterArgsDict',
    'GetSubjectConfigCredentialsArgs',
    'GetSubjectConfigCredentialsArgsDict',
    'GetSubjectConfigSchemaRegistryClusterArgs',
    'GetSubjectConfigSchemaRegistryClusterArgsDict',
    'GetSubjectModeCredentialsArgs',
    'GetSubjectModeCredentialsArgsDict',
    'GetSubjectModeSchemaRegistryClusterArgs',
    'GetSubjectModeSchemaRegistryClusterArgsDict',
    'GetTableflowTopicCredentialsArgs',
    'GetTableflowTopicCredentialsArgsDict',
    'GetTableflowTopicEnvironmentArgs',
    'GetTableflowTopicEnvironmentArgsDict',
    'GetTableflowTopicKafkaClusterArgs',
    'GetTableflowTopicKafkaClusterArgsDict',
    'GetTagBindingCredentialsArgs',
    'GetTagBindingCredentialsArgsDict',
    'GetTagBindingSchemaRegistryClusterArgs',
    'GetTagBindingSchemaRegistryClusterArgsDict',
    'GetTagCredentialsArgs',
    'GetTagCredentialsArgsDict',
    'GetTagSchemaRegistryClusterArgs',
    'GetTagSchemaRegistryClusterArgsDict',
    'GetTransitGatewayAttachmentEnvironmentArgs',
    'GetTransitGatewayAttachmentEnvironmentArgsDict',
]

class AccessPointAwsEgressPrivateLinkEndpointArgsDict(TypedDict):
    vpc_endpoint_service_name: pulumi.Input[_builtins.str]
    """
    AWS VPC Endpoint Service that can be used to establish connections for all zones, for example `com.amazonaws.vpce.us-west-2.vpce-svc-0d3be37e21708ecd3`.
    """
    enable_high_availability: NotRequired[pulumi.Input[_builtins.bool]]
    """
    Whether a resource should be provisioned with high availability. Endpoints deployed with high availability have network interfaces deployed in multiple AZs. Defaults to `false`.
    """
    vpc_endpoint_dns_name: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The DNS name of a VPC Endpoint (if any) that is connected to the VPC Endpoint service, for example, `*.vpce-00000000000000000-abcd1234.s3.us-west-2.vpce.amazonaws.com`.
    """
    vpc_endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The ID of a VPC Endpoint (if any) that is connected to the VPC Endpoint service, for example, `vpce-00000000000000000`.
    """

@pulumi.input_type
class AccessPointAwsEgressPrivateLinkEndpointArgs:
    def __init__(__self__, *,
                 vpc_endpoint_service_name: pulumi.Input[_builtins.str],
                 enable_high_availability: Optional[pulumi.Input[_builtins.bool]] = None,
                 vpc_endpoint_dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_endpoint_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] vpc_endpoint_service_name: AWS VPC Endpoint Service that can be used to establish connections for all zones, for example `com.amazonaws.vpce.us-west-2.vpce-svc-0d3be37e21708ecd3`.
        :param pulumi.Input[_builtins.bool] enable_high_availability: Whether a resource should be provisioned with high availability. Endpoints deployed with high availability have network interfaces deployed in multiple AZs. Defaults to `false`.
        :param pulumi.Input[_builtins.str] vpc_endpoint_dns_name: (Required String) The DNS name of a VPC Endpoint (if any) that is connected to the VPC Endpoint service, for example, `*.vpce-00000000000000000-abcd1234.s3.us-west-2.vpce.amazonaws.com`.
        :param pulumi.Input[_builtins.str] vpc_endpoint_id: (Required String) The ID of a VPC Endpoint (if any) that is connected to the VPC Endpoint service, for example, `vpce-00000000000000000`.
        """
        pulumi.set(__self__, "vpc_endpoint_service_name", vpc_endpoint_service_name)
        if enable_high_availability is not None:
            pulumi.set(__self__, "enable_high_availability", enable_high_availability)
        if vpc_endpoint_dns_name is not None:
            pulumi.set(__self__, "vpc_endpoint_dns_name", vpc_endpoint_dns_name)
        if vpc_endpoint_id is not None:
            pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)

    @_builtins.property
    @pulumi.getter(name="vpcEndpointServiceName")
    def vpc_endpoint_service_name(self) -> pulumi.Input[_builtins.str]:
        """
        AWS VPC Endpoint Service that can be used to establish connections for all zones, for example `com.amazonaws.vpce.us-west-2.vpce-svc-0d3be37e21708ecd3`.
        """
        return pulumi.get(self, "vpc_endpoint_service_name")

    @vpc_endpoint_service_name.setter
    def vpc_endpoint_service_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_endpoint_service_name", value)

    @_builtins.property
    @pulumi.getter(name="enableHighAvailability")
    def enable_high_availability(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether a resource should be provisioned with high availability. Endpoints deployed with high availability have network interfaces deployed in multiple AZs. Defaults to `false`.
        """
        return pulumi.get(self, "enable_high_availability")

    @enable_high_availability.setter
    def enable_high_availability(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_high_availability", value)

    @_builtins.property
    @pulumi.getter(name="vpcEndpointDnsName")
    def vpc_endpoint_dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The DNS name of a VPC Endpoint (if any) that is connected to the VPC Endpoint service, for example, `*.vpce-00000000000000000-abcd1234.s3.us-west-2.vpce.amazonaws.com`.
        """
        return pulumi.get(self, "vpc_endpoint_dns_name")

    @vpc_endpoint_dns_name.setter
    def vpc_endpoint_dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_endpoint_dns_name", value)

    @_builtins.property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The ID of a VPC Endpoint (if any) that is connected to the VPC Endpoint service, for example, `vpce-00000000000000000`.
        """
        return pulumi.get(self, "vpc_endpoint_id")

    @vpc_endpoint_id.setter
    def vpc_endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_endpoint_id", value)


class AccessPointAwsIngressPrivateLinkEndpointArgsDict(TypedDict):
    vpc_endpoint_id: pulumi.Input[_builtins.str]
    """
    ID of a VPC Endpoint that will be connected to the VPC Endpoint service, for example, `vpce-00000000000000000`.
    """
    dns_domain: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) DNS domain name used to configure the Private Hosted Zone for the Access Point, for example, `ap123abc.us-west-2.aws.accesspoint.confluent.cloud`.
    """
    vpc_endpoint_service_name: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) ID of the Confluent Cloud VPC Endpoint service used for PrivateLink, for example, `com.amazonaws.vpce.us-west-2.vpce-svc-00000000000000000`.
    """

@pulumi.input_type
class AccessPointAwsIngressPrivateLinkEndpointArgs:
    def __init__(__self__, *,
                 vpc_endpoint_id: pulumi.Input[_builtins.str],
                 dns_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_endpoint_service_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] vpc_endpoint_id: ID of a VPC Endpoint that will be connected to the VPC Endpoint service, for example, `vpce-00000000000000000`.
        :param pulumi.Input[_builtins.str] dns_domain: (Required String) DNS domain name used to configure the Private Hosted Zone for the Access Point, for example, `ap123abc.us-west-2.aws.accesspoint.confluent.cloud`.
        :param pulumi.Input[_builtins.str] vpc_endpoint_service_name: (Required String) ID of the Confluent Cloud VPC Endpoint service used for PrivateLink, for example, `com.amazonaws.vpce.us-west-2.vpce-svc-00000000000000000`.
        """
        pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)
        if dns_domain is not None:
            pulumi.set(__self__, "dns_domain", dns_domain)
        if vpc_endpoint_service_name is not None:
            pulumi.set(__self__, "vpc_endpoint_service_name", vpc_endpoint_service_name)

    @_builtins.property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of a VPC Endpoint that will be connected to the VPC Endpoint service, for example, `vpce-00000000000000000`.
        """
        return pulumi.get(self, "vpc_endpoint_id")

    @vpc_endpoint_id.setter
    def vpc_endpoint_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_endpoint_id", value)

    @_builtins.property
    @pulumi.getter(name="dnsDomain")
    def dns_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) DNS domain name used to configure the Private Hosted Zone for the Access Point, for example, `ap123abc.us-west-2.aws.accesspoint.confluent.cloud`.
        """
        return pulumi.get(self, "dns_domain")

    @dns_domain.setter
    def dns_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_domain", value)

    @_builtins.property
    @pulumi.getter(name="vpcEndpointServiceName")
    def vpc_endpoint_service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) ID of the Confluent Cloud VPC Endpoint service used for PrivateLink, for example, `com.amazonaws.vpce.us-west-2.vpce-svc-00000000000000000`.
        """
        return pulumi.get(self, "vpc_endpoint_service_name")

    @vpc_endpoint_service_name.setter
    def vpc_endpoint_service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_endpoint_service_name", value)


class AccessPointAwsPrivateNetworkInterfaceArgsDict(TypedDict):
    account: pulumi.Input[_builtins.str]
    """
    (Required String) The AWS account ID associated with the ENIs you are using for the Confluent Private Network Interface, for example: `000000000000`.
    """
    network_interfaces: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
    """
    (Required List of Strings) List of the IDs of the Elastic Network Interfaces, for example: `["eni-00000000000000000", "eni-00000000000000001", "eni-00000000000000002", "eni-00000000000000003", "eni-00000000000000004", "eni-00000000000000005"]`
    """

@pulumi.input_type
class AccessPointAwsPrivateNetworkInterfaceArgs:
    def __init__(__self__, *,
                 account: pulumi.Input[_builtins.str],
                 network_interfaces: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] account: (Required String) The AWS account ID associated with the ENIs you are using for the Confluent Private Network Interface, for example: `000000000000`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] network_interfaces: (Required List of Strings) List of the IDs of the Elastic Network Interfaces, for example: `["eni-00000000000000000", "eni-00000000000000001", "eni-00000000000000002", "eni-00000000000000003", "eni-00000000000000004", "eni-00000000000000005"]`
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "network_interfaces", network_interfaces)

    @_builtins.property
    @pulumi.getter
    def account(self) -> pulumi.Input[_builtins.str]:
        """
        (Required String) The AWS account ID associated with the ENIs you are using for the Confluent Private Network Interface, for example: `000000000000`.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account", value)

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Required List of Strings) List of the IDs of the Elastic Network Interfaces, for example: `["eni-00000000000000000", "eni-00000000000000001", "eni-00000000000000002", "eni-00000000000000003", "eni-00000000000000004", "eni-00000000000000005"]`
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "network_interfaces", value)


class AccessPointAzureEgressPrivateLinkEndpointArgsDict(TypedDict):
    private_link_service_resource_id: pulumi.Input[_builtins.str]
    """
    Resource ID of the Azure Private Link service.
    """
    private_endpoint_custom_dns_config_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
    """
    (Required List of Strings) Domains of the Private Endpoint (if any) based off FQDNs in Azure custom DNS configs, which are required in your private DNS setup, for example: `["dbname.database.windows.net", "dbname-region.database.windows.net"]`.
    """
    private_endpoint_domain: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) Domain of the Private Endpoint (if any) that is connected to the Private Link service.
    """
    private_endpoint_ip_address: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) IP address of the Private Endpoint (if any) that is connected to the Private Link service.
    """
    private_endpoint_resource_id: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) Resource ID of the Private Endpoint (if any) that is connected to the Private Link service.
    """
    private_link_subresource_name: NotRequired[pulumi.Input[_builtins.str]]
    """
    Name of the subresource for the Private Endpoint to connect to.
    """

@pulumi.input_type
class AccessPointAzureEgressPrivateLinkEndpointArgs:
    def __init__(__self__, *,
                 private_link_service_resource_id: pulumi.Input[_builtins.str],
                 private_endpoint_custom_dns_config_domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 private_endpoint_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 private_endpoint_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 private_endpoint_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 private_link_subresource_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private_link_service_resource_id: Resource ID of the Azure Private Link service.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] private_endpoint_custom_dns_config_domains: (Required List of Strings) Domains of the Private Endpoint (if any) based off FQDNs in Azure custom DNS configs, which are required in your private DNS setup, for example: `["dbname.database.windows.net", "dbname-region.database.windows.net"]`.
        :param pulumi.Input[_builtins.str] private_endpoint_domain: (Required String) Domain of the Private Endpoint (if any) that is connected to the Private Link service.
        :param pulumi.Input[_builtins.str] private_endpoint_ip_address: (Required String) IP address of the Private Endpoint (if any) that is connected to the Private Link service.
        :param pulumi.Input[_builtins.str] private_endpoint_resource_id: (Required String) Resource ID of the Private Endpoint (if any) that is connected to the Private Link service.
        :param pulumi.Input[_builtins.str] private_link_subresource_name: Name of the subresource for the Private Endpoint to connect to.
        """
        pulumi.set(__self__, "private_link_service_resource_id", private_link_service_resource_id)
        if private_endpoint_custom_dns_config_domains is not None:
            pulumi.set(__self__, "private_endpoint_custom_dns_config_domains", private_endpoint_custom_dns_config_domains)
        if private_endpoint_domain is not None:
            pulumi.set(__self__, "private_endpoint_domain", private_endpoint_domain)
        if private_endpoint_ip_address is not None:
            pulumi.set(__self__, "private_endpoint_ip_address", private_endpoint_ip_address)
        if private_endpoint_resource_id is not None:
            pulumi.set(__self__, "private_endpoint_resource_id", private_endpoint_resource_id)
        if private_link_subresource_name is not None:
            pulumi.set(__self__, "private_link_subresource_name", private_link_subresource_name)

    @_builtins.property
    @pulumi.getter(name="privateLinkServiceResourceId")
    def private_link_service_resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        Resource ID of the Azure Private Link service.
        """
        return pulumi.get(self, "private_link_service_resource_id")

    @private_link_service_resource_id.setter
    def private_link_service_resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_link_service_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointCustomDnsConfigDomains")
    def private_endpoint_custom_dns_config_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Required List of Strings) Domains of the Private Endpoint (if any) based off FQDNs in Azure custom DNS configs, which are required in your private DNS setup, for example: `["dbname.database.windows.net", "dbname-region.database.windows.net"]`.
        """
        return pulumi.get(self, "private_endpoint_custom_dns_config_domains")

    @private_endpoint_custom_dns_config_domains.setter
    def private_endpoint_custom_dns_config_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "private_endpoint_custom_dns_config_domains", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointDomain")
    def private_endpoint_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) Domain of the Private Endpoint (if any) that is connected to the Private Link service.
        """
        return pulumi.get(self, "private_endpoint_domain")

    @private_endpoint_domain.setter
    def private_endpoint_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_endpoint_domain", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointIpAddress")
    def private_endpoint_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) IP address of the Private Endpoint (if any) that is connected to the Private Link service.
        """
        return pulumi.get(self, "private_endpoint_ip_address")

    @private_endpoint_ip_address.setter
    def private_endpoint_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_endpoint_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointResourceId")
    def private_endpoint_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) Resource ID of the Private Endpoint (if any) that is connected to the Private Link service.
        """
        return pulumi.get(self, "private_endpoint_resource_id")

    @private_endpoint_resource_id.setter
    def private_endpoint_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_endpoint_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="privateLinkSubresourceName")
    def private_link_subresource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the subresource for the Private Endpoint to connect to.
        """
        return pulumi.get(self, "private_link_subresource_name")

    @private_link_subresource_name.setter
    def private_link_subresource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_link_subresource_name", value)


class AccessPointEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Access Point belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class AccessPointEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Access Point belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Access Point belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class AccessPointGatewayArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the gateway to which the Access Point belongs, for example, `gw-abc123`.
    """

@pulumi.input_type
class AccessPointGatewayArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the gateway to which the Access Point belongs, for example, `gw-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the gateway to which the Access Point belongs, for example, `gw-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class AccessPointGcpEgressPrivateServiceConnectEndpointArgsDict(TypedDict):
    private_service_connect_endpoint_target: pulumi.Input[_builtins.str]
    """
    URI of the service attachment for the published service that the Private Service Connect Endpoint connects to, or "all-google-apis" for global Google APIs.
    """
    private_service_connect_endpoint_connection_id: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) Connection ID of the Private Service Connect Endpoint that is connected to the endpoint target.
    """
    private_service_connect_endpoint_ip_address: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) IP address of the Private Service Connect Endpoint that is connected to the endpoint target.
    """
    private_service_connect_endpoint_name: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) Name of the Private Service Connect Endpoint that is connected to the endpoint target.
    """

@pulumi.input_type
class AccessPointGcpEgressPrivateServiceConnectEndpointArgs:
    def __init__(__self__, *,
                 private_service_connect_endpoint_target: pulumi.Input[_builtins.str],
                 private_service_connect_endpoint_connection_id: Optional[pulumi.Input[_builtins.str]] = None,
                 private_service_connect_endpoint_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 private_service_connect_endpoint_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private_service_connect_endpoint_target: URI of the service attachment for the published service that the Private Service Connect Endpoint connects to, or "all-google-apis" for global Google APIs.
        :param pulumi.Input[_builtins.str] private_service_connect_endpoint_connection_id: (Required String) Connection ID of the Private Service Connect Endpoint that is connected to the endpoint target.
        :param pulumi.Input[_builtins.str] private_service_connect_endpoint_ip_address: (Required String) IP address of the Private Service Connect Endpoint that is connected to the endpoint target.
        :param pulumi.Input[_builtins.str] private_service_connect_endpoint_name: (Required String) Name of the Private Service Connect Endpoint that is connected to the endpoint target.
        """
        pulumi.set(__self__, "private_service_connect_endpoint_target", private_service_connect_endpoint_target)
        if private_service_connect_endpoint_connection_id is not None:
            pulumi.set(__self__, "private_service_connect_endpoint_connection_id", private_service_connect_endpoint_connection_id)
        if private_service_connect_endpoint_ip_address is not None:
            pulumi.set(__self__, "private_service_connect_endpoint_ip_address", private_service_connect_endpoint_ip_address)
        if private_service_connect_endpoint_name is not None:
            pulumi.set(__self__, "private_service_connect_endpoint_name", private_service_connect_endpoint_name)

    @_builtins.property
    @pulumi.getter(name="privateServiceConnectEndpointTarget")
    def private_service_connect_endpoint_target(self) -> pulumi.Input[_builtins.str]:
        """
        URI of the service attachment for the published service that the Private Service Connect Endpoint connects to, or "all-google-apis" for global Google APIs.
        """
        return pulumi.get(self, "private_service_connect_endpoint_target")

    @private_service_connect_endpoint_target.setter
    def private_service_connect_endpoint_target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_service_connect_endpoint_target", value)

    @_builtins.property
    @pulumi.getter(name="privateServiceConnectEndpointConnectionId")
    def private_service_connect_endpoint_connection_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) Connection ID of the Private Service Connect Endpoint that is connected to the endpoint target.
        """
        return pulumi.get(self, "private_service_connect_endpoint_connection_id")

    @private_service_connect_endpoint_connection_id.setter
    def private_service_connect_endpoint_connection_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_service_connect_endpoint_connection_id", value)

    @_builtins.property
    @pulumi.getter(name="privateServiceConnectEndpointIpAddress")
    def private_service_connect_endpoint_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) IP address of the Private Service Connect Endpoint that is connected to the endpoint target.
        """
        return pulumi.get(self, "private_service_connect_endpoint_ip_address")

    @private_service_connect_endpoint_ip_address.setter
    def private_service_connect_endpoint_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_service_connect_endpoint_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="privateServiceConnectEndpointName")
    def private_service_connect_endpoint_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) Name of the Private Service Connect Endpoint that is connected to the endpoint target.
        """
        return pulumi.get(self, "private_service_connect_endpoint_name")

    @private_service_connect_endpoint_name.setter
    def private_service_connect_endpoint_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_service_connect_endpoint_name", value)


class ApiKeyManagedResourceArgsDict(TypedDict):
    api_version: pulumi.Input[_builtins.str]
    """
    The API group and version of the managed resource that the API Key associated with, for example, `cmk/v2`.
    """
    id: pulumi.Input[_builtins.str]
    """
    The ID of the managed resource that the API Key associated with, for example, `lkc-abc123`.
    """
    kind: pulumi.Input[_builtins.str]
    """
    The kind of the managed resource that the API Key associated with, for example, `Cluster`.
    """
    environment: NotRequired[pulumi.Input['ApiKeyManagedResourceEnvironmentArgsDict']]

@pulumi.input_type
class ApiKeyManagedResourceArgs:
    def __init__(__self__, *,
                 api_version: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 kind: pulumi.Input[_builtins.str],
                 environment: Optional[pulumi.Input['ApiKeyManagedResourceEnvironmentArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] api_version: The API group and version of the managed resource that the API Key associated with, for example, `cmk/v2`.
        :param pulumi.Input[_builtins.str] id: The ID of the managed resource that the API Key associated with, for example, `lkc-abc123`.
        :param pulumi.Input[_builtins.str] kind: The kind of the managed resource that the API Key associated with, for example, `Cluster`.
        """
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kind", kind)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> pulumi.Input[_builtins.str]:
        """
        The API group and version of the managed resource that the API Key associated with, for example, `cmk/v2`.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the managed resource that the API Key associated with, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        The kind of the managed resource that the API Key associated with, for example, `Cluster`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input['ApiKeyManagedResourceEnvironmentArgs']]:
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input['ApiKeyManagedResourceEnvironmentArgs']]):
        pulumi.set(self, "environment", value)


class ApiKeyManagedResourceEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the managed resource belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class ApiKeyManagedResourceEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the managed resource belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the managed resource belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class ApiKeyOwnerArgsDict(TypedDict):
    api_version: pulumi.Input[_builtins.str]
    """
    The API group and version of the owner that the API Key belongs to, for example, `iam/v2`.
    """
    id: pulumi.Input[_builtins.str]
    """
    The ID of the owner that the API Key belongs to, for example, `sa-abc123` or `u-abc123`.
    """
    kind: pulumi.Input[_builtins.str]
    """
    The kind of the owner that the API Key belongs to, for example, `ServiceAccount` or `User`.
    """

@pulumi.input_type
class ApiKeyOwnerArgs:
    def __init__(__self__, *,
                 api_version: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 kind: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] api_version: The API group and version of the owner that the API Key belongs to, for example, `iam/v2`.
        :param pulumi.Input[_builtins.str] id: The ID of the owner that the API Key belongs to, for example, `sa-abc123` or `u-abc123`.
        :param pulumi.Input[_builtins.str] kind: The kind of the owner that the API Key belongs to, for example, `ServiceAccount` or `User`.
        """
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> pulumi.Input[_builtins.str]:
        """
        The API group and version of the owner that the API Key belongs to, for example, `iam/v2`.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the owner that the API Key belongs to, for example, `sa-abc123` or `u-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        The kind of the owner that the API Key belongs to, for example, `ServiceAccount` or `User`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)


class BusinessMetadataAttributeDefinitionArgsDict(TypedDict):
    name: pulumi.Input[_builtins.str]
    """
    The name of the attribute.
    """
    default_value: NotRequired[pulumi.Input[_builtins.str]]
    """
    The default value of this attribute.
    """
    description: NotRequired[pulumi.Input[_builtins.str]]
    """
    The description of this attribute.
    """
    is_optional: NotRequired[pulumi.Input[_builtins.bool]]
    """
    An optional flag to control whether the attribute should be optional or required. The default value is `false`.
    """
    options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
    """
    (Optional Map) Block for the attribute options:
    - `applicableEntityTypes` - (Optional String) The entity types that the attribute is applicable, it always returns `[\\"cf_entity\\"]`.
    - `maxStrLength` - (Optional String) The maximum length of the string value, it always returns `5000`.
    """
    type: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The type of the attribute, it always returns `string`.
    """

@pulumi.input_type
class BusinessMetadataAttributeDefinitionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 default_value: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 is_optional: Optional[pulumi.Input[_builtins.bool]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the attribute.
        :param pulumi.Input[_builtins.str] default_value: The default value of this attribute.
        :param pulumi.Input[_builtins.str] description: The description of this attribute.
        :param pulumi.Input[_builtins.bool] is_optional: An optional flag to control whether the attribute should be optional or required. The default value is `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] options: (Optional Map) Block for the attribute options:
               - `applicableEntityTypes` - (Optional String) The entity types that the attribute is applicable, it always returns `[\\"cf_entity\\"]`.
               - `maxStrLength` - (Optional String) The maximum length of the string value, it always returns `5000`.
        :param pulumi.Input[_builtins.str] type: (Required String) The type of the attribute, it always returns `string`.
        """
        pulumi.set(__self__, "name", name)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_optional is not None:
            pulumi.set(__self__, "is_optional", is_optional)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default value of this attribute.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of this attribute.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="isOptional")
    def is_optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        An optional flag to control whether the attribute should be optional or required. The default value is `false`.
        """
        return pulumi.get(self, "is_optional")

    @is_optional.setter
    def is_optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_optional", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Optional Map) Block for the attribute options:
        - `applicableEntityTypes` - (Optional String) The entity types that the attribute is applicable, it always returns `[\\"cf_entity\\"]`.
        - `maxStrLength` - (Optional String) The maximum length of the string value, it always returns `5000`.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The type of the attribute, it always returns `string`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


class BusinessMetadataBindingCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class BusinessMetadataBindingCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class BusinessMetadataBindingSchemaRegistryClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class BusinessMetadataBindingSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class BusinessMetadataCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.

    > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.

    > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_business_metadata.pii"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_business_metadata.pii" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.

    !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `BusinessMetadata` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
    """

@pulumi.input_type
class BusinessMetadataCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
               
               > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_business_metadata.pii"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_business_metadata.pii" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.
               
               !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `BusinessMetadata` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.

        > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_business_metadata.pii"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_business_metadata.pii" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.

        !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `BusinessMetadata` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class BusinessMetadataSchemaRegistryClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class BusinessMetadataSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class ByokKeyAwsArgsDict(TypedDict):
    key_arn: pulumi.Input[_builtins.str]
    """
    The Amazon Resource Name (ARN) of an AWS KMS key.
    """
    roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
    """
    (Optional List of Strings) The Amazon Resource Names (ARNs) of IAM Roles created for this key-environment
    """

@pulumi.input_type
class ByokKeyAwsArgs:
    def __init__(__self__, *,
                 key_arn: pulumi.Input[_builtins.str],
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] key_arn: The Amazon Resource Name (ARN) of an AWS KMS key.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] roles: (Optional List of Strings) The Amazon Resource Names (ARNs) of IAM Roles created for this key-environment
        """
        pulumi.set(__self__, "key_arn", key_arn)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of an AWS KMS key.
        """
        return pulumi.get(self, "key_arn")

    @key_arn.setter
    def key_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_arn", value)

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Optional List of Strings) The Amazon Resource Names (ARNs) of IAM Roles created for this key-environment
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "roles", value)


class ByokKeyAzureArgsDict(TypedDict):
    key_identifier: pulumi.Input[_builtins.str]
    """
    The unique Key Object Identifier URL of an Azure Key Vault key.
    """
    key_vault_id: pulumi.Input[_builtins.str]
    """
    Key Vault ID containing the key.
    """
    tenant_id: pulumi.Input[_builtins.str]
    """
    Tenant ID (uuid) hosting the Key Vault containing the key.
    """
    application_id: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Optional String) The Application ID created for this key-environment combination.
    """

@pulumi.input_type
class ByokKeyAzureArgs:
    def __init__(__self__, *,
                 key_identifier: pulumi.Input[_builtins.str],
                 key_vault_id: pulumi.Input[_builtins.str],
                 tenant_id: pulumi.Input[_builtins.str],
                 application_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key_identifier: The unique Key Object Identifier URL of an Azure Key Vault key.
        :param pulumi.Input[_builtins.str] key_vault_id: Key Vault ID containing the key.
        :param pulumi.Input[_builtins.str] tenant_id: Tenant ID (uuid) hosting the Key Vault containing the key.
        :param pulumi.Input[_builtins.str] application_id: (Optional String) The Application ID created for this key-environment combination.
        """
        pulumi.set(__self__, "key_identifier", key_identifier)
        pulumi.set(__self__, "key_vault_id", key_vault_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)

    @_builtins.property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        The unique Key Object Identifier URL of an Azure Key Vault key.
        """
        return pulumi.get(self, "key_identifier")

    @key_identifier.setter
    def key_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_identifier", value)

    @_builtins.property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> pulumi.Input[_builtins.str]:
        """
        Key Vault ID containing the key.
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_vault_id", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[_builtins.str]:
        """
        Tenant ID (uuid) hosting the Key Vault containing the key.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tenant_id", value)

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional String) The Application ID created for this key-environment combination.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_id", value)


class ByokKeyGcpArgsDict(TypedDict):
    key_id: pulumi.Input[_builtins.str]
    """
    The Google Cloud Platform key ID.
    """
    security_group: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Optional String) The Google security group created for this key.
    """

@pulumi.input_type
class ByokKeyGcpArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 security_group: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key_id: The Google Cloud Platform key ID.
        :param pulumi.Input[_builtins.str] security_group: (Optional String) The Google security group created for this key.
        """
        pulumi.set(__self__, "key_id", key_id)
        if security_group is not None:
            pulumi.set(__self__, "security_group", security_group)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Google Cloud Platform key ID.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional String) The Google security group created for this key.
        """
        return pulumi.get(self, "security_group")

    @security_group.setter
    def security_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group", value)


class CatalogEntityAttributesCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class CatalogEntityAttributesCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class CatalogEntityAttributesSchemaRegistryClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class CatalogEntityAttributesSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class CatalogIntegrationAwsGlueArgsDict(TypedDict):
    provider_integration_id: pulumi.Input[_builtins.str]
    """
    The provider integration id.
    """

@pulumi.input_type
class CatalogIntegrationAwsGlueArgs:
    def __init__(__self__, *,
                 provider_integration_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] provider_integration_id: The provider integration id.
        """
        pulumi.set(__self__, "provider_integration_id", provider_integration_id)

    @_builtins.property
    @pulumi.getter(name="providerIntegrationId")
    def provider_integration_id(self) -> pulumi.Input[_builtins.str]:
        """
        The provider integration id.
        """
        return pulumi.get(self, "provider_integration_id")

    @provider_integration_id.setter
    def provider_integration_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider_integration_id", value)


class CatalogIntegrationCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Tableflow API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Tableflow API Secret.

    > **Note:** A Tableflow API key consists of a key and a secret. Tableflow API keys are required to interact with Catalog Integrations in Confluent Cloud.

    > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Tableflow API key, create a new Tableflow API key, update the `credentials` block in all configuration files to use the new Tableflow API key, run `pulumi up -target="confluent_catalog_integration.example"`, and remove the old Tableflow API key. Alternatively, in case the old Tableflow API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_catalog_integration.example" -out=rotate-tableflow-api-key` and `pulumi up rotate-tableflow-api-key` instead.

    !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `CatalogIntegration` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
    """

@pulumi.input_type
class CatalogIntegrationCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Tableflow API Key.
        :param pulumi.Input[_builtins.str] secret: The Tableflow API Secret.
               
               > **Note:** A Tableflow API key consists of a key and a secret. Tableflow API keys are required to interact with Catalog Integrations in Confluent Cloud.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Tableflow API key, create a new Tableflow API key, update the `credentials` block in all configuration files to use the new Tableflow API key, run `pulumi up -target="confluent_catalog_integration.example"`, and remove the old Tableflow API key. Alternatively, in case the old Tableflow API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_catalog_integration.example" -out=rotate-tableflow-api-key` and `pulumi up rotate-tableflow-api-key` instead.
               
               !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `CatalogIntegration` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Tableflow API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Tableflow API Secret.

        > **Note:** A Tableflow API key consists of a key and a secret. Tableflow API keys are required to interact with Catalog Integrations in Confluent Cloud.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Tableflow API key, create a new Tableflow API key, update the `credentials` block in all configuration files to use the new Tableflow API key, run `pulumi up -target="confluent_catalog_integration.example"`, and remove the old Tableflow API key. Alternatively, in case the old Tableflow API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_catalog_integration.example" -out=rotate-tableflow-api-key` and `pulumi up rotate-tableflow-api-key` instead.

        !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `CatalogIntegration` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class CatalogIntegrationEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment, for example, `env-abc123`.
    """

@pulumi.input_type
class CatalogIntegrationEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class CatalogIntegrationKafkaClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Kafka cluster, for example, `lkc-abc123`.
    """

@pulumi.input_type
class CatalogIntegrationKafkaClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class CatalogIntegrationSnowflakeArgsDict(TypedDict):
    allowed_scope: pulumi.Input[_builtins.str]
    """
    Allowed scope of the Snowflake Open Catalog.
    """
    client_id: pulumi.Input[_builtins.str]
    """
    The client ID of the catalog integration.
    """
    client_secret: pulumi.Input[_builtins.str]
    """
    The client secret of the catalog integration.
    """
    endpoint: pulumi.Input[_builtins.str]
    """
    The catalog integration connection endpoint for Snowflake Open Catalog.
    """
    warehouse: pulumi.Input[_builtins.str]
    """
    Warehouse name of the Snowflake Open Catalog, for example, `catalog-name`.
    """

@pulumi.input_type
class CatalogIntegrationSnowflakeArgs:
    def __init__(__self__, *,
                 allowed_scope: pulumi.Input[_builtins.str],
                 client_id: pulumi.Input[_builtins.str],
                 client_secret: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 warehouse: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] allowed_scope: Allowed scope of the Snowflake Open Catalog.
        :param pulumi.Input[_builtins.str] client_id: The client ID of the catalog integration.
        :param pulumi.Input[_builtins.str] client_secret: The client secret of the catalog integration.
        :param pulumi.Input[_builtins.str] endpoint: The catalog integration connection endpoint for Snowflake Open Catalog.
        :param pulumi.Input[_builtins.str] warehouse: Warehouse name of the Snowflake Open Catalog, for example, `catalog-name`.
        """
        pulumi.set(__self__, "allowed_scope", allowed_scope)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "warehouse", warehouse)

    @_builtins.property
    @pulumi.getter(name="allowedScope")
    def allowed_scope(self) -> pulumi.Input[_builtins.str]:
        """
        Allowed scope of the Snowflake Open Catalog.
        """
        return pulumi.get(self, "allowed_scope")

    @allowed_scope.setter
    def allowed_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "allowed_scope", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        The client ID of the catalog integration.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[_builtins.str]:
        """
        The client secret of the catalog integration.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The catalog integration connection endpoint for Snowflake Open Catalog.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def warehouse(self) -> pulumi.Input[_builtins.str]:
        """
        Warehouse name of the Snowflake Open Catalog, for example, `catalog-name`.
        """
        return pulumi.get(self, "warehouse")

    @warehouse.setter
    def warehouse(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "warehouse", value)


class CertificatePoolCertificateAuthorityArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Certificate Authority for this Certificate Pool, for example, `op-123abc`.
    """

@pulumi.input_type
class CertificatePoolCertificateAuthorityArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Certificate Authority for this Certificate Pool, for example, `op-123abc`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Certificate Authority for this Certificate Pool, for example, `op-123abc`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class ClusterLinkDestinationKafkaClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the destination Kafka cluster, for example, `lkc-abc123`.
    """
    bootstrap_endpoint: NotRequired[pulumi.Input[_builtins.str]]
    """
    The bootstrap endpoint of the destination Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
    """
    credentials: NotRequired[pulumi.Input['ClusterLinkDestinationKafkaClusterCredentialsArgsDict']]
    """
    The Kafka API Credentials.
    """
    rest_endpoint: NotRequired[pulumi.Input[_builtins.str]]
    """
    The REST endpoint of the destination Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
    """

@pulumi.input_type
class ClusterLinkDestinationKafkaClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 bootstrap_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 credentials: Optional[pulumi.Input['ClusterLinkDestinationKafkaClusterCredentialsArgs']] = None,
                 rest_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the destination Kafka cluster, for example, `lkc-abc123`.
        :param pulumi.Input[_builtins.str] bootstrap_endpoint: The bootstrap endpoint of the destination Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        :param pulumi.Input['ClusterLinkDestinationKafkaClusterCredentialsArgs'] credentials: The Kafka API Credentials.
        :param pulumi.Input[_builtins.str] rest_endpoint: The REST endpoint of the destination Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        pulumi.set(__self__, "id", id)
        if bootstrap_endpoint is not None:
            pulumi.set(__self__, "bootstrap_endpoint", bootstrap_endpoint)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if rest_endpoint is not None:
            pulumi.set(__self__, "rest_endpoint", rest_endpoint)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the destination Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="bootstrapEndpoint")
    def bootstrap_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bootstrap endpoint of the destination Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        """
        return pulumi.get(self, "bootstrap_endpoint")

    @bootstrap_endpoint.setter
    def bootstrap_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bootstrap_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['ClusterLinkDestinationKafkaClusterCredentialsArgs']]:
        """
        The Kafka API Credentials.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['ClusterLinkDestinationKafkaClusterCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The REST endpoint of the destination Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        return pulumi.get(self, "rest_endpoint")

    @rest_endpoint.setter
    def rest_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rest_endpoint", value)


class ClusterLinkDestinationKafkaClusterCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Kafka API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Kafka API Secret.
    """

@pulumi.input_type
class ClusterLinkDestinationKafkaClusterCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Kafka API Key.
        :param pulumi.Input[_builtins.str] secret: The Kafka API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class ClusterLinkLocalKafkaClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the local Kafka cluster, for example, `lkc-abc123`.
    """
    bootstrap_endpoint: NotRequired[pulumi.Input[_builtins.str]]
    """
    The bootstrap endpoint of the local Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
    """
    credentials: NotRequired[pulumi.Input['ClusterLinkLocalKafkaClusterCredentialsArgsDict']]
    """
    The Kafka API Credentials.
    """
    rest_endpoint: NotRequired[pulumi.Input[_builtins.str]]
    """
    The REST endpoint of the local Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
    """

@pulumi.input_type
class ClusterLinkLocalKafkaClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 bootstrap_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 credentials: Optional[pulumi.Input['ClusterLinkLocalKafkaClusterCredentialsArgs']] = None,
                 rest_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the local Kafka cluster, for example, `lkc-abc123`.
        :param pulumi.Input[_builtins.str] bootstrap_endpoint: The bootstrap endpoint of the local Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        :param pulumi.Input['ClusterLinkLocalKafkaClusterCredentialsArgs'] credentials: The Kafka API Credentials.
        :param pulumi.Input[_builtins.str] rest_endpoint: The REST endpoint of the local Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        pulumi.set(__self__, "id", id)
        if bootstrap_endpoint is not None:
            pulumi.set(__self__, "bootstrap_endpoint", bootstrap_endpoint)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if rest_endpoint is not None:
            pulumi.set(__self__, "rest_endpoint", rest_endpoint)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the local Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="bootstrapEndpoint")
    def bootstrap_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bootstrap endpoint of the local Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        """
        return pulumi.get(self, "bootstrap_endpoint")

    @bootstrap_endpoint.setter
    def bootstrap_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bootstrap_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['ClusterLinkLocalKafkaClusterCredentialsArgs']]:
        """
        The Kafka API Credentials.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['ClusterLinkLocalKafkaClusterCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The REST endpoint of the local Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        return pulumi.get(self, "rest_endpoint")

    @rest_endpoint.setter
    def rest_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rest_endpoint", value)


class ClusterLinkLocalKafkaClusterCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Kafka API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Kafka API Secret.
    """

@pulumi.input_type
class ClusterLinkLocalKafkaClusterCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Kafka API Key.
        :param pulumi.Input[_builtins.str] secret: The Kafka API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class ClusterLinkRemoteKafkaClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the remote Kafka cluster, for example, `lkc-abc123`.
    """
    bootstrap_endpoint: NotRequired[pulumi.Input[_builtins.str]]
    """
    The bootstrap endpoint of the remote Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
    """
    credentials: NotRequired[pulumi.Input['ClusterLinkRemoteKafkaClusterCredentialsArgsDict']]
    """
    The Kafka API Credentials.
    """
    rest_endpoint: NotRequired[pulumi.Input[_builtins.str]]
    """
    The REST endpoint of the remote Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
    """

@pulumi.input_type
class ClusterLinkRemoteKafkaClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 bootstrap_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 credentials: Optional[pulumi.Input['ClusterLinkRemoteKafkaClusterCredentialsArgs']] = None,
                 rest_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the remote Kafka cluster, for example, `lkc-abc123`.
        :param pulumi.Input[_builtins.str] bootstrap_endpoint: The bootstrap endpoint of the remote Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        :param pulumi.Input['ClusterLinkRemoteKafkaClusterCredentialsArgs'] credentials: The Kafka API Credentials.
        :param pulumi.Input[_builtins.str] rest_endpoint: The REST endpoint of the remote Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        pulumi.set(__self__, "id", id)
        if bootstrap_endpoint is not None:
            pulumi.set(__self__, "bootstrap_endpoint", bootstrap_endpoint)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if rest_endpoint is not None:
            pulumi.set(__self__, "rest_endpoint", rest_endpoint)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the remote Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="bootstrapEndpoint")
    def bootstrap_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bootstrap endpoint of the remote Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        """
        return pulumi.get(self, "bootstrap_endpoint")

    @bootstrap_endpoint.setter
    def bootstrap_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bootstrap_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['ClusterLinkRemoteKafkaClusterCredentialsArgs']]:
        """
        The Kafka API Credentials.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['ClusterLinkRemoteKafkaClusterCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The REST endpoint of the remote Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        return pulumi.get(self, "rest_endpoint")

    @rest_endpoint.setter
    def rest_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rest_endpoint", value)


class ClusterLinkRemoteKafkaClusterCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Kafka API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Kafka API Secret.
    """

@pulumi.input_type
class ClusterLinkRemoteKafkaClusterCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Kafka API Key.
        :param pulumi.Input[_builtins.str] secret: The Kafka API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class ClusterLinkSourceKafkaClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the source Kafka cluster, for example, `lkc-abc123`.
    """
    bootstrap_endpoint: NotRequired[pulumi.Input[_builtins.str]]
    """
    The bootstrap endpoint of the source Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
    """
    credentials: NotRequired[pulumi.Input['ClusterLinkSourceKafkaClusterCredentialsArgsDict']]
    """
    The Kafka API Credentials.
    """
    rest_endpoint: NotRequired[pulumi.Input[_builtins.str]]
    """
    The REST endpoint of the source Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
    """

@pulumi.input_type
class ClusterLinkSourceKafkaClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 bootstrap_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 credentials: Optional[pulumi.Input['ClusterLinkSourceKafkaClusterCredentialsArgs']] = None,
                 rest_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the source Kafka cluster, for example, `lkc-abc123`.
        :param pulumi.Input[_builtins.str] bootstrap_endpoint: The bootstrap endpoint of the source Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        :param pulumi.Input['ClusterLinkSourceKafkaClusterCredentialsArgs'] credentials: The Kafka API Credentials.
        :param pulumi.Input[_builtins.str] rest_endpoint: The REST endpoint of the source Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        pulumi.set(__self__, "id", id)
        if bootstrap_endpoint is not None:
            pulumi.set(__self__, "bootstrap_endpoint", bootstrap_endpoint)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if rest_endpoint is not None:
            pulumi.set(__self__, "rest_endpoint", rest_endpoint)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the source Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="bootstrapEndpoint")
    def bootstrap_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bootstrap endpoint of the source Kafka cluster, for example, `SASL_SSL://pkc-00000.us-central1.gcp.confluent.cloud:9092` or `pkc-00000.us-central1.gcp.confluent.cloud:9092`).
        """
        return pulumi.get(self, "bootstrap_endpoint")

    @bootstrap_endpoint.setter
    def bootstrap_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bootstrap_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['ClusterLinkSourceKafkaClusterCredentialsArgs']]:
        """
        The Kafka API Credentials.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['ClusterLinkSourceKafkaClusterCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The REST endpoint of the source Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        return pulumi.get(self, "rest_endpoint")

    @rest_endpoint.setter
    def rest_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rest_endpoint", value)


class ClusterLinkSourceKafkaClusterCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Kafka API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Kafka API Secret.
    """

@pulumi.input_type
class ClusterLinkSourceKafkaClusterCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Kafka API Key.
        :param pulumi.Input[_builtins.str] secret: The Kafka API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class ConnectArtifactEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Connect Artifact belongs to.
    """

@pulumi.input_type
class ConnectArtifactEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Connect Artifact belongs to.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Connect Artifact belongs to.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class ConnectorEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the connector belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class ConnectorEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the connector belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the connector belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class ConnectorKafkaClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Kafka cluster that the connector belongs to, for example, `lkc-abc123`.
    """

@pulumi.input_type
class ConnectorKafkaClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Kafka cluster that the connector belongs to, for example, `lkc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Kafka cluster that the connector belongs to, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class ConnectorOffsetArgsDict(TypedDict):
    offset: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
    """
    Block with offset information that supports different keys depending on the connector type. For sink connectors, use `kafka_offset`. For source connectors, the applicable keys differ by kindrefer to the [Source connectors page](https://docs.confluent.io/cloud/current/connectors/offsets.html#source-connectors) for the full list of supported keys. Alternatively, use the [Manage custom offsets section](https://docs.confluent.io/cloud/current/connectors/cc-github-source.html#manage-custom-offsets) on the homepage of the target source connector.
    """
    partition: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
    """
    Block with partition information that supports different keys depending on the connector type. For sink connectors, use `kafka_partition` and `kafka_topic`. For source connectors, the applicable keys differ by kindrefer to the [Source connectors page](https://docs.confluent.io/cloud/current/connectors/offsets.html#source-connectors) for the full list of supported keys.
    """

@pulumi.input_type
class ConnectorOffsetArgs:
    def __init__(__self__, *,
                 offset: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 partition: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] offset: Block with offset information that supports different keys depending on the connector type. For sink connectors, use `kafka_offset`. For source connectors, the applicable keys differ by kindrefer to the [Source connectors page](https://docs.confluent.io/cloud/current/connectors/offsets.html#source-connectors) for the full list of supported keys. Alternatively, use the [Manage custom offsets section](https://docs.confluent.io/cloud/current/connectors/cc-github-source.html#manage-custom-offsets) on the homepage of the target source connector.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] partition: Block with partition information that supports different keys depending on the connector type. For sink connectors, use `kafka_partition` and `kafka_topic`. For source connectors, the applicable keys differ by kindrefer to the [Source connectors page](https://docs.confluent.io/cloud/current/connectors/offsets.html#source-connectors) for the full list of supported keys.
        """
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "partition", partition)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        Block with offset information that supports different keys depending on the connector type. For sink connectors, use `kafka_offset`. For source connectors, the applicable keys differ by kindrefer to the [Source connectors page](https://docs.confluent.io/cloud/current/connectors/offsets.html#source-connectors) for the full list of supported keys. Alternatively, use the [Manage custom offsets section](https://docs.confluent.io/cloud/current/connectors/cc-github-source.html#manage-custom-offsets) on the homepage of the target source connector.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "offset", value)

    @_builtins.property
    @pulumi.getter
    def partition(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        Block with partition information that supports different keys depending on the connector type. For sink connectors, use `kafka_partition` and `kafka_topic`. For source connectors, the applicable keys differ by kindrefer to the [Source connectors page](https://docs.confluent.io/cloud/current/connectors/offsets.html#source-connectors) for the full list of supported keys.
        """
        return pulumi.get(self, "partition")

    @partition.setter
    def partition(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "partition", value)


class CustomConnectorPluginVersionConnectorClassArgsDict(TypedDict):
    connector_class_name: pulumi.Input[_builtins.str]
    """
    The name of the connector class.
    """
    connector_type: pulumi.Input[_builtins.str]
    """
    The type of the Custom Connector Plugin. Accepted values are: `SOURCE`, `SINK`.
    """

@pulumi.input_type
class CustomConnectorPluginVersionConnectorClassArgs:
    def __init__(__self__, *,
                 connector_class_name: pulumi.Input[_builtins.str],
                 connector_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] connector_class_name: The name of the connector class.
        :param pulumi.Input[_builtins.str] connector_type: The type of the Custom Connector Plugin. Accepted values are: `SOURCE`, `SINK`.
        """
        pulumi.set(__self__, "connector_class_name", connector_class_name)
        pulumi.set(__self__, "connector_type", connector_type)

    @_builtins.property
    @pulumi.getter(name="connectorClassName")
    def connector_class_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the connector class.
        """
        return pulumi.get(self, "connector_class_name")

    @connector_class_name.setter
    def connector_class_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connector_class_name", value)

    @_builtins.property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the Custom Connector Plugin. Accepted values are: `SOURCE`, `SINK`.
        """
        return pulumi.get(self, "connector_type")

    @connector_type.setter
    def connector_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connector_type", value)


class CustomConnectorPluginVersionEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment, for example, `env-abc123`.
    """

@pulumi.input_type
class CustomConnectorPluginVersionEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class DnsForwarderEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the DNS Forwarder belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class DnsForwarderEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the DNS Forwarder belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the DNS Forwarder belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class DnsForwarderForwardViaGcpDnsZonesArgsDict(TypedDict):
    domain_mappings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
    """
    List of Maps which contains the domain to zone and project mapping.

    > **Note:** The `forward_via_gcp_zones` and `forward_via_ip` blocks are mutually exclusive, and one of them must be provided.

    > **Note:** The zone and project must be specified in the correct order, separated by a comma, to ensure accurate `domain_mappings`.
    """

@pulumi.input_type
class DnsForwarderForwardViaGcpDnsZonesArgs:
    def __init__(__self__, *,
                 domain_mappings: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] domain_mappings: List of Maps which contains the domain to zone and project mapping.
               
               > **Note:** The `forward_via_gcp_zones` and `forward_via_ip` blocks are mutually exclusive, and one of them must be provided.
               
               > **Note:** The zone and project must be specified in the correct order, separated by a comma, to ensure accurate `domain_mappings`.
        """
        if domain_mappings is not None:
            pulumi.set(__self__, "domain_mappings", domain_mappings)

    @_builtins.property
    @pulumi.getter(name="domainMappings")
    def domain_mappings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        List of Maps which contains the domain to zone and project mapping.

        > **Note:** The `forward_via_gcp_zones` and `forward_via_ip` blocks are mutually exclusive, and one of them must be provided.

        > **Note:** The zone and project must be specified in the correct order, separated by a comma, to ensure accurate `domain_mappings`.
        """
        return pulumi.get(self, "domain_mappings")

    @domain_mappings.setter
    def domain_mappings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "domain_mappings", value)


class DnsForwarderForwardViaIpArgsDict(TypedDict):
    dns_server_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
    """
    List of IP addresses of the DNS server.
    """

@pulumi.input_type
class DnsForwarderForwardViaIpArgs:
    def __init__(__self__, *,
                 dns_server_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dns_server_ips: List of IP addresses of the DNS server.
        """
        if dns_server_ips is not None:
            pulumi.set(__self__, "dns_server_ips", dns_server_ips)

    @_builtins.property
    @pulumi.getter(name="dnsServerIps")
    def dns_server_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IP addresses of the DNS server.
        """
        return pulumi.get(self, "dns_server_ips")

    @dns_server_ips.setter
    def dns_server_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dns_server_ips", value)


class DnsForwarderGatewayArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the gateway to which the DNS Forwarder belongs, for example, `gw-abc123`.
    """

@pulumi.input_type
class DnsForwarderGatewayArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the gateway to which the DNS Forwarder belongs, for example, `gw-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the gateway to which the DNS Forwarder belongs, for example, `gw-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class DnsRecordEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the DNS Record belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class DnsRecordEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the DNS Record belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the DNS Record belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class DnsRecordGatewayArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the gateway to which the DNS Record belongs, for example, `gw-abc123`.
    """

@pulumi.input_type
class DnsRecordGatewayArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the gateway to which the DNS Record belongs, for example, `gw-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the gateway to which the DNS Record belongs, for example, `gw-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class DnsRecordPrivateLinkAccessPointArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Private Link access point to which the DNS Record is associated, for example `ap-123abc`.
    """

@pulumi.input_type
class DnsRecordPrivateLinkAccessPointArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Private Link access point to which the DNS Record is associated, for example `ap-123abc`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Private Link access point to which the DNS Record is associated, for example `ap-123abc`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class EnvironmentStreamGovernanceArgsDict(TypedDict):
    package: pulumi.Input[_builtins.str]
    """
    The [stream governance package](https://docs.confluent.io/cloud/current/stream-governance/packages.html#packages) for the Environment. Accepted values are: `ESSENTIALS` and `ADVANCED`.
    """

@pulumi.input_type
class EnvironmentStreamGovernanceArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] package: The [stream governance package](https://docs.confluent.io/cloud/current/stream-governance/packages.html#packages) for the Environment. Accepted values are: `ESSENTIALS` and `ADVANCED`.
        """
        pulumi.set(__self__, "package", package)

    @_builtins.property
    @pulumi.getter
    def package(self) -> pulumi.Input[_builtins.str]:
        """
        The [stream governance package](https://docs.confluent.io/cloud/current/stream-governance/packages.html#packages) for the Environment. Accepted values are: `ESSENTIALS` and `ADVANCED`.
        """
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "package", value)


class FlinkArtifactEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Flink Artifact Pool belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class FlinkArtifactEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Flink Artifact Pool belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Flink Artifact Pool belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class FlinkArtifactVersionArgsDict(TypedDict):
    version: pulumi.Input[_builtins.str]
    """
    The version of this Flink Artifact.
    """

@pulumi.input_type
class FlinkArtifactVersionArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] version: The version of this Flink Artifact.
        """
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        The version of this Flink Artifact.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)


class FlinkComputePoolEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Flink Compute Pool belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class FlinkComputePoolEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Flink Compute Pool belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Flink Compute Pool belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class FlinkConnectionComputePoolArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]

@pulumi.input_type
class FlinkConnectionComputePoolArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class FlinkConnectionCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Cluster API Key for your Confluent Cloud cluster.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Cluster API Secret for your Confluent Cloud cluster.
    """

@pulumi.input_type
class FlinkConnectionCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Cluster API Key for your Confluent Cloud cluster.
        :param pulumi.Input[_builtins.str] secret: The Cluster API Secret for your Confluent Cloud cluster.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Cluster API Key for your Confluent Cloud cluster.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Cluster API Secret for your Confluent Cloud cluster.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class FlinkConnectionEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]

@pulumi.input_type
class FlinkConnectionEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class FlinkConnectionOrganizationArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]

@pulumi.input_type
class FlinkConnectionOrganizationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class FlinkConnectionPrincipalArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]

@pulumi.input_type
class FlinkConnectionPrincipalArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class FlinkStatementComputePoolArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Flink Compute Pool, for example, `lfcp-abc123`.
    """

@pulumi.input_type
class FlinkStatementComputePoolArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Flink Compute Pool, for example, `lfcp-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Flink Compute Pool, for example, `lfcp-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class FlinkStatementCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Flink API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Flink API Secret.

    > **Note:** A Flink API key consists of a key and a secret. Flink API keys are required to interact with Flink Statements in Confluent Cloud. Each Flink API key is valid for one specific Flink Region.

    > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Flink API key, create a new Flink API key, update the `credentials` block in all configuration files to use the new Flink API key, run `pulumi up -target="confluent_flink_statement.example"`, and remove the old Flink API key. Alternatively, in case the old Flink API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_flink_statement.example" -out=rotate-flink-api-key` and `pulumi up rotate-flink-api-key` instead.
    """

@pulumi.input_type
class FlinkStatementCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Flink API Key.
        :param pulumi.Input[_builtins.str] secret: The Flink API Secret.
               
               > **Note:** A Flink API key consists of a key and a secret. Flink API keys are required to interact with Flink Statements in Confluent Cloud. Each Flink API key is valid for one specific Flink Region.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Flink API key, create a new Flink API key, update the `credentials` block in all configuration files to use the new Flink API key, run `pulumi up -target="confluent_flink_statement.example"`, and remove the old Flink API key. Alternatively, in case the old Flink API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_flink_statement.example" -out=rotate-flink-api-key` and `pulumi up rotate-flink-api-key` instead.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Flink API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Flink API Secret.

        > **Note:** A Flink API key consists of a key and a secret. Flink API keys are required to interact with Flink Statements in Confluent Cloud. Each Flink API key is valid for one specific Flink Region.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Flink API key, create a new Flink API key, update the `credentials` block in all configuration files to use the new Flink API key, run `pulumi up -target="confluent_flink_statement.example"`, and remove the old Flink API key. Alternatively, in case the old Flink API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_flink_statement.example" -out=rotate-flink-api-key` and `pulumi up rotate-flink-api-key` instead.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class FlinkStatementEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment, for example, `env-abc123`.
    """

@pulumi.input_type
class FlinkStatementEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class FlinkStatementOrganizationArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Organization, for example, `1111aaaa-11aa-11aa-11aa-111111aaaaaa`.
    """

@pulumi.input_type
class FlinkStatementOrganizationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Organization, for example, `1111aaaa-11aa-11aa-11aa-111111aaaaaa`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Organization, for example, `1111aaaa-11aa-11aa-11aa-111111aaaaaa`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class FlinkStatementPrincipalArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Principal the Flink Statement runs as, for example, `sa-abc123`.
    """

@pulumi.input_type
class FlinkStatementPrincipalArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Principal the Flink Statement runs as, for example, `sa-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Principal the Flink Statement runs as, for example, `sa-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class GatewayAwsEgressPrivateLinkGatewayArgsDict(TypedDict):
    region: pulumi.Input[_builtins.str]
    """
    AWS region of the Gateway, for example, `us-east-1`.
    """
    principal_arn: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The principal ARN used by the AWS Egress Private Link Gateway, for example, `arn:aws:iam::123456789012:tenant-1-role`.
    """

@pulumi.input_type
class GatewayAwsEgressPrivateLinkGatewayArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 principal_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] region: AWS region of the Gateway, for example, `us-east-1`.
        :param pulumi.Input[_builtins.str] principal_arn: (Required String) The principal ARN used by the AWS Egress Private Link Gateway, for example, `arn:aws:iam::123456789012:tenant-1-role`.
        """
        pulumi.set(__self__, "region", region)
        if principal_arn is not None:
            pulumi.set(__self__, "principal_arn", principal_arn)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        AWS region of the Gateway, for example, `us-east-1`.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="principalArn")
    def principal_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The principal ARN used by the AWS Egress Private Link Gateway, for example, `arn:aws:iam::123456789012:tenant-1-role`.
        """
        return pulumi.get(self, "principal_arn")

    @principal_arn.setter
    def principal_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "principal_arn", value)


class GatewayAwsIngressPrivateLinkGatewayArgsDict(TypedDict):
    region: pulumi.Input[_builtins.str]
    """
    AWS region of the Ingress Private Link Gateway, for example, `us-east-1`.
    """
    vpc_endpoint_service_name: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The ID of the AWS VPC Endpoint Service that can be used to establish connections for all zones, for example, `com.amazonaws.vpce.us-west-2.vpce-svc-00000000000000000`.
    """

@pulumi.input_type
class GatewayAwsIngressPrivateLinkGatewayArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 vpc_endpoint_service_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] region: AWS region of the Ingress Private Link Gateway, for example, `us-east-1`.
        :param pulumi.Input[_builtins.str] vpc_endpoint_service_name: (Required String) The ID of the AWS VPC Endpoint Service that can be used to establish connections for all zones, for example, `com.amazonaws.vpce.us-west-2.vpce-svc-00000000000000000`.
        """
        pulumi.set(__self__, "region", region)
        if vpc_endpoint_service_name is not None:
            pulumi.set(__self__, "vpc_endpoint_service_name", vpc_endpoint_service_name)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        AWS region of the Ingress Private Link Gateway, for example, `us-east-1`.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="vpcEndpointServiceName")
    def vpc_endpoint_service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The ID of the AWS VPC Endpoint Service that can be used to establish connections for all zones, for example, `com.amazonaws.vpce.us-west-2.vpce-svc-00000000000000000`.
        """
        return pulumi.get(self, "vpc_endpoint_service_name")

    @vpc_endpoint_service_name.setter
    def vpc_endpoint_service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_endpoint_service_name", value)


class GatewayAwsPrivateNetworkInterfaceGatewayArgsDict(TypedDict):
    region: pulumi.Input[_builtins.str]
    """
    AWS region of the Private Network Interface Gateway.
    """
    zones: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
    """
    AWS availability zone ids of the Private Network Interface Gateway.
    """
    account: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The AWS account ID associated with the Private Network Interface Gateway.
    """

@pulumi.input_type
class GatewayAwsPrivateNetworkInterfaceGatewayArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 zones: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 account: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] region: AWS region of the Private Network Interface Gateway.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] zones: AWS availability zone ids of the Private Network Interface Gateway.
        :param pulumi.Input[_builtins.str] account: (Required String) The AWS account ID associated with the Private Network Interface Gateway.
        """
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "zones", zones)
        if account is not None:
            pulumi.set(__self__, "account", account)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        AWS region of the Private Network Interface Gateway.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def zones(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        AWS availability zone ids of the Private Network Interface Gateway.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "zones", value)

    @_builtins.property
    @pulumi.getter
    def account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The AWS account ID associated with the Private Network Interface Gateway.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account", value)


class GatewayAzureEgressPrivateLinkGatewayArgsDict(TypedDict):
    region: pulumi.Input[_builtins.str]
    """
    Azure region of the Gateway, for example, `eastus`.
    """
    subscription: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The Azure Subscription ID associated with the Confluent Cloud VPC, for example, `00000000-0000-0000-0000-000000000000`.
    """

@pulumi.input_type
class GatewayAzureEgressPrivateLinkGatewayArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 subscription: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] region: Azure region of the Gateway, for example, `eastus`.
        :param pulumi.Input[_builtins.str] subscription: (Required String) The Azure Subscription ID associated with the Confluent Cloud VPC, for example, `00000000-0000-0000-0000-000000000000`.
        """
        pulumi.set(__self__, "region", region)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Azure region of the Gateway, for example, `eastus`.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def subscription(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The Azure Subscription ID associated with the Confluent Cloud VPC, for example, `00000000-0000-0000-0000-000000000000`.
        """
        return pulumi.get(self, "subscription")

    @subscription.setter
    def subscription(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subscription", value)


class GatewayEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Gateway belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class GatewayEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Gateway belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Gateway belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class IdentityPoolIdentityProviderArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Identity Provider associated with the Identity Pool, for example, `op-abc123`.
    """

@pulumi.input_type
class IdentityPoolIdentityProviderArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Identity Provider associated with the Identity Pool, for example, `op-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Identity Provider associated with the Identity Pool, for example, `op-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class InvitationCreatorArgsDict(TypedDict):
    id: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The id of invitation creator.
    """

@pulumi.input_type
class InvitationCreatorArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: (Required String) The id of invitation creator.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The id of invitation creator.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


class InvitationUserArgsDict(TypedDict):
    id: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The id of invitation creator.
    """

@pulumi.input_type
class InvitationUserArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: (Required String) The id of invitation creator.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The id of invitation creator.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


class KafkaAclCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Kafka API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Kafka API Secret.
    """

@pulumi.input_type
class KafkaAclCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Kafka API Key.
        :param pulumi.Input[_builtins.str] secret: The Kafka API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class KafkaAclKafkaClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Kafka cluster, for example, `lkc-abc123`.
    """

@pulumi.input_type
class KafkaAclKafkaClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class KafkaClientQuotaEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.

    > **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.

    > **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
    """

@pulumi.input_type
class KafkaClientQuotaEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.
               
               > **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.
               
               > **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.

        > **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.

        > **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class KafkaClientQuotaKafkaClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Kafka Cluster where the Kafka Client Quota is applied, for example, `lkc-abc123`.
    """

@pulumi.input_type
class KafkaClientQuotaKafkaClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Kafka Cluster where the Kafka Client Quota is applied, for example, `lkc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Kafka Cluster where the Kafka Client Quota is applied, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class KafkaClientQuotaThroughputArgsDict(TypedDict):
    egress_byte_rate: pulumi.Input[_builtins.str]
    """
    The egress throughput limit in bytes per second.
    """
    ingress_byte_rate: pulumi.Input[_builtins.str]
    """
    The ingress throughput limit in bytes per second.
    """

@pulumi.input_type
class KafkaClientQuotaThroughputArgs:
    def __init__(__self__, *,
                 egress_byte_rate: pulumi.Input[_builtins.str],
                 ingress_byte_rate: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] egress_byte_rate: The egress throughput limit in bytes per second.
        :param pulumi.Input[_builtins.str] ingress_byte_rate: The ingress throughput limit in bytes per second.
        """
        pulumi.set(__self__, "egress_byte_rate", egress_byte_rate)
        pulumi.set(__self__, "ingress_byte_rate", ingress_byte_rate)

    @_builtins.property
    @pulumi.getter(name="egressByteRate")
    def egress_byte_rate(self) -> pulumi.Input[_builtins.str]:
        """
        The egress throughput limit in bytes per second.
        """
        return pulumi.get(self, "egress_byte_rate")

    @egress_byte_rate.setter
    def egress_byte_rate(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "egress_byte_rate", value)

    @_builtins.property
    @pulumi.getter(name="ingressByteRate")
    def ingress_byte_rate(self) -> pulumi.Input[_builtins.str]:
        """
        The ingress throughput limit in bytes per second.
        """
        return pulumi.get(self, "ingress_byte_rate")

    @ingress_byte_rate.setter
    def ingress_byte_rate(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ingress_byte_rate", value)


class KafkaClusterBasicArgsDict(TypedDict):
    max_ecku: NotRequired[pulumi.Input[_builtins.int]]
    """
    The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs.
    """

@pulumi.input_type
class KafkaClusterBasicArgs:
    def __init__(__self__, *,
                 max_ecku: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max_ecku: The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs.
        """
        if max_ecku is not None:
            pulumi.set(__self__, "max_ecku", max_ecku)

    @_builtins.property
    @pulumi.getter(name="maxEcku")
    def max_ecku(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs.
        """
        return pulumi.get(self, "max_ecku")

    @max_ecku.setter
    def max_ecku(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_ecku", value)


class KafkaClusterByokKeyArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Confluent key that is used to encrypt the data in the Kafka cluster, for example, `cck-lye5m`.
    """

@pulumi.input_type
class KafkaClusterByokKeyArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Confluent key that is used to encrypt the data in the Kafka cluster, for example, `cck-lye5m`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Confluent key that is used to encrypt the data in the Kafka cluster, for example, `cck-lye5m`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class KafkaClusterConfigCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Kafka API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Kafka API Secret.

    > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.

    > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Kafka API key, create a new Kafka API key, update the `credentials` block in all configuration files to use the new Kafka API key, run `pulumi up -target="confluent_kafka_cluster_config.orders"`, and remove the old Kafka API key. Alternatively, in case the old Kafka API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_kafka_cluster_config.orders" -out=rotate-kafka-api-key` and `pulumi up rotate-kafka-api-key` instead.
    """

@pulumi.input_type
class KafkaClusterConfigCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Kafka API Key.
        :param pulumi.Input[_builtins.str] secret: The Kafka API Secret.
               
               > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Kafka API key, create a new Kafka API key, update the `credentials` block in all configuration files to use the new Kafka API key, run `pulumi up -target="confluent_kafka_cluster_config.orders"`, and remove the old Kafka API key. Alternatively, in case the old Kafka API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_kafka_cluster_config.orders" -out=rotate-kafka-api-key` and `pulumi up rotate-kafka-api-key` instead.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Secret.

        > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Kafka API key, create a new Kafka API key, update the `credentials` block in all configuration files to use the new Kafka API key, run `pulumi up -target="confluent_kafka_cluster_config.orders"`, and remove the old Kafka API key. Alternatively, in case the old Kafka API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_kafka_cluster_config.orders" -out=rotate-kafka-api-key` and `pulumi up rotate-kafka-api-key` instead.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class KafkaClusterConfigKafkaClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Dedicated Kafka cluster, for example, `lkc-abc123`.
    """

@pulumi.input_type
class KafkaClusterConfigKafkaClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Dedicated Kafka cluster, for example, `lkc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Dedicated Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class KafkaClusterDedicatedArgsDict(TypedDict):
    cku: pulumi.Input[_builtins.int]
    """
    The number of Confluent Kafka Units (CKUs) for Dedicated cluster types. The minimum number of CKUs for `SINGLE_ZONE` dedicated clusters is `1` whereas `MULTI_ZONE` dedicated clusters must have `2` CKUs or more.

    > **Note:** Exactly one from the `basic`, `standard`, `dedicated`, `enterprise` or `freight` configuration blocks must be specified.

    > **Note:** The `freight` Kafka cluster type is currently available only on AWS.

    !> **Warning:** You can only upgrade clusters from `basic` to `standard`.

    > **Note:** Currently, provisioning of a Dedicated Kafka cluster takes around 25 minutes on average but might take up to 24 hours. If you can't wait for the `pulumi up` step to finish, you can exit it and import the cluster by using the `pulumi import` command once it has been provisioned. When the cluster is provisioned, you will receive an email notification, and you can also follow updates on the Target Environment web page of the Confluent Cloud website.

    > **Note:** Refer to [eCKU/CKU comparison](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#ecku-cku-comparison) documentation for the minimum/maximum eCKU requirements for each cluster type.
    """
    encryption_key: NotRequired[pulumi.Input[_builtins.str]]
    """
    The ID of the encryption key that is used to encrypt the data in the Kafka cluster.
    """
    zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
    """
    (Required List of String) The list of zones the cluster is in.
    - On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
    """

@pulumi.input_type
class KafkaClusterDedicatedArgs:
    def __init__(__self__, *,
                 cku: pulumi.Input[_builtins.int],
                 encryption_key: Optional[pulumi.Input[_builtins.str]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] cku: The number of Confluent Kafka Units (CKUs) for Dedicated cluster types. The minimum number of CKUs for `SINGLE_ZONE` dedicated clusters is `1` whereas `MULTI_ZONE` dedicated clusters must have `2` CKUs or more.
               
               > **Note:** Exactly one from the `basic`, `standard`, `dedicated`, `enterprise` or `freight` configuration blocks must be specified.
               
               > **Note:** The `freight` Kafka cluster type is currently available only on AWS.
               
               !> **Warning:** You can only upgrade clusters from `basic` to `standard`.
               
               > **Note:** Currently, provisioning of a Dedicated Kafka cluster takes around 25 minutes on average but might take up to 24 hours. If you can't wait for the `pulumi up` step to finish, you can exit it and import the cluster by using the `pulumi import` command once it has been provisioned. When the cluster is provisioned, you will receive an email notification, and you can also follow updates on the Target Environment web page of the Confluent Cloud website.
               
               > **Note:** Refer to [eCKU/CKU comparison](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#ecku-cku-comparison) documentation for the minimum/maximum eCKU requirements for each cluster type.
        :param pulumi.Input[_builtins.str] encryption_key: The ID of the encryption key that is used to encrypt the data in the Kafka cluster.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] zones: (Required List of String) The list of zones the cluster is in.
               - On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
        """
        pulumi.set(__self__, "cku", cku)
        if encryption_key is not None:
            pulumi.set(__self__, "encryption_key", encryption_key)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter
    def cku(self) -> pulumi.Input[_builtins.int]:
        """
        The number of Confluent Kafka Units (CKUs) for Dedicated cluster types. The minimum number of CKUs for `SINGLE_ZONE` dedicated clusters is `1` whereas `MULTI_ZONE` dedicated clusters must have `2` CKUs or more.

        > **Note:** Exactly one from the `basic`, `standard`, `dedicated`, `enterprise` or `freight` configuration blocks must be specified.

        > **Note:** The `freight` Kafka cluster type is currently available only on AWS.

        !> **Warning:** You can only upgrade clusters from `basic` to `standard`.

        > **Note:** Currently, provisioning of a Dedicated Kafka cluster takes around 25 minutes on average but might take up to 24 hours. If you can't wait for the `pulumi up` step to finish, you can exit it and import the cluster by using the `pulumi import` command once it has been provisioned. When the cluster is provisioned, you will receive an email notification, and you can also follow updates on the Target Environment web page of the Confluent Cloud website.

        > **Note:** Refer to [eCKU/CKU comparison](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#ecku-cku-comparison) documentation for the minimum/maximum eCKU requirements for each cluster type.
        """
        return pulumi.get(self, "cku")

    @cku.setter
    def cku(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "cku", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the encryption key that is used to encrypt the data in the Kafka cluster.
        """
        return pulumi.get(self, "encryption_key")

    @encryption_key.setter
    def encryption_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_key", value)

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Required List of String) The list of zones the cluster is in.
        - On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "zones", value)


class KafkaClusterEndpointArgsDict(TypedDict):
    access_point_id: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The ID of the Access Point that the endpoint corresponds to. Access Point IDs `PUBLIC` and `PRIVATE_LINK` are reserved.
    """
    bootstrap_endpoint: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The bootstrap endpoint used by Kafka clients to connect to the cluster (for example, `lkc-abc123-apfoo123.eu-west-3.aws.accesspoint.glb.confluent.cloud:9092`).
    """
    connection_type: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The type of connection used for the endpoint (for example, `PRIVATE_NETWORK_INTERFACE`).
    """
    rest_endpoint: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The REST endpoint of the Kafka cluster (for example, `https://lkc-abc123-apfoo123.eu-west-3.aws.accesspoint.glb.confluent.cloud:443`).
    """

@pulumi.input_type
class KafkaClusterEndpointArgs:
    def __init__(__self__, *,
                 access_point_id: Optional[pulumi.Input[_builtins.str]] = None,
                 bootstrap_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_type: Optional[pulumi.Input[_builtins.str]] = None,
                 rest_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_point_id: (Required String) The ID of the Access Point that the endpoint corresponds to. Access Point IDs `PUBLIC` and `PRIVATE_LINK` are reserved.
        :param pulumi.Input[_builtins.str] bootstrap_endpoint: (Required String) The bootstrap endpoint used by Kafka clients to connect to the cluster (for example, `lkc-abc123-apfoo123.eu-west-3.aws.accesspoint.glb.confluent.cloud:9092`).
        :param pulumi.Input[_builtins.str] connection_type: (Required String) The type of connection used for the endpoint (for example, `PRIVATE_NETWORK_INTERFACE`).
        :param pulumi.Input[_builtins.str] rest_endpoint: (Required String) The REST endpoint of the Kafka cluster (for example, `https://lkc-abc123-apfoo123.eu-west-3.aws.accesspoint.glb.confluent.cloud:443`).
        """
        if access_point_id is not None:
            pulumi.set(__self__, "access_point_id", access_point_id)
        if bootstrap_endpoint is not None:
            pulumi.set(__self__, "bootstrap_endpoint", bootstrap_endpoint)
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if rest_endpoint is not None:
            pulumi.set(__self__, "rest_endpoint", rest_endpoint)

    @_builtins.property
    @pulumi.getter(name="accessPointId")
    def access_point_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The ID of the Access Point that the endpoint corresponds to. Access Point IDs `PUBLIC` and `PRIVATE_LINK` are reserved.
        """
        return pulumi.get(self, "access_point_id")

    @access_point_id.setter
    def access_point_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_point_id", value)

    @_builtins.property
    @pulumi.getter(name="bootstrapEndpoint")
    def bootstrap_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The bootstrap endpoint used by Kafka clients to connect to the cluster (for example, `lkc-abc123-apfoo123.eu-west-3.aws.accesspoint.glb.confluent.cloud:9092`).
        """
        return pulumi.get(self, "bootstrap_endpoint")

    @bootstrap_endpoint.setter
    def bootstrap_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bootstrap_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The type of connection used for the endpoint (for example, `PRIVATE_NETWORK_INTERFACE`).
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_type", value)

    @_builtins.property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The REST endpoint of the Kafka cluster (for example, `https://lkc-abc123-apfoo123.eu-west-3.aws.accesspoint.glb.confluent.cloud:443`).
        """
        return pulumi.get(self, "rest_endpoint")

    @rest_endpoint.setter
    def rest_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rest_endpoint", value)


class KafkaClusterEnterpriseArgsDict(TypedDict):
    max_ecku: NotRequired[pulumi.Input[_builtins.int]]
    """
    The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs.
    """

@pulumi.input_type
class KafkaClusterEnterpriseArgs:
    def __init__(__self__, *,
                 max_ecku: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max_ecku: The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs.
        """
        if max_ecku is not None:
            pulumi.set(__self__, "max_ecku", max_ecku)

    @_builtins.property
    @pulumi.getter(name="maxEcku")
    def max_ecku(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs.
        """
        return pulumi.get(self, "max_ecku")

    @max_ecku.setter
    def max_ecku(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_ecku", value)


class KafkaClusterEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Kafka cluster belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class KafkaClusterEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Kafka cluster belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Kafka cluster belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class KafkaClusterFreightArgsDict(TypedDict):
    max_ecku: NotRequired[pulumi.Input[_builtins.int]]
    """
    The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs.
    """
    zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
    """
    (Required List of String) The list of zones the cluster is in.
    - On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
    """

@pulumi.input_type
class KafkaClusterFreightArgs:
    def __init__(__self__, *,
                 max_ecku: Optional[pulumi.Input[_builtins.int]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] max_ecku: The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] zones: (Required List of String) The list of zones the cluster is in.
               - On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
        """
        if max_ecku is not None:
            pulumi.set(__self__, "max_ecku", max_ecku)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter(name="maxEcku")
    def max_ecku(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs.
        """
        return pulumi.get(self, "max_ecku")

    @max_ecku.setter
    def max_ecku(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_ecku", value)

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Required List of String) The list of zones the cluster is in.
        - On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "zones", value)


class KafkaClusterNetworkArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Network that the Kafka cluster belongs to, for example, `n-abc123`.
    """

@pulumi.input_type
class KafkaClusterNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Network that the Kafka cluster belongs to, for example, `n-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Network that the Kafka cluster belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class KafkaClusterStandardArgsDict(TypedDict):
    max_ecku: NotRequired[pulumi.Input[_builtins.int]]
    """
    The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs.
    """

@pulumi.input_type
class KafkaClusterStandardArgs:
    def __init__(__self__, *,
                 max_ecku: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max_ecku: The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs.
        """
        if max_ecku is not None:
            pulumi.set(__self__, "max_ecku", max_ecku)

    @_builtins.property
    @pulumi.getter(name="maxEcku")
    def max_ecku(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs.
        """
        return pulumi.get(self, "max_ecku")

    @max_ecku.setter
    def max_ecku(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_ecku", value)


class KafkaMirrorTopicClusterLinkArgsDict(TypedDict):
    link_name: pulumi.Input[_builtins.str]
    """
    The name of the cluster link to attach to the mirror topic, for example, `my-cluster-link`.
    """

@pulumi.input_type
class KafkaMirrorTopicClusterLinkArgs:
    def __init__(__self__, *,
                 link_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] link_name: The name of the cluster link to attach to the mirror topic, for example, `my-cluster-link`.
        """
        pulumi.set(__self__, "link_name", link_name)

    @_builtins.property
    @pulumi.getter(name="linkName")
    def link_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the cluster link to attach to the mirror topic, for example, `my-cluster-link`.
        """
        return pulumi.get(self, "link_name")

    @link_name.setter
    def link_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "link_name", value)


class KafkaMirrorTopicKafkaClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the destination Kafka cluster, for example, `lkc-abc123`.
    """
    credentials: NotRequired[pulumi.Input['KafkaMirrorTopicKafkaClusterCredentialsArgsDict']]
    """
    The Kafka API Credentials.
    """
    rest_endpoint: NotRequired[pulumi.Input[_builtins.str]]
    """
    The REST endpoint of the destination Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
    """

@pulumi.input_type
class KafkaMirrorTopicKafkaClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 credentials: Optional[pulumi.Input['KafkaMirrorTopicKafkaClusterCredentialsArgs']] = None,
                 rest_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the destination Kafka cluster, for example, `lkc-abc123`.
        :param pulumi.Input['KafkaMirrorTopicKafkaClusterCredentialsArgs'] credentials: The Kafka API Credentials.
        :param pulumi.Input[_builtins.str] rest_endpoint: The REST endpoint of the destination Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        pulumi.set(__self__, "id", id)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if rest_endpoint is not None:
            pulumi.set(__self__, "rest_endpoint", rest_endpoint)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the destination Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['KafkaMirrorTopicKafkaClusterCredentialsArgs']]:
        """
        The Kafka API Credentials.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['KafkaMirrorTopicKafkaClusterCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The REST endpoint of the destination Kafka cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        return pulumi.get(self, "rest_endpoint")

    @rest_endpoint.setter
    def rest_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rest_endpoint", value)


class KafkaMirrorTopicKafkaClusterCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Kafka API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Kafka API Secret.
    """

@pulumi.input_type
class KafkaMirrorTopicKafkaClusterCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Kafka API Key.
        :param pulumi.Input[_builtins.str] secret: The Kafka API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class KafkaMirrorTopicSourceKafkaTopicArgsDict(TypedDict):
    topic_name: pulumi.Input[_builtins.str]
    """
    The name of the topic on the source cluster to be mirrored over the cluster link, for example, `orders`. A topic with the exact same name must exist on the source cluster, and no topic with this name should exist on the destination cluster.
    """

@pulumi.input_type
class KafkaMirrorTopicSourceKafkaTopicArgs:
    def __init__(__self__, *,
                 topic_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] topic_name: The name of the topic on the source cluster to be mirrored over the cluster link, for example, `orders`. A topic with the exact same name must exist on the source cluster, and no topic with this name should exist on the destination cluster.
        """
        pulumi.set(__self__, "topic_name", topic_name)

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the topic on the source cluster to be mirrored over the cluster link, for example, `orders`. A topic with the exact same name must exist on the source cluster, and no topic with this name should exist on the destination cluster.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_name", value)


class KafkaTopicCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Kafka API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Kafka API Secret.

    > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.

    > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Kafka API key, create a new Kafka API key, update the `credentials` block in all configuration files to use the new Kafka API key, run `pulumi up -target="confluent_kafka_topic.orders"`, and remove the old Kafka API key. Alternatively, in case the old Kafka API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_kafka_topic.orders" -out=rotate-kafka-api-key` and `pulumi up rotate-kafka-api-key` instead.
    """

@pulumi.input_type
class KafkaTopicCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Kafka API Key.
        :param pulumi.Input[_builtins.str] secret: The Kafka API Secret.
               
               > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Kafka API key, create a new Kafka API key, update the `credentials` block in all configuration files to use the new Kafka API key, run `pulumi up -target="confluent_kafka_topic.orders"`, and remove the old Kafka API key. Alternatively, in case the old Kafka API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_kafka_topic.orders" -out=rotate-kafka-api-key` and `pulumi up rotate-kafka-api-key` instead.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka API Secret.

        > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Kafka API key, create a new Kafka API key, update the `credentials` block in all configuration files to use the new Kafka API key, run `pulumi up -target="confluent_kafka_topic.orders"`, and remove the old Kafka API key. Alternatively, in case the old Kafka API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_kafka_topic.orders" -out=rotate-kafka-api-key` and `pulumi up rotate-kafka-api-key` instead.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class KafkaTopicKafkaClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Kafka cluster, for example, `lkc-abc123`.
    """

@pulumi.input_type
class KafkaTopicKafkaClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class KsqlClusterCredentialIdentityArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the associated service or user account, for example, `sa-abc123`.
    """

@pulumi.input_type
class KsqlClusterCredentialIdentityArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the associated service or user account, for example, `sa-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the associated service or user account, for example, `sa-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class KsqlClusterEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the associated Environment, for example, `env-xyz456`.
    """

@pulumi.input_type
class KsqlClusterEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the associated Environment, for example, `env-xyz456`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the associated Environment, for example, `env-xyz456`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class KsqlClusterKafkaClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the associated Kafka cluster, for example, `lkc-abc123`.
    """

@pulumi.input_type
class KsqlClusterKafkaClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the associated Kafka cluster, for example, `lkc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the associated Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class NetworkAwArgsDict(TypedDict):
    account: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The AWS account ID associated with the Confluent Cloud VPC.
    """
    private_link_endpoint_service: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Optional String) The endpoint service of the Confluent Cloud VPC (used for PrivateLink) if available.
    """
    vpc: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The Confluent Cloud VPC ID.
    """

@pulumi.input_type
class NetworkAwArgs:
    def __init__(__self__, *,
                 account: Optional[pulumi.Input[_builtins.str]] = None,
                 private_link_endpoint_service: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account: (Required String) The AWS account ID associated with the Confluent Cloud VPC.
        :param pulumi.Input[_builtins.str] private_link_endpoint_service: (Optional String) The endpoint service of the Confluent Cloud VPC (used for PrivateLink) if available.
        :param pulumi.Input[_builtins.str] vpc: (Required String) The Confluent Cloud VPC ID.
        """
        if account is not None:
            pulumi.set(__self__, "account", account)
        if private_link_endpoint_service is not None:
            pulumi.set(__self__, "private_link_endpoint_service", private_link_endpoint_service)
        if vpc is not None:
            pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter
    def account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The AWS account ID associated with the Confluent Cloud VPC.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account", value)

    @_builtins.property
    @pulumi.getter(name="privateLinkEndpointService")
    def private_link_endpoint_service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional String) The endpoint service of the Confluent Cloud VPC (used for PrivateLink) if available.
        """
        return pulumi.get(self, "private_link_endpoint_service")

    @private_link_endpoint_service.setter
    def private_link_endpoint_service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_link_endpoint_service", value)

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The Confluent Cloud VPC ID.
        """
        return pulumi.get(self, "vpc")

    @vpc.setter
    def vpc(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc", value)


class NetworkAzureArgsDict(TypedDict):
    private_link_service_aliases: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
    """
    (Optional Map) The mapping of zones to Private Link Service Aliases if available. Keys are zone names, for example, `1` and values are [Azure Private Link Service Aliases](https://docs.microsoft.com/en-us/azure/private-link/private-link-service-overview#share-your-service), for example, `s-nk99e-privatelink-1.8c43dcd0-695c-1234-bc35-11fe6abb303a.centralus.azure.privatelinkservice`.
    """

@pulumi.input_type
class NetworkAzureArgs:
    def __init__(__self__, *,
                 private_link_service_aliases: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] private_link_service_aliases: (Optional Map) The mapping of zones to Private Link Service Aliases if available. Keys are zone names, for example, `1` and values are [Azure Private Link Service Aliases](https://docs.microsoft.com/en-us/azure/private-link/private-link-service-overview#share-your-service), for example, `s-nk99e-privatelink-1.8c43dcd0-695c-1234-bc35-11fe6abb303a.centralus.azure.privatelinkservice`.
        """
        if private_link_service_aliases is not None:
            pulumi.set(__self__, "private_link_service_aliases", private_link_service_aliases)

    @_builtins.property
    @pulumi.getter(name="privateLinkServiceAliases")
    def private_link_service_aliases(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Optional Map) The mapping of zones to Private Link Service Aliases if available. Keys are zone names, for example, `1` and values are [Azure Private Link Service Aliases](https://docs.microsoft.com/en-us/azure/private-link/private-link-service-overview#share-your-service), for example, `s-nk99e-privatelink-1.8c43dcd0-695c-1234-bc35-11fe6abb303a.centralus.azure.privatelinkservice`.
        """
        return pulumi.get(self, "private_link_service_aliases")

    @private_link_service_aliases.setter
    def private_link_service_aliases(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "private_link_service_aliases", value)


class NetworkDnsConfigArgsDict(TypedDict):
    resolution: pulumi.Input[_builtins.str]
    """
    Network DNS resolution.
    When resolution is `CHASED_PRIVATE`, clusters in this network require both public and private DNS to resolve cluster endpoints.
    When resolution is `PRIVATE`, clusters in this network only require private DNS to resolve cluster endpoints.
    The Confluent Cloud Console uses `resolution = PRIVATE`.
    """

@pulumi.input_type
class NetworkDnsConfigArgs:
    def __init__(__self__, *,
                 resolution: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] resolution: Network DNS resolution.
               When resolution is `CHASED_PRIVATE`, clusters in this network require both public and private DNS to resolve cluster endpoints.
               When resolution is `PRIVATE`, clusters in this network only require private DNS to resolve cluster endpoints.
               The Confluent Cloud Console uses `resolution = PRIVATE`.
        """
        pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> pulumi.Input[_builtins.str]:
        """
        Network DNS resolution.
        When resolution is `CHASED_PRIVATE`, clusters in this network require both public and private DNS to resolve cluster endpoints.
        When resolution is `PRIVATE`, clusters in this network only require private DNS to resolve cluster endpoints.
        The Confluent Cloud Console uses `resolution = PRIVATE`.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resolution", value)


class NetworkEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Network belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class NetworkEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Network belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Network belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class NetworkGatewayArgsDict(TypedDict):
    id: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Optional String) The ID of the Gateway, for example, `gw-abc123`.
    """

@pulumi.input_type
class NetworkGatewayArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: (Optional String) The ID of the Gateway, for example, `gw-abc123`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional String) The ID of the Gateway, for example, `gw-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


class NetworkGcpArgsDict(TypedDict):
    private_service_connect_service_attachments: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
    """
    (Optional Map) The mapping of zones to Private Service Connect Service Attachments if available. Keys are zones and values are [GCP Private Service Connect service attachment](https://cloud.google.com/vpc/docs/configure-private-service-connect-producer#api_7).
    """
    project: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The GCP Project ID associated with the Confluent Cloud VPC.
    """
    vpc_network: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The network name of the Confluent Cloud VPC.
    """

@pulumi.input_type
class NetworkGcpArgs:
    def __init__(__self__, *,
                 private_service_connect_service_attachments: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 project: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] private_service_connect_service_attachments: (Optional Map) The mapping of zones to Private Service Connect Service Attachments if available. Keys are zones and values are [GCP Private Service Connect service attachment](https://cloud.google.com/vpc/docs/configure-private-service-connect-producer#api_7).
        :param pulumi.Input[_builtins.str] project: (Required String) The GCP Project ID associated with the Confluent Cloud VPC.
        :param pulumi.Input[_builtins.str] vpc_network: (Required String) The network name of the Confluent Cloud VPC.
        """
        if private_service_connect_service_attachments is not None:
            pulumi.set(__self__, "private_service_connect_service_attachments", private_service_connect_service_attachments)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if vpc_network is not None:
            pulumi.set(__self__, "vpc_network", vpc_network)

    @_builtins.property
    @pulumi.getter(name="privateServiceConnectServiceAttachments")
    def private_service_connect_service_attachments(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Optional Map) The mapping of zones to Private Service Connect Service Attachments if available. Keys are zones and values are [GCP Private Service Connect service attachment](https://cloud.google.com/vpc/docs/configure-private-service-connect-producer#api_7).
        """
        return pulumi.get(self, "private_service_connect_service_attachments")

    @private_service_connect_service_attachments.setter
    def private_service_connect_service_attachments(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "private_service_connect_service_attachments", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The GCP Project ID associated with the Confluent Cloud VPC.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project", value)

    @_builtins.property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The network name of the Confluent Cloud VPC.
        """
        return pulumi.get(self, "vpc_network")

    @vpc_network.setter
    def vpc_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_network", value)


class NetworkLinkEndpointEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
    """

@pulumi.input_type
class NetworkLinkEndpointEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class NetworkLinkEndpointNetworkArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Network that the Network Link Endpoint belongs to, for example, `n-abc123`.
    """

@pulumi.input_type
class NetworkLinkEndpointNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Network that the Network Link Endpoint belongs to, for example, `n-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Network that the Network Link Endpoint belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class NetworkLinkEndpointNetworkLinkServiceArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Network Link Service, for example, `nls-g3e1ox`.
    """

@pulumi.input_type
class NetworkLinkEndpointNetworkLinkServiceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Network Link Service, for example, `nls-g3e1ox`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Network Link Service, for example, `nls-g3e1ox`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class NetworkLinkServiceAcceptArgsDict(TypedDict):
    environments: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
    """
    List of environments ids from which connections can be accepted. All networks within the list of environment will be allowed.
    """
    networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
    """
    List of network ids from which connections can be accepted.
    """

@pulumi.input_type
class NetworkLinkServiceAcceptArgs:
    def __init__(__self__, *,
                 environments: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] environments: List of environments ids from which connections can be accepted. All networks within the list of environment will be allowed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] networks: List of network ids from which connections can be accepted.
        """
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter
    def environments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of environments ids from which connections can be accepted. All networks within the list of environment will be allowed.
        """
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environments", value)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of network ids from which connections can be accepted.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "networks", value)


class NetworkLinkServiceEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Network Link Service belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class NetworkLinkServiceEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Network Link Service belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Network Link Service belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class NetworkLinkServiceNetworkArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Network that the Network Link Service belongs to, for example, `n-abc123`.
    """

@pulumi.input_type
class NetworkLinkServiceNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Network that the Network Link Service belongs to, for example, `n-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Network that the Network Link Service belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class NetworkZoneInfoArgsDict(TypedDict):
    cidr: NotRequired[pulumi.Input[_builtins.str]]
    """
    The IPv4 CIDR block to be used for the network. Must be `/27`. Required for VPC peering and AWS TransitGateway.
    """
    zone_id: NotRequired[pulumi.Input[_builtins.str]]
    """
    Cloud provider zone ID.
    """

@pulumi.input_type
class NetworkZoneInfoArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 zone_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cidr: The IPv4 CIDR block to be used for the network. Must be `/27`. Required for VPC peering and AWS TransitGateway.
        :param pulumi.Input[_builtins.str] zone_id: Cloud provider zone ID.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv4 CIDR block to be used for the network. Must be `/27`. Required for VPC peering and AWS TransitGateway.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr", value)

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud provider zone ID.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone_id", value)


class PeeringAwsArgsDict(TypedDict):
    account: pulumi.Input[_builtins.str]
    """
    The AWS Account ID of the peer VPC owner. You can find your AWS Account ID [here](https://console.aws.amazon.com/billing/home?#/account) under **My Account** section of the AWS Management Console. Must be a **12 character string**.
    """
    customer_region: pulumi.Input[_builtins.str]
    """
    The region of the AWS peer VPC.
    """
    routes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
    """
    The AWS VPC CIDR blocks or subsets. This must be from the supported CIDR blocks and must not overlap with your Confluent Cloud CIDR block or any other network peering connection VPC CIDR (learn more about the requirements [here](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html#vpc-peering-on-aws)). You can find AWS VPC CIDR [here](https://console.aws.amazon.com/vpc/) under **Your VPCs > Target VPC > Details** section of the AWS Management Console.
    """
    vpc: pulumi.Input[_builtins.str]
    """
    The AWS VPC ID of the peer VPC that you're peering with Confluent Cloud. You can find your AWS VPC ID [here](https://console.aws.amazon.com/vpc/) under **Your VPCs** section of the AWS Management Console. Must start with `vpc-`.
    """

@pulumi.input_type
class PeeringAwsArgs:
    def __init__(__self__, *,
                 account: pulumi.Input[_builtins.str],
                 customer_region: pulumi.Input[_builtins.str],
                 routes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 vpc: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] account: The AWS Account ID of the peer VPC owner. You can find your AWS Account ID [here](https://console.aws.amazon.com/billing/home?#/account) under **My Account** section of the AWS Management Console. Must be a **12 character string**.
        :param pulumi.Input[_builtins.str] customer_region: The region of the AWS peer VPC.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] routes: The AWS VPC CIDR blocks or subsets. This must be from the supported CIDR blocks and must not overlap with your Confluent Cloud CIDR block or any other network peering connection VPC CIDR (learn more about the requirements [here](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html#vpc-peering-on-aws)). You can find AWS VPC CIDR [here](https://console.aws.amazon.com/vpc/) under **Your VPCs > Target VPC > Details** section of the AWS Management Console.
        :param pulumi.Input[_builtins.str] vpc: The AWS VPC ID of the peer VPC that you're peering with Confluent Cloud. You can find your AWS VPC ID [here](https://console.aws.amazon.com/vpc/) under **Your VPCs** section of the AWS Management Console. Must start with `vpc-`.
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "customer_region", customer_region)
        pulumi.set(__self__, "routes", routes)
        pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter
    def account(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS Account ID of the peer VPC owner. You can find your AWS Account ID [here](https://console.aws.amazon.com/billing/home?#/account) under **My Account** section of the AWS Management Console. Must be a **12 character string**.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account", value)

    @_builtins.property
    @pulumi.getter(name="customerRegion")
    def customer_region(self) -> pulumi.Input[_builtins.str]:
        """
        The region of the AWS peer VPC.
        """
        return pulumi.get(self, "customer_region")

    @customer_region.setter
    def customer_region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "customer_region", value)

    @_builtins.property
    @pulumi.getter
    def routes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The AWS VPC CIDR blocks or subsets. This must be from the supported CIDR blocks and must not overlap with your Confluent Cloud CIDR block or any other network peering connection VPC CIDR (learn more about the requirements [here](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html#vpc-peering-on-aws)). You can find AWS VPC CIDR [here](https://console.aws.amazon.com/vpc/) under **Your VPCs > Target VPC > Details** section of the AWS Management Console.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "routes", value)

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS VPC ID of the peer VPC that you're peering with Confluent Cloud. You can find your AWS VPC ID [here](https://console.aws.amazon.com/vpc/) under **Your VPCs** section of the AWS Management Console. Must start with `vpc-`.
        """
        return pulumi.get(self, "vpc")

    @vpc.setter
    def vpc(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc", value)


class PeeringAzureArgsDict(TypedDict):
    customer_region: pulumi.Input[_builtins.str]
    """
    The region of the Azure peer VNet.
    """
    tenant: pulumi.Input[_builtins.str]
    """
    The Tenant ID that represents an organization in Azure Active Directory. You can find your Azure Tenant ID in the [Azure Portal under Azure Active Directory](https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/Overview). Must be a valid **32 character UUID string**.
    """
    vnet: pulumi.Input[_builtins.str]
    """
    The resource (composite) ID of the peer Virtual Network that you're peering with Confluent Cloud, in the format `/subscriptions/<Subscription ID>/resourceGroups/<Resource Group Name>/providers/Microsoft.Network/virtualNetworks/<VNet name>`. You can find Subscription ID, Resource Group Name and your VNet name under **Virtual Networks > Target VNet > Essentials** section of your [Microsoft Azure Portal](https://portal.azure.com/).
    """

@pulumi.input_type
class PeeringAzureArgs:
    def __init__(__self__, *,
                 customer_region: pulumi.Input[_builtins.str],
                 tenant: pulumi.Input[_builtins.str],
                 vnet: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] customer_region: The region of the Azure peer VNet.
        :param pulumi.Input[_builtins.str] tenant: The Tenant ID that represents an organization in Azure Active Directory. You can find your Azure Tenant ID in the [Azure Portal under Azure Active Directory](https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/Overview). Must be a valid **32 character UUID string**.
        :param pulumi.Input[_builtins.str] vnet: The resource (composite) ID of the peer Virtual Network that you're peering with Confluent Cloud, in the format `/subscriptions/<Subscription ID>/resourceGroups/<Resource Group Name>/providers/Microsoft.Network/virtualNetworks/<VNet name>`. You can find Subscription ID, Resource Group Name and your VNet name under **Virtual Networks > Target VNet > Essentials** section of your [Microsoft Azure Portal](https://portal.azure.com/).
        """
        pulumi.set(__self__, "customer_region", customer_region)
        pulumi.set(__self__, "tenant", tenant)
        pulumi.set(__self__, "vnet", vnet)

    @_builtins.property
    @pulumi.getter(name="customerRegion")
    def customer_region(self) -> pulumi.Input[_builtins.str]:
        """
        The region of the Azure peer VNet.
        """
        return pulumi.get(self, "customer_region")

    @customer_region.setter
    def customer_region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "customer_region", value)

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> pulumi.Input[_builtins.str]:
        """
        The Tenant ID that represents an organization in Azure Active Directory. You can find your Azure Tenant ID in the [Azure Portal under Azure Active Directory](https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/Overview). Must be a valid **32 character UUID string**.
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tenant", value)

    @_builtins.property
    @pulumi.getter
    def vnet(self) -> pulumi.Input[_builtins.str]:
        """
        The resource (composite) ID of the peer Virtual Network that you're peering with Confluent Cloud, in the format `/subscriptions/<Subscription ID>/resourceGroups/<Resource Group Name>/providers/Microsoft.Network/virtualNetworks/<VNet name>`. You can find Subscription ID, Resource Group Name and your VNet name under **Virtual Networks > Target VNet > Essentials** section of your [Microsoft Azure Portal](https://portal.azure.com/).
        """
        return pulumi.get(self, "vnet")

    @vnet.setter
    def vnet(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vnet", value)


class PeeringEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Peering belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class PeeringEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Peering belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Peering belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class PeeringGcpArgsDict(TypedDict):
    project: pulumi.Input[_builtins.str]
    """
    The GCP Project ID. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).
    """
    vpc_network: pulumi.Input[_builtins.str]
    """
    The VPC network name that you're peering to Confluent Cloud. You can find your VPC network name under **VPC Networks** section of your [Google Cloud Console](https://console.cloud.google.com/networking/networks/list).
    """
    import_custom_routes: NotRequired[pulumi.Input[_builtins.bool]]
    """
    The Import Custom Routes option enables connectivity to a Confluent Cloud cluster in Google Cloud from customer premise or other clouds, such as AWS and Azure, through a customer VPC that is peered with Confluent Cloud in the same region. Defaults to `false`. Learn more about considerations / limitations of the Import Custom Routes option [here](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html#import-custom-routes).

    > **Note:** Exactly one from the `aws`, `azure`, and `gcp` configuration blocks must be specified.

    > **Note:** Learn more about VPC Peering requirements on AWS [here](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html#vpc-peering-on-aws).

    > **Note:** Learn more about VNet Peering requirements on Azure [here](https://docs.confluent.io/cloud/current/networking/peering/azure-peering.html#vnet-peering-on-az).

    > **Note:** Learn more about VPC Peering requirements on Google Cloud Platform [here](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html#vpc-peering-on-gcp).
    """

@pulumi.input_type
class PeeringGcpArgs:
    def __init__(__self__, *,
                 project: pulumi.Input[_builtins.str],
                 vpc_network: pulumi.Input[_builtins.str],
                 import_custom_routes: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] project: The GCP Project ID. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).
        :param pulumi.Input[_builtins.str] vpc_network: The VPC network name that you're peering to Confluent Cloud. You can find your VPC network name under **VPC Networks** section of your [Google Cloud Console](https://console.cloud.google.com/networking/networks/list).
        :param pulumi.Input[_builtins.bool] import_custom_routes: The Import Custom Routes option enables connectivity to a Confluent Cloud cluster in Google Cloud from customer premise or other clouds, such as AWS and Azure, through a customer VPC that is peered with Confluent Cloud in the same region. Defaults to `false`. Learn more about considerations / limitations of the Import Custom Routes option [here](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html#import-custom-routes).
               
               > **Note:** Exactly one from the `aws`, `azure`, and `gcp` configuration blocks must be specified.
               
               > **Note:** Learn more about VPC Peering requirements on AWS [here](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html#vpc-peering-on-aws).
               
               > **Note:** Learn more about VNet Peering requirements on Azure [here](https://docs.confluent.io/cloud/current/networking/peering/azure-peering.html#vnet-peering-on-az).
               
               > **Note:** Learn more about VPC Peering requirements on Google Cloud Platform [here](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html#vpc-peering-on-gcp).
        """
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "vpc_network", vpc_network)
        if import_custom_routes is not None:
            pulumi.set(__self__, "import_custom_routes", import_custom_routes)

    @_builtins.property
    @pulumi.getter
    def project(self) -> pulumi.Input[_builtins.str]:
        """
        The GCP Project ID. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project", value)

    @_builtins.property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> pulumi.Input[_builtins.str]:
        """
        The VPC network name that you're peering to Confluent Cloud. You can find your VPC network name under **VPC Networks** section of your [Google Cloud Console](https://console.cloud.google.com/networking/networks/list).
        """
        return pulumi.get(self, "vpc_network")

    @vpc_network.setter
    def vpc_network(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_network", value)

    @_builtins.property
    @pulumi.getter(name="importCustomRoutes")
    def import_custom_routes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The Import Custom Routes option enables connectivity to a Confluent Cloud cluster in Google Cloud from customer premise or other clouds, such as AWS and Azure, through a customer VPC that is peered with Confluent Cloud in the same region. Defaults to `false`. Learn more about considerations / limitations of the Import Custom Routes option [here](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html#import-custom-routes).

        > **Note:** Exactly one from the `aws`, `azure`, and `gcp` configuration blocks must be specified.

        > **Note:** Learn more about VPC Peering requirements on AWS [here](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html#vpc-peering-on-aws).

        > **Note:** Learn more about VNet Peering requirements on Azure [here](https://docs.confluent.io/cloud/current/networking/peering/azure-peering.html#vnet-peering-on-az).

        > **Note:** Learn more about VPC Peering requirements on Google Cloud Platform [here](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html#vpc-peering-on-gcp).
        """
        return pulumi.get(self, "import_custom_routes")

    @import_custom_routes.setter
    def import_custom_routes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "import_custom_routes", value)


class PeeringNetworkArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Network that the Peering belongs to, for example, `n-abc123`.
    """

@pulumi.input_type
class PeeringNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Network that the Peering belongs to, for example, `n-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Network that the Peering belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class PluginEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment, for example, `env-abc123`.
    """

@pulumi.input_type
class PluginEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class PrivateLinkAccessAwsArgsDict(TypedDict):
    account: pulumi.Input[_builtins.str]
    """
    The AWS account ID to enable for the Private Link Access. You can find your AWS account ID [here] (https://console.aws.amazon.com/billing/home?#/account) under **My Account** in your AWS Management Console. Must be a **12 character string**.
    """

@pulumi.input_type
class PrivateLinkAccessAwsArgs:
    def __init__(__self__, *,
                 account: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] account: The AWS account ID to enable for the Private Link Access. You can find your AWS account ID [here] (https://console.aws.amazon.com/billing/home?#/account) under **My Account** in your AWS Management Console. Must be a **12 character string**.
        """
        pulumi.set(__self__, "account", account)

    @_builtins.property
    @pulumi.getter
    def account(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS account ID to enable for the Private Link Access. You can find your AWS account ID [here] (https://console.aws.amazon.com/billing/home?#/account) under **My Account** in your AWS Management Console. Must be a **12 character string**.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account", value)


class PrivateLinkAccessAzureArgsDict(TypedDict):
    subscription: pulumi.Input[_builtins.str]
    """
    The Azure subscription ID to enable for the Private Link Access. You can find your Azure subscription ID in the subscription section of your [Microsoft Azure Portal] (https://portal.azure.com/#blade/Microsoft_Azure_Billing/SubscriptionsBlade). Must be a valid **32 character UUID string**.
    """

@pulumi.input_type
class PrivateLinkAccessAzureArgs:
    def __init__(__self__, *,
                 subscription: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] subscription: The Azure subscription ID to enable for the Private Link Access. You can find your Azure subscription ID in the subscription section of your [Microsoft Azure Portal] (https://portal.azure.com/#blade/Microsoft_Azure_Billing/SubscriptionsBlade). Must be a valid **32 character UUID string**.
        """
        pulumi.set(__self__, "subscription", subscription)

    @_builtins.property
    @pulumi.getter
    def subscription(self) -> pulumi.Input[_builtins.str]:
        """
        The Azure subscription ID to enable for the Private Link Access. You can find your Azure subscription ID in the subscription section of your [Microsoft Azure Portal] (https://portal.azure.com/#blade/Microsoft_Azure_Billing/SubscriptionsBlade). Must be a valid **32 character UUID string**.
        """
        return pulumi.get(self, "subscription")

    @subscription.setter
    def subscription(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subscription", value)


class PrivateLinkAccessEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Private Link Access belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class PrivateLinkAccessEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Private Link Access belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Private Link Access belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class PrivateLinkAccessGcpArgsDict(TypedDict):
    project: pulumi.Input[_builtins.str]
    """
    The GCP project ID to allow for Private Service Connect access. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).

    > **Note:** Exactly one from the `aws`, `azure`, `gcp` configuration blocks must be specified.

    > **Note:** Learn more about Private Link Access limitations on AWS [here](https://docs.confluent.io/cloud/current/networking/private-links/aws-privatelink.html#limitations).

    > **Note:** Learn more about Private Link Access limitations on Azure [here](https://docs.confluent.io/cloud/current/networking/private-links/azure-privatelink.html#limitations).
    """

@pulumi.input_type
class PrivateLinkAccessGcpArgs:
    def __init__(__self__, *,
                 project: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] project: The GCP project ID to allow for Private Service Connect access. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).
               
               > **Note:** Exactly one from the `aws`, `azure`, `gcp` configuration blocks must be specified.
               
               > **Note:** Learn more about Private Link Access limitations on AWS [here](https://docs.confluent.io/cloud/current/networking/private-links/aws-privatelink.html#limitations).
               
               > **Note:** Learn more about Private Link Access limitations on Azure [here](https://docs.confluent.io/cloud/current/networking/private-links/azure-privatelink.html#limitations).
        """
        pulumi.set(__self__, "project", project)

    @_builtins.property
    @pulumi.getter
    def project(self) -> pulumi.Input[_builtins.str]:
        """
        The GCP project ID to allow for Private Service Connect access. You can find your Google Cloud Project ID under **Project ID** section of your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).

        > **Note:** Exactly one from the `aws`, `azure`, `gcp` configuration blocks must be specified.

        > **Note:** Learn more about Private Link Access limitations on AWS [here](https://docs.confluent.io/cloud/current/networking/private-links/aws-privatelink.html#limitations).

        > **Note:** Learn more about Private Link Access limitations on Azure [here](https://docs.confluent.io/cloud/current/networking/private-links/azure-privatelink.html#limitations).
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project", value)


class PrivateLinkAccessNetworkArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Network that the Private Link Access belongs to, for example, `n-abc123`.
    """

@pulumi.input_type
class PrivateLinkAccessNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Network that the Private Link Access belongs to, for example, `n-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Network that the Private Link Access belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class PrivateLinkAttachmentAwArgsDict(TypedDict):
    vpc_endpoint_service_name: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) AWS VPC Endpoint Service that can be used to establish connections for all zones, for example `com.amazonaws.vpce.us-west-2.vpce-svc-0d3be37e21708ecd3`.
    """

@pulumi.input_type
class PrivateLinkAttachmentAwArgs:
    def __init__(__self__, *,
                 vpc_endpoint_service_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] vpc_endpoint_service_name: (Required String) AWS VPC Endpoint Service that can be used to establish connections for all zones, for example `com.amazonaws.vpce.us-west-2.vpce-svc-0d3be37e21708ecd3`.
        """
        if vpc_endpoint_service_name is not None:
            pulumi.set(__self__, "vpc_endpoint_service_name", vpc_endpoint_service_name)

    @_builtins.property
    @pulumi.getter(name="vpcEndpointServiceName")
    def vpc_endpoint_service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) AWS VPC Endpoint Service that can be used to establish connections for all zones, for example `com.amazonaws.vpce.us-west-2.vpce-svc-0d3be37e21708ecd3`.
        """
        return pulumi.get(self, "vpc_endpoint_service_name")

    @vpc_endpoint_service_name.setter
    def vpc_endpoint_service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_endpoint_service_name", value)


class PrivateLinkAttachmentAzureArgsDict(TypedDict):
    private_link_service_alias: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) Azure Private Link service alias for the availability zone.
    """
    private_link_service_resource_id: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) Azure Private Link service resource ID for the availability zone.
    """

@pulumi.input_type
class PrivateLinkAttachmentAzureArgs:
    def __init__(__self__, *,
                 private_link_service_alias: Optional[pulumi.Input[_builtins.str]] = None,
                 private_link_service_resource_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private_link_service_alias: (Required String) Azure Private Link service alias for the availability zone.
        :param pulumi.Input[_builtins.str] private_link_service_resource_id: (Required String) Azure Private Link service resource ID for the availability zone.
        """
        if private_link_service_alias is not None:
            pulumi.set(__self__, "private_link_service_alias", private_link_service_alias)
        if private_link_service_resource_id is not None:
            pulumi.set(__self__, "private_link_service_resource_id", private_link_service_resource_id)

    @_builtins.property
    @pulumi.getter(name="privateLinkServiceAlias")
    def private_link_service_alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) Azure Private Link service alias for the availability zone.
        """
        return pulumi.get(self, "private_link_service_alias")

    @private_link_service_alias.setter
    def private_link_service_alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_link_service_alias", value)

    @_builtins.property
    @pulumi.getter(name="privateLinkServiceResourceId")
    def private_link_service_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) Azure Private Link service resource ID for the availability zone.
        """
        return pulumi.get(self, "private_link_service_resource_id")

    @private_link_service_resource_id.setter
    def private_link_service_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_link_service_resource_id", value)


class PrivateLinkAttachmentConnectionAwsArgsDict(TypedDict):
    vpc_endpoint_id: pulumi.Input[_builtins.str]
    """
    ID of a VPC Endpoint that is connected to the VPC Endpoint service.
    """

@pulumi.input_type
class PrivateLinkAttachmentConnectionAwsArgs:
    def __init__(__self__, *,
                 vpc_endpoint_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] vpc_endpoint_id: ID of a VPC Endpoint that is connected to the VPC Endpoint service.
        """
        pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)

    @_builtins.property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of a VPC Endpoint that is connected to the VPC Endpoint service.
        """
        return pulumi.get(self, "vpc_endpoint_id")

    @vpc_endpoint_id.setter
    def vpc_endpoint_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_endpoint_id", value)


class PrivateLinkAttachmentConnectionAzureArgsDict(TypedDict):
    private_endpoint_resource_id: pulumi.Input[_builtins.str]
    """
    Resource ID of the Private Endpoint that is connected to the Private Link service.
    """

@pulumi.input_type
class PrivateLinkAttachmentConnectionAzureArgs:
    def __init__(__self__, *,
                 private_endpoint_resource_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] private_endpoint_resource_id: Resource ID of the Private Endpoint that is connected to the Private Link service.
        """
        pulumi.set(__self__, "private_endpoint_resource_id", private_endpoint_resource_id)

    @_builtins.property
    @pulumi.getter(name="privateEndpointResourceId")
    def private_endpoint_resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        Resource ID of the Private Endpoint that is connected to the Private Link service.
        """
        return pulumi.get(self, "private_endpoint_resource_id")

    @private_endpoint_resource_id.setter
    def private_endpoint_resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_endpoint_resource_id", value)


class PrivateLinkAttachmentConnectionEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Private Link Attachment Connection belongs to, for example `env-xyz456`.
    """

@pulumi.input_type
class PrivateLinkAttachmentConnectionEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Private Link Attachment Connection belongs to, for example `env-xyz456`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Private Link Attachment Connection belongs to, for example `env-xyz456`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class PrivateLinkAttachmentConnectionGcpArgsDict(TypedDict):
    private_service_connect_connection_id: pulumi.Input[_builtins.str]
    """
    GCP Private Service Connect ID used to establish connections for all zones.
    """

@pulumi.input_type
class PrivateLinkAttachmentConnectionGcpArgs:
    def __init__(__self__, *,
                 private_service_connect_connection_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] private_service_connect_connection_id: GCP Private Service Connect ID used to establish connections for all zones.
        """
        pulumi.set(__self__, "private_service_connect_connection_id", private_service_connect_connection_id)

    @_builtins.property
    @pulumi.getter(name="privateServiceConnectConnectionId")
    def private_service_connect_connection_id(self) -> pulumi.Input[_builtins.str]:
        """
        GCP Private Service Connect ID used to establish connections for all zones.
        """
        return pulumi.get(self, "private_service_connect_connection_id")

    @private_service_connect_connection_id.setter
    def private_service_connect_connection_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_service_connect_connection_id", value)


class PrivateLinkAttachmentConnectionPrivateLinkAttachmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The unique identifier for the private link attachment.
    """

@pulumi.input_type
class PrivateLinkAttachmentConnectionPrivateLinkAttachmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The unique identifier for the private link attachment.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The unique identifier for the private link attachment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class PrivateLinkAttachmentEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Private Link Attachment belongs to, for example `env-xyz456`.
    """

@pulumi.input_type
class PrivateLinkAttachmentEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Private Link Attachment belongs to, for example `env-xyz456`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Private Link Attachment belongs to, for example `env-xyz456`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class PrivateLinkAttachmentGcpArgsDict(TypedDict):
    private_service_connect_service_attachment: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The ID of the GCP Private Service Connect Service Attachment on Confluent Cloud.
    """

@pulumi.input_type
class PrivateLinkAttachmentGcpArgs:
    def __init__(__self__, *,
                 private_service_connect_service_attachment: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private_service_connect_service_attachment: (Required String) The ID of the GCP Private Service Connect Service Attachment on Confluent Cloud.
        """
        if private_service_connect_service_attachment is not None:
            pulumi.set(__self__, "private_service_connect_service_attachment", private_service_connect_service_attachment)

    @_builtins.property
    @pulumi.getter(name="privateServiceConnectServiceAttachment")
    def private_service_connect_service_attachment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The ID of the GCP Private Service Connect Service Attachment on Confluent Cloud.
        """
        return pulumi.get(self, "private_service_connect_service_attachment")

    @private_service_connect_service_attachment.setter
    def private_service_connect_service_attachment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_service_connect_service_attachment", value)


class ProviderIntegrationAuthorizationAzureArgsDict(TypedDict):
    customer_azure_tenant_id: pulumi.Input[_builtins.str]
    """
    Customer's Azure Tenant ID.
    """
    confluent_multi_tenant_app_id: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Computed String) Confluent Multi-Tenant App ID used to access customer Azure resources.
    """

@pulumi.input_type
class ProviderIntegrationAuthorizationAzureArgs:
    def __init__(__self__, *,
                 customer_azure_tenant_id: pulumi.Input[_builtins.str],
                 confluent_multi_tenant_app_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] customer_azure_tenant_id: Customer's Azure Tenant ID.
        :param pulumi.Input[_builtins.str] confluent_multi_tenant_app_id: (Computed String) Confluent Multi-Tenant App ID used to access customer Azure resources.
        """
        pulumi.set(__self__, "customer_azure_tenant_id", customer_azure_tenant_id)
        if confluent_multi_tenant_app_id is not None:
            pulumi.set(__self__, "confluent_multi_tenant_app_id", confluent_multi_tenant_app_id)

    @_builtins.property
    @pulumi.getter(name="customerAzureTenantId")
    def customer_azure_tenant_id(self) -> pulumi.Input[_builtins.str]:
        """
        Customer's Azure Tenant ID.
        """
        return pulumi.get(self, "customer_azure_tenant_id")

    @customer_azure_tenant_id.setter
    def customer_azure_tenant_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "customer_azure_tenant_id", value)

    @_builtins.property
    @pulumi.getter(name="confluentMultiTenantAppId")
    def confluent_multi_tenant_app_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Computed String) Confluent Multi-Tenant App ID used to access customer Azure resources.
        """
        return pulumi.get(self, "confluent_multi_tenant_app_id")

    @confluent_multi_tenant_app_id.setter
    def confluent_multi_tenant_app_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "confluent_multi_tenant_app_id", value)


class ProviderIntegrationAuthorizationEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class ProviderIntegrationAuthorizationEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class ProviderIntegrationAuthorizationGcpArgsDict(TypedDict):
    customer_google_service_account: pulumi.Input[_builtins.str]
    """
    Customer's Google Service Account that Confluent Cloud impersonates.

    > **Note:** Exactly one of `azure` or `gcp` configuration blocks must be provided, matching the cloud provider of the associated provider integration.
    """
    google_service_account: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Computed String) Google Service Account that Confluent Cloud uses for impersonation.
    """

@pulumi.input_type
class ProviderIntegrationAuthorizationGcpArgs:
    def __init__(__self__, *,
                 customer_google_service_account: pulumi.Input[_builtins.str],
                 google_service_account: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] customer_google_service_account: Customer's Google Service Account that Confluent Cloud impersonates.
               
               > **Note:** Exactly one of `azure` or `gcp` configuration blocks must be provided, matching the cloud provider of the associated provider integration.
        :param pulumi.Input[_builtins.str] google_service_account: (Computed String) Google Service Account that Confluent Cloud uses for impersonation.
        """
        pulumi.set(__self__, "customer_google_service_account", customer_google_service_account)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)

    @_builtins.property
    @pulumi.getter(name="customerGoogleServiceAccount")
    def customer_google_service_account(self) -> pulumi.Input[_builtins.str]:
        """
        Customer's Google Service Account that Confluent Cloud impersonates.

        > **Note:** Exactly one of `azure` or `gcp` configuration blocks must be provided, matching the cloud provider of the associated provider integration.
        """
        return pulumi.get(self, "customer_google_service_account")

    @customer_google_service_account.setter
    def customer_google_service_account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "customer_google_service_account", value)

    @_builtins.property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Computed String) Google Service Account that Confluent Cloud uses for impersonation.
        """
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "google_service_account", value)


class ProviderIntegrationAwsArgsDict(TypedDict):
    customer_role_arn: pulumi.Input[_builtins.str]
    """
    Amazon Resource Name (ARN) that identifies the AWS Identity and Access Management (IAM) role that Confluent Cloud assumes when it accesses resources in your AWS account.

    > **Note:** Currently only `aws` config is supported, more cloud service provider config will be supported in the short future.

    > **Note:** `customer_role_arn` must be unique in a given environment for creating a new Provider Integration.
    """
    external_id: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) Unique external ID that Confluent Cloud uses when it assumes the IAM role in your Amazon Web Services (AWS) account.
    """
    iam_role_arn: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The IAM role ARN used in Confluent Cloud internally, bundled with `customer_role_arn`.
    """

@pulumi.input_type
class ProviderIntegrationAwsArgs:
    def __init__(__self__, *,
                 customer_role_arn: pulumi.Input[_builtins.str],
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 iam_role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] customer_role_arn: Amazon Resource Name (ARN) that identifies the AWS Identity and Access Management (IAM) role that Confluent Cloud assumes when it accesses resources in your AWS account.
               
               > **Note:** Currently only `aws` config is supported, more cloud service provider config will be supported in the short future.
               
               > **Note:** `customer_role_arn` must be unique in a given environment for creating a new Provider Integration.
        :param pulumi.Input[_builtins.str] external_id: (Required String) Unique external ID that Confluent Cloud uses when it assumes the IAM role in your Amazon Web Services (AWS) account.
        :param pulumi.Input[_builtins.str] iam_role_arn: (Required String) The IAM role ARN used in Confluent Cloud internally, bundled with `customer_role_arn`.
        """
        pulumi.set(__self__, "customer_role_arn", customer_role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if iam_role_arn is not None:
            pulumi.set(__self__, "iam_role_arn", iam_role_arn)

    @_builtins.property
    @pulumi.getter(name="customerRoleArn")
    def customer_role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        Amazon Resource Name (ARN) that identifies the AWS Identity and Access Management (IAM) role that Confluent Cloud assumes when it accesses resources in your AWS account.

        > **Note:** Currently only `aws` config is supported, more cloud service provider config will be supported in the short future.

        > **Note:** `customer_role_arn` must be unique in a given environment for creating a new Provider Integration.
        """
        return pulumi.get(self, "customer_role_arn")

    @customer_role_arn.setter
    def customer_role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "customer_role_arn", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) Unique external ID that Confluent Cloud uses when it assumes the IAM role in your Amazon Web Services (AWS) account.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The IAM role ARN used in Confluent Cloud internally, bundled with `customer_role_arn`.
        """
        return pulumi.get(self, "iam_role_arn")

    @iam_role_arn.setter
    def iam_role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iam_role_arn", value)


class ProviderIntegrationEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class ProviderIntegrationEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class ProviderIntegrationSetupEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class ProviderIntegrationSetupEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class ProviderOauthArgsDict(TypedDict):
    oauth_identity_pool_id: pulumi.Input[_builtins.str]
    """
    OAuth identity pool id used for processing external token and exchange STS token, registered with Confluent Cloud.
    """
    oauth_external_access_token: NotRequired[pulumi.Input[_builtins.str]]
    """
    OAuth existing static access token already fetched from external Identity Provider.
    """
    oauth_external_client_id: NotRequired[pulumi.Input[_builtins.str]]
    """
    OAuth token application client id from external Identity Provider.
    """
    oauth_external_client_secret: NotRequired[pulumi.Input[_builtins.str]]
    """
    OAuth token application client secret from external Identity Provider.
    """
    oauth_external_token_scope: NotRequired[pulumi.Input[_builtins.str]]
    """
    OAuth client application scope, this is a required field when using Microsoft Azure Entra ID as the identity provider.
    """
    oauth_external_token_url: NotRequired[pulumi.Input[_builtins.str]]
    """
    OAuth token URL to fetch access token from external Identity Provider.
    """
    oauth_sts_token_expired_in_seconds: NotRequired[pulumi.Input[_builtins.str]]
    """
    OAuth STS access token expired in second from Confluent Cloud
    """

@pulumi.input_type
class ProviderOauthArgs:
    def __init__(__self__, *,
                 oauth_identity_pool_id: pulumi.Input[_builtins.str],
                 oauth_external_access_token: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_external_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_external_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_external_token_scope: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_external_token_url: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_sts_token_expired_in_seconds: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] oauth_identity_pool_id: OAuth identity pool id used for processing external token and exchange STS token, registered with Confluent Cloud.
        :param pulumi.Input[_builtins.str] oauth_external_access_token: OAuth existing static access token already fetched from external Identity Provider.
        :param pulumi.Input[_builtins.str] oauth_external_client_id: OAuth token application client id from external Identity Provider.
        :param pulumi.Input[_builtins.str] oauth_external_client_secret: OAuth token application client secret from external Identity Provider.
        :param pulumi.Input[_builtins.str] oauth_external_token_scope: OAuth client application scope, this is a required field when using Microsoft Azure Entra ID as the identity provider.
        :param pulumi.Input[_builtins.str] oauth_external_token_url: OAuth token URL to fetch access token from external Identity Provider.
        :param pulumi.Input[_builtins.str] oauth_sts_token_expired_in_seconds: OAuth STS access token expired in second from Confluent Cloud
        """
        pulumi.set(__self__, "oauth_identity_pool_id", oauth_identity_pool_id)
        if oauth_external_access_token is not None:
            pulumi.set(__self__, "oauth_external_access_token", oauth_external_access_token)
        if oauth_external_client_id is not None:
            pulumi.set(__self__, "oauth_external_client_id", oauth_external_client_id)
        if oauth_external_client_secret is not None:
            pulumi.set(__self__, "oauth_external_client_secret", oauth_external_client_secret)
        if oauth_external_token_scope is not None:
            pulumi.set(__self__, "oauth_external_token_scope", oauth_external_token_scope)
        if oauth_external_token_url is not None:
            pulumi.set(__self__, "oauth_external_token_url", oauth_external_token_url)
        if oauth_sts_token_expired_in_seconds is not None:
            pulumi.set(__self__, "oauth_sts_token_expired_in_seconds", oauth_sts_token_expired_in_seconds)

    @_builtins.property
    @pulumi.getter(name="oauthIdentityPoolId")
    def oauth_identity_pool_id(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth identity pool id used for processing external token and exchange STS token, registered with Confluent Cloud.
        """
        return pulumi.get(self, "oauth_identity_pool_id")

    @oauth_identity_pool_id.setter
    def oauth_identity_pool_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oauth_identity_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="oauthExternalAccessToken")
    def oauth_external_access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OAuth existing static access token already fetched from external Identity Provider.
        """
        return pulumi.get(self, "oauth_external_access_token")

    @oauth_external_access_token.setter
    def oauth_external_access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oauth_external_access_token", value)

    @_builtins.property
    @pulumi.getter(name="oauthExternalClientId")
    def oauth_external_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OAuth token application client id from external Identity Provider.
        """
        return pulumi.get(self, "oauth_external_client_id")

    @oauth_external_client_id.setter
    def oauth_external_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oauth_external_client_id", value)

    @_builtins.property
    @pulumi.getter(name="oauthExternalClientSecret")
    def oauth_external_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OAuth token application client secret from external Identity Provider.
        """
        return pulumi.get(self, "oauth_external_client_secret")

    @oauth_external_client_secret.setter
    def oauth_external_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oauth_external_client_secret", value)

    @_builtins.property
    @pulumi.getter(name="oauthExternalTokenScope")
    def oauth_external_token_scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OAuth client application scope, this is a required field when using Microsoft Azure Entra ID as the identity provider.
        """
        return pulumi.get(self, "oauth_external_token_scope")

    @oauth_external_token_scope.setter
    def oauth_external_token_scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oauth_external_token_scope", value)

    @_builtins.property
    @pulumi.getter(name="oauthExternalTokenUrl")
    def oauth_external_token_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OAuth token URL to fetch access token from external Identity Provider.
        """
        return pulumi.get(self, "oauth_external_token_url")

    @oauth_external_token_url.setter
    def oauth_external_token_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oauth_external_token_url", value)

    @_builtins.property
    @pulumi.getter(name="oauthStsTokenExpiredInSeconds")
    def oauth_sts_token_expired_in_seconds(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OAuth STS access token expired in second from Confluent Cloud
        """
        return pulumi.get(self, "oauth_sts_token_expired_in_seconds")

    @oauth_sts_token_expired_in_seconds.setter
    def oauth_sts_token_expired_in_seconds(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oauth_sts_token_expired_in_seconds", value)


class SchemaCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.

    > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Kafka clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Kafka cluster.

    > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Kafka API key, update the `credentials` block in all configuration files to use the new Kafka API key, run `pulumi up -target="confluent_schema.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_schema.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.

    !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `Schema` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
    """

@pulumi.input_type
class SchemaCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
               
               > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Kafka clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Kafka cluster.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Kafka API key, update the `credentials` block in all configuration files to use the new Kafka API key, run `pulumi up -target="confluent_schema.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_schema.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.
               
               !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `Schema` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.

        > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Kafka clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Kafka cluster.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Kafka API key, update the `credentials` block in all configuration files to use the new Kafka API key, run `pulumi up -target="confluent_schema.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_schema.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.

        !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `Schema` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class SchemaExporterCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class SchemaExporterCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class SchemaExporterDestinationSchemaRegistryClusterArgsDict(TypedDict):
    rest_endpoint: pulumi.Input[_builtins.str]
    """
    The REST endpoint of the destination Schema Registry cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
    """
    credentials: NotRequired[pulumi.Input['SchemaExporterDestinationSchemaRegistryClusterCredentialsArgsDict']]
    id: NotRequired[pulumi.Input[_builtins.str]]
    """
    The ID of the destination Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class SchemaExporterDestinationSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 rest_endpoint: pulumi.Input[_builtins.str],
                 credentials: Optional[pulumi.Input['SchemaExporterDestinationSchemaRegistryClusterCredentialsArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] rest_endpoint: The REST endpoint of the destination Schema Registry cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        :param pulumi.Input[_builtins.str] id: The ID of the destination Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "rest_endpoint", rest_endpoint)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="restEndpoint")
    def rest_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The REST endpoint of the destination Schema Registry cluster, for example, `https://pkc-00000.us-central1.gcp.confluent.cloud:443`).
        """
        return pulumi.get(self, "rest_endpoint")

    @rest_endpoint.setter
    def rest_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rest_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SchemaExporterDestinationSchemaRegistryClusterCredentialsArgs']]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SchemaExporterDestinationSchemaRegistryClusterCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the destination Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


class SchemaExporterDestinationSchemaRegistryClusterCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class SchemaExporterDestinationSchemaRegistryClusterCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class SchemaExporterSchemaRegistryClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class SchemaExporterSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class SchemaMetadataArgsDict(TypedDict):
    properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
    """
    The custom properties to set:
    """
    sensitives: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
    """
    A list of metadata properties to be encrypted.
    """
    tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['SchemaMetadataTagArgsDict']]]]

@pulumi.input_type
class SchemaMetadataArgs:
    def __init__(__self__, *,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 sensitives: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['SchemaMetadataTagArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] properties: The custom properties to set:
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] sensitives: A list of metadata properties to be encrypted.
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if sensitives is not None:
            pulumi.set(__self__, "sensitives", sensitives)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The custom properties to set:
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def sensitives(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of metadata properties to be encrypted.
        """
        return pulumi.get(self, "sensitives")

    @sensitives.setter
    def sensitives(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "sensitives", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SchemaMetadataTagArgs']]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SchemaMetadataTagArgs']]]]):
        pulumi.set(self, "tags", value)


class SchemaMetadataTagArgsDict(TypedDict):
    key: NotRequired[pulumi.Input[_builtins.str]]
    values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]

@pulumi.input_type
class SchemaMetadataTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


class SchemaRegistryClusterConfigCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.

    > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.

    > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_schema_registry_cluster_config.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_schema_registry_cluster_config.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.

    !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `SchemaRegistryClusterConfig` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.

    > **Note:** To configure a config at the context level, affecting all subjects created within that context, use `SubjectConfig` resource and pass in the context name as the `subject_name`. See the SubjectConfig` resource documentation for more details.
    """

@pulumi.input_type
class SchemaRegistryClusterConfigCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
               
               > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_schema_registry_cluster_config.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_schema_registry_cluster_config.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.
               
               !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `SchemaRegistryClusterConfig` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
               
               > **Note:** To configure a config at the context level, affecting all subjects created within that context, use `SubjectConfig` resource and pass in the context name as the `subject_name`. See the SubjectConfig` resource documentation for more details.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.

        > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_schema_registry_cluster_config.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_schema_registry_cluster_config.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.

        !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `SchemaRegistryClusterConfig` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.

        > **Note:** To configure a config at the context level, affecting all subjects created within that context, use `SubjectConfig` resource and pass in the context name as the `subject_name`. See the SubjectConfig` resource documentation for more details.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class SchemaRegistryClusterConfigSchemaRegistryClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class SchemaRegistryClusterConfigSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class SchemaRegistryClusterModeCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.

    > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.

    > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_schema_registry_cluster_mode.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_schema_registry_cluster_mode.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.

    !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `confluent_kafka_cluster_mode` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
    """

@pulumi.input_type
class SchemaRegistryClusterModeCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
               
               > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_schema_registry_cluster_mode.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_schema_registry_cluster_mode.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.
               
               !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `confluent_kafka_cluster_mode` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.

        > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_schema_registry_cluster_mode.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_schema_registry_cluster_mode.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.

        !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `confluent_kafka_cluster_mode` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class SchemaRegistryClusterModeSchemaRegistryClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class SchemaRegistryClusterModeSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class SchemaRegistryDekCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class SchemaRegistryDekCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class SchemaRegistryDekSchemaRegistryClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class SchemaRegistryDekSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class SchemaRegistryKekCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class SchemaRegistryKekCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class SchemaRegistryKekSchemaRegistryClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class SchemaRegistryKekSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class SchemaRulesetArgsDict(TypedDict):
    domain_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['SchemaRulesetDomainRuleArgsDict']]]]
    """
    supports the following:
    """
    migration_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['SchemaRulesetMigrationRuleArgsDict']]]]
    """
    supports the following:
    """

@pulumi.input_type
class SchemaRulesetArgs:
    def __init__(__self__, *,
                 domain_rules: Optional[pulumi.Input[Sequence[pulumi.Input['SchemaRulesetDomainRuleArgs']]]] = None,
                 migration_rules: Optional[pulumi.Input[Sequence[pulumi.Input['SchemaRulesetMigrationRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SchemaRulesetDomainRuleArgs']]] domain_rules: supports the following:
        :param pulumi.Input[Sequence[pulumi.Input['SchemaRulesetMigrationRuleArgs']]] migration_rules: supports the following:
        """
        if domain_rules is not None:
            pulumi.set(__self__, "domain_rules", domain_rules)
        if migration_rules is not None:
            pulumi.set(__self__, "migration_rules", migration_rules)

    @_builtins.property
    @pulumi.getter(name="domainRules")
    def domain_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SchemaRulesetDomainRuleArgs']]]]:
        """
        supports the following:
        """
        return pulumi.get(self, "domain_rules")

    @domain_rules.setter
    def domain_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SchemaRulesetDomainRuleArgs']]]]):
        pulumi.set(self, "domain_rules", value)

    @_builtins.property
    @pulumi.getter(name="migrationRules")
    def migration_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SchemaRulesetMigrationRuleArgs']]]]:
        """
        supports the following:
        """
        return pulumi.get(self, "migration_rules")

    @migration_rules.setter
    def migration_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SchemaRulesetMigrationRuleArgs']]]]):
        pulumi.set(self, "migration_rules", value)


class SchemaRulesetDomainRuleArgsDict(TypedDict):
    kind: pulumi.Input[_builtins.str]
    mode: pulumi.Input[_builtins.str]
    name: pulumi.Input[_builtins.str]
    type: pulumi.Input[_builtins.str]
    disabled: NotRequired[pulumi.Input[_builtins.bool]]
    doc: NotRequired[pulumi.Input[_builtins.str]]
    expr: NotRequired[pulumi.Input[_builtins.str]]
    on_failure: NotRequired[pulumi.Input[_builtins.str]]
    on_success: NotRequired[pulumi.Input[_builtins.str]]
    params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
    tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]

@pulumi.input_type
class SchemaRulesetDomainRuleArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 mode: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 doc: Optional[pulumi.Input[_builtins.str]] = None,
                 expr: Optional[pulumi.Input[_builtins.str]] = None,
                 on_failure: Optional[pulumi.Input[_builtins.str]] = None,
                 on_success: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if doc is not None:
            pulumi.set(__self__, "doc", doc)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def doc(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "doc")

    @doc.setter
    def doc(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "doc", value)

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "expr")

    @expr.setter
    def expr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expr", value)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "on_failure", value)

    @_builtins.property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "on_success", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


class SchemaRulesetMigrationRuleArgsDict(TypedDict):
    kind: pulumi.Input[_builtins.str]
    mode: pulumi.Input[_builtins.str]
    name: pulumi.Input[_builtins.str]
    type: pulumi.Input[_builtins.str]
    disabled: NotRequired[pulumi.Input[_builtins.bool]]
    doc: NotRequired[pulumi.Input[_builtins.str]]
    expr: NotRequired[pulumi.Input[_builtins.str]]
    on_failure: NotRequired[pulumi.Input[_builtins.str]]
    on_success: NotRequired[pulumi.Input[_builtins.str]]
    params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
    tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]

@pulumi.input_type
class SchemaRulesetMigrationRuleArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 mode: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 doc: Optional[pulumi.Input[_builtins.str]] = None,
                 expr: Optional[pulumi.Input[_builtins.str]] = None,
                 on_failure: Optional[pulumi.Input[_builtins.str]] = None,
                 on_success: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if doc is not None:
            pulumi.set(__self__, "doc", doc)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def doc(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "doc")

    @doc.setter
    def doc(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "doc", value)

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "expr")

    @expr.setter
    def expr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expr", value)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "on_failure", value)

    @_builtins.property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "on_success", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


class SchemaSchemaReferenceArgsDict(TypedDict):
    name: pulumi.Input[_builtins.str]
    """
    The name of the Schema references (for example, "io.confluent.kafka.example.User"). For Avro, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf, it is the name of another Protobuf file.
    """
    subject_name: pulumi.Input[_builtins.str]
    """
    The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`. Schemas evolve safely, following a compatibility mode defined, under a subject name.
    """
    version: pulumi.Input[_builtins.int]
    """
    (Required Integer) The version of the Schema, for example, `4`.
    """

@pulumi.input_type
class SchemaSchemaReferenceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 subject_name: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the Schema references (for example, "io.confluent.kafka.example.User"). For Avro, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf, it is the name of another Protobuf file.
        :param pulumi.Input[_builtins.str] subject_name: The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`. Schemas evolve safely, following a compatibility mode defined, under a subject name.
        :param pulumi.Input[_builtins.int] version: (Required Integer) The version of the Schema, for example, `4`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject_name", subject_name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Schema references (for example, "io.confluent.kafka.example.User"). For Avro, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf, it is the name of another Protobuf file.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`. Schemas evolve safely, following a compatibility mode defined, under a subject name.
        """
        return pulumi.get(self, "subject_name")

    @subject_name.setter
    def subject_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subject_name", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.int]:
        """
        (Required Integer) The version of the Schema, for example, `4`.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "version", value)


class SchemaSchemaRegistryClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class SchemaSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class SubjectConfigCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.

    > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.

    > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_subject_config.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_subject_config.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.

    !> **Warning:** Terraform doesn't encrypt the sensitive `credentials` value of the `SubjectConfig` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
    """

@pulumi.input_type
class SubjectConfigCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
               
               > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_subject_config.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_subject_config.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.
               
               !> **Warning:** Terraform doesn't encrypt the sensitive `credentials` value of the `SubjectConfig` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.

        > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_subject_config.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_subject_config.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.

        !> **Warning:** Terraform doesn't encrypt the sensitive `credentials` value of the `SubjectConfig` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class SubjectConfigSchemaRegistryClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class SubjectConfigSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class SubjectModeCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.

    > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.

    > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_subject_mode.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_subject_mode.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.

    !> **Warning:** Terraform doesn't encrypt the sensitive `credentials` value of the `SubjectMode` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
    """

@pulumi.input_type
class SubjectModeCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
               
               > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_subject_mode.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_subject_mode.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.
               
               !> **Warning:** Terraform doesn't encrypt the sensitive `credentials` value of the `SubjectMode` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.

        > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target="confluent_subject_mode.orders"`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_subject_mode.orders" -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.

        !> **Warning:** Terraform doesn't encrypt the sensitive `credentials` value of the `SubjectMode` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class SubjectModeSchemaRegistryClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class SubjectModeSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class TableflowTopicAzureDataLakeStorageGen2ArgsDict(TypedDict):
    container_name: pulumi.Input[_builtins.str]
    """
    The container name.
    """
    provider_integration_id: pulumi.Input[_builtins.str]
    """
    The provider integration id.
    """
    storage_account_name: pulumi.Input[_builtins.str]
    """
    The storage account name.
    """
    storage_region: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The storage region.
    """

@pulumi.input_type
class TableflowTopicAzureDataLakeStorageGen2Args:
    def __init__(__self__, *,
                 container_name: pulumi.Input[_builtins.str],
                 provider_integration_id: pulumi.Input[_builtins.str],
                 storage_account_name: pulumi.Input[_builtins.str],
                 storage_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] container_name: The container name.
        :param pulumi.Input[_builtins.str] provider_integration_id: The provider integration id.
        :param pulumi.Input[_builtins.str] storage_account_name: The storage account name.
        :param pulumi.Input[_builtins.str] storage_region: (Required String) The storage region.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "provider_integration_id", provider_integration_id)
        pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_region is not None:
            pulumi.set(__self__, "storage_region", storage_region)

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> pulumi.Input[_builtins.str]:
        """
        The container name.
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container_name", value)

    @_builtins.property
    @pulumi.getter(name="providerIntegrationId")
    def provider_integration_id(self) -> pulumi.Input[_builtins.str]:
        """
        The provider integration id.
        """
        return pulumi.get(self, "provider_integration_id")

    @provider_integration_id.setter
    def provider_integration_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider_integration_id", value)

    @_builtins.property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> pulumi.Input[_builtins.str]:
        """
        The storage account name.
        """
        return pulumi.get(self, "storage_account_name")

    @storage_account_name.setter
    def storage_account_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_account_name", value)

    @_builtins.property
    @pulumi.getter(name="storageRegion")
    def storage_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The storage region.
        """
        return pulumi.get(self, "storage_region")

    @storage_region.setter
    def storage_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_region", value)


class TableflowTopicByobAwsArgsDict(TypedDict):
    bucket_name: pulumi.Input[_builtins.str]
    """
    The bucket name.
    """
    provider_integration_id: pulumi.Input[_builtins.str]
    """
    The provider integration id.
    """
    bucket_region: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The bucket region.
    """

@pulumi.input_type
class TableflowTopicByobAwsArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 provider_integration_id: pulumi.Input[_builtins.str],
                 bucket_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: The bucket name.
        :param pulumi.Input[_builtins.str] provider_integration_id: The provider integration id.
        :param pulumi.Input[_builtins.str] bucket_region: (Required String) The bucket region.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "provider_integration_id", provider_integration_id)
        if bucket_region is not None:
            pulumi.set(__self__, "bucket_region", bucket_region)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="providerIntegrationId")
    def provider_integration_id(self) -> pulumi.Input[_builtins.str]:
        """
        The provider integration id.
        """
        return pulumi.get(self, "provider_integration_id")

    @provider_integration_id.setter
    def provider_integration_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider_integration_id", value)

    @_builtins.property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The bucket region.
        """
        return pulumi.get(self, "bucket_region")

    @bucket_region.setter
    def bucket_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_region", value)


class TableflowTopicCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Tableflow API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Tableflow API Secret.

    > **Note:** A Tableflow API key consists of a key and a secret. Tableflow API keys are required to interact with Tableflow Topics in Confluent Cloud.

    > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Tableflow API key, create a new Tableflow API key, update the `credentials` block in all configuration files to use the new Tableflow API key, run `pulumi up -target="confluent_tableflow_topic.example"`, and remove the old Tableflow API key. Alternatively, in case the old Tableflow API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_tableflow_topic.example" -out=rotate-tableflow-api-key` and `pulumi up rotate-tableflow-api-key` instead.

    !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `TableflowTopic` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
    """

@pulumi.input_type
class TableflowTopicCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Tableflow API Key.
        :param pulumi.Input[_builtins.str] secret: The Tableflow API Secret.
               
               > **Note:** A Tableflow API key consists of a key and a secret. Tableflow API keys are required to interact with Tableflow Topics in Confluent Cloud.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Tableflow API key, create a new Tableflow API key, update the `credentials` block in all configuration files to use the new Tableflow API key, run `pulumi up -target="confluent_tableflow_topic.example"`, and remove the old Tableflow API key. Alternatively, in case the old Tableflow API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_tableflow_topic.example" -out=rotate-tableflow-api-key` and `pulumi up rotate-tableflow-api-key` instead.
               
               !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `TableflowTopic` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Tableflow API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Tableflow API Secret.

        > **Note:** A Tableflow API key consists of a key and a secret. Tableflow API keys are required to interact with Tableflow Topics in Confluent Cloud.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Tableflow API key, create a new Tableflow API key, update the `credentials` block in all configuration files to use the new Tableflow API key, run `pulumi up -target="confluent_tableflow_topic.example"`, and remove the old Tableflow API key. Alternatively, in case the old Tableflow API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_tableflow_topic.example" -out=rotate-tableflow-api-key` and `pulumi up rotate-tableflow-api-key` instead.

        !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `TableflowTopic` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class TableflowTopicEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment, for example, `env-abc123`.
    """

@pulumi.input_type
class TableflowTopicEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class TableflowTopicErrorHandlingArgsDict(TypedDict):
    log_target: NotRequired[pulumi.Input[_builtins.str]]
    """
    The topic to which the bad records will be logged for error handling mode `LOG`. Creates the topic if it doesn't already exist. The default topic is "error_log" if error handling mode is `LOG`, and empty otherwise.
    """
    mode: NotRequired[pulumi.Input[_builtins.str]]
    """
    The error handling mode. For `SUSPEND`, the materialization of the topic is suspended in case of record failures. For `SKIP`, bad records are skipped and the materialization continues with the next record. For `LOG`, bad records are logged to a dead-letter queue (DLQ) topic and the materialization continues with the next record. The default mode is `SUSPEND`.
    """

@pulumi.input_type
class TableflowTopicErrorHandlingArgs:
    def __init__(__self__, *,
                 log_target: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] log_target: The topic to which the bad records will be logged for error handling mode `LOG`. Creates the topic if it doesn't already exist. The default topic is "error_log" if error handling mode is `LOG`, and empty otherwise.
        :param pulumi.Input[_builtins.str] mode: The error handling mode. For `SUSPEND`, the materialization of the topic is suspended in case of record failures. For `SKIP`, bad records are skipped and the materialization continues with the next record. For `LOG`, bad records are logged to a dead-letter queue (DLQ) topic and the materialization continues with the next record. The default mode is `SUSPEND`.
        """
        if log_target is not None:
            pulumi.set(__self__, "log_target", log_target)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="logTarget")
    def log_target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The topic to which the bad records will be logged for error handling mode `LOG`. Creates the topic if it doesn't already exist. The default topic is "error_log" if error handling mode is `LOG`, and empty otherwise.
        """
        return pulumi.get(self, "log_target")

    @log_target.setter
    def log_target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_target", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The error handling mode. For `SUSPEND`, the materialization of the topic is suspended in case of record failures. For `SKIP`, bad records are skipped and the materialization continues with the next record. For `LOG`, bad records are logged to a dead-letter queue (DLQ) topic and the materialization continues with the next record. The default mode is `SUSPEND`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


class TableflowTopicKafkaClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Kafka cluster, for example, `lkc-abc123`.
    """

@pulumi.input_type
class TableflowTopicKafkaClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class TableflowTopicManagedStorageArgsDict(TypedDict):
    pass

@pulumi.input_type
class TableflowTopicManagedStorageArgs:
    def __init__(__self__):
        pass


class TagBindingCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class TagBindingCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class TagBindingSchemaRegistryClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class TagBindingSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class TagCredentialsArgsDict(TypedDict):
    key: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Key.
    """
    secret: pulumi.Input[_builtins.str]
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class TagCredentialsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The Schema Registry API Key.
        :param pulumi.Input[_builtins.str] secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


class TagSchemaRegistryClusterArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class TagSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class TransitGatewayAttachmentAwsArgsDict(TypedDict):
    ram_resource_share_arn: pulumi.Input[_builtins.str]
    """
    The Amazon Resource Name (ARN) of the Resource Access Manager (RAM) Resource Share of the transit gateway your Confluent Cloud network attaches to.
    """
    routes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
    """
    List of destination routes for traffic from Confluent VPC to customer VPC via Transit Gateway.

    > **Note:** Learn more about Transit Gateway Attachment limitations on AWS [here](https://docs.confluent.io/cloud/current/networking/aws-transit-gateway.html#limitations).
    """
    transit_gateway_id: pulumi.Input[_builtins.str]
    """
    The ID of the AWS Transit Gateway that you want Confluent CLoud to be attached to. Must start with `tgw-`.
    """
    transit_gateway_attachment_id: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Required String) The ID of the AWS Transit Gateway VPC Attachment that attaches Confluent VPC to Transit Gateway.
    """

@pulumi.input_type
class TransitGatewayAttachmentAwsArgs:
    def __init__(__self__, *,
                 ram_resource_share_arn: pulumi.Input[_builtins.str],
                 routes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 transit_gateway_id: pulumi.Input[_builtins.str],
                 transit_gateway_attachment_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ram_resource_share_arn: The Amazon Resource Name (ARN) of the Resource Access Manager (RAM) Resource Share of the transit gateway your Confluent Cloud network attaches to.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] routes: List of destination routes for traffic from Confluent VPC to customer VPC via Transit Gateway.
               
               > **Note:** Learn more about Transit Gateway Attachment limitations on AWS [here](https://docs.confluent.io/cloud/current/networking/aws-transit-gateway.html#limitations).
        :param pulumi.Input[_builtins.str] transit_gateway_id: The ID of the AWS Transit Gateway that you want Confluent CLoud to be attached to. Must start with `tgw-`.
        :param pulumi.Input[_builtins.str] transit_gateway_attachment_id: (Required String) The ID of the AWS Transit Gateway VPC Attachment that attaches Confluent VPC to Transit Gateway.
        """
        pulumi.set(__self__, "ram_resource_share_arn", ram_resource_share_arn)
        pulumi.set(__self__, "routes", routes)
        pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if transit_gateway_attachment_id is not None:
            pulumi.set(__self__, "transit_gateway_attachment_id", transit_gateway_attachment_id)

    @_builtins.property
    @pulumi.getter(name="ramResourceShareArn")
    def ram_resource_share_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the Resource Access Manager (RAM) Resource Share of the transit gateway your Confluent Cloud network attaches to.
        """
        return pulumi.get(self, "ram_resource_share_arn")

    @ram_resource_share_arn.setter
    def ram_resource_share_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ram_resource_share_arn", value)

    @_builtins.property
    @pulumi.getter
    def routes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of destination routes for traffic from Confluent VPC to customer VPC via Transit Gateway.

        > **Note:** Learn more about Transit Gateway Attachment limitations on AWS [here](https://docs.confluent.io/cloud/current/networking/aws-transit-gateway.html#limitations).
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "routes", value)

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the AWS Transit Gateway that you want Confluent CLoud to be attached to. Must start with `tgw-`.
        """
        return pulumi.get(self, "transit_gateway_id")

    @transit_gateway_id.setter
    def transit_gateway_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "transit_gateway_id", value)

    @_builtins.property
    @pulumi.getter(name="transitGatewayAttachmentId")
    def transit_gateway_attachment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required String) The ID of the AWS Transit Gateway VPC Attachment that attaches Confluent VPC to Transit Gateway.
        """
        return pulumi.get(self, "transit_gateway_attachment_id")

    @transit_gateway_attachment_id.setter
    def transit_gateway_attachment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transit_gateway_attachment_id", value)


class TransitGatewayAttachmentEnvironmentArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Environment that the Transit Gateway Attachment belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class TransitGatewayAttachmentEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Environment that the Transit Gateway Attachment belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Environment that the Transit Gateway Attachment belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class TransitGatewayAttachmentNetworkArgsDict(TypedDict):
    id: pulumi.Input[_builtins.str]
    """
    The ID of the Network that the Transit Gateway Attachment belongs to, for example, `n-abc123`.
    """

@pulumi.input_type
class TransitGatewayAttachmentNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Network that the Transit Gateway Attachment belongs to, for example, `n-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Network that the Transit Gateway Attachment belongs to, for example, `n-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


class GetAccessPointEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Access Point belongs to, for example, `env-123abc`.
    """

@pulumi.input_type
class GetAccessPointEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Access Point belongs to, for example, `env-123abc`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Access Point belongs to, for example, `env-123abc`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetAccessPointGcpEgressPrivateServiceConnectEndpointArgsDict(TypedDict):
    private_service_connect_endpoint_connection_id: _builtins.str
    """
    (Required String) Connection ID of the Private Service Connect Endpoint that is connected to the endpoint target.
    """
    private_service_connect_endpoint_ip_address: _builtins.str
    """
    (Required String) IP address of the Private Service Connect Endpoint that is connected to the endpoint target.
    """
    private_service_connect_endpoint_name: _builtins.str
    """
    (Required String) Name of the Private Service Connect Endpoint that is connected to the endpoint target.
    """
    private_service_connect_endpoint_target: _builtins.str
    """
    (Required String) URI of the service attachment for the published service that the Private Service Connect Endpoint connects to, or "all-google-apis" for global Google APIs.
    """

@pulumi.input_type
class GetAccessPointGcpEgressPrivateServiceConnectEndpointArgs:
    def __init__(__self__, *,
                 private_service_connect_endpoint_connection_id: _builtins.str,
                 private_service_connect_endpoint_ip_address: _builtins.str,
                 private_service_connect_endpoint_name: _builtins.str,
                 private_service_connect_endpoint_target: _builtins.str):
        """
        :param _builtins.str private_service_connect_endpoint_connection_id: (Required String) Connection ID of the Private Service Connect Endpoint that is connected to the endpoint target.
        :param _builtins.str private_service_connect_endpoint_ip_address: (Required String) IP address of the Private Service Connect Endpoint that is connected to the endpoint target.
        :param _builtins.str private_service_connect_endpoint_name: (Required String) Name of the Private Service Connect Endpoint that is connected to the endpoint target.
        :param _builtins.str private_service_connect_endpoint_target: (Required String) URI of the service attachment for the published service that the Private Service Connect Endpoint connects to, or "all-google-apis" for global Google APIs.
        """
        pulumi.set(__self__, "private_service_connect_endpoint_connection_id", private_service_connect_endpoint_connection_id)
        pulumi.set(__self__, "private_service_connect_endpoint_ip_address", private_service_connect_endpoint_ip_address)
        pulumi.set(__self__, "private_service_connect_endpoint_name", private_service_connect_endpoint_name)
        pulumi.set(__self__, "private_service_connect_endpoint_target", private_service_connect_endpoint_target)

    @_builtins.property
    @pulumi.getter(name="privateServiceConnectEndpointConnectionId")
    def private_service_connect_endpoint_connection_id(self) -> _builtins.str:
        """
        (Required String) Connection ID of the Private Service Connect Endpoint that is connected to the endpoint target.
        """
        return pulumi.get(self, "private_service_connect_endpoint_connection_id")

    @private_service_connect_endpoint_connection_id.setter
    def private_service_connect_endpoint_connection_id(self, value: _builtins.str):
        pulumi.set(self, "private_service_connect_endpoint_connection_id", value)

    @_builtins.property
    @pulumi.getter(name="privateServiceConnectEndpointIpAddress")
    def private_service_connect_endpoint_ip_address(self) -> _builtins.str:
        """
        (Required String) IP address of the Private Service Connect Endpoint that is connected to the endpoint target.
        """
        return pulumi.get(self, "private_service_connect_endpoint_ip_address")

    @private_service_connect_endpoint_ip_address.setter
    def private_service_connect_endpoint_ip_address(self, value: _builtins.str):
        pulumi.set(self, "private_service_connect_endpoint_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="privateServiceConnectEndpointName")
    def private_service_connect_endpoint_name(self) -> _builtins.str:
        """
        (Required String) Name of the Private Service Connect Endpoint that is connected to the endpoint target.
        """
        return pulumi.get(self, "private_service_connect_endpoint_name")

    @private_service_connect_endpoint_name.setter
    def private_service_connect_endpoint_name(self, value: _builtins.str):
        pulumi.set(self, "private_service_connect_endpoint_name", value)

    @_builtins.property
    @pulumi.getter(name="privateServiceConnectEndpointTarget")
    def private_service_connect_endpoint_target(self) -> _builtins.str:
        """
        (Required String) URI of the service attachment for the published service that the Private Service Connect Endpoint connects to, or "all-google-apis" for global Google APIs.
        """
        return pulumi.get(self, "private_service_connect_endpoint_target")

    @private_service_connect_endpoint_target.setter
    def private_service_connect_endpoint_target(self, value: _builtins.str):
        pulumi.set(self, "private_service_connect_endpoint_target", value)


class GetBusinessMetadataBindingCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Schema Registry API Key.
    """
    secret: _builtins.str
    """
    The Schema Registry API Secret.

    > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
    """

@pulumi.input_type
class GetBusinessMetadataBindingCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Schema Registry API Key.
        :param _builtins.str secret: The Schema Registry API Secret.
               
               > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Schema Registry API Secret.

        > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetBusinessMetadataBindingSchemaRegistryClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class GetBusinessMetadataBindingSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetBusinessMetadataCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Schema Registry API Key.
    """
    secret: _builtins.str
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class GetBusinessMetadataCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Schema Registry API Key.
        :param _builtins.str secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetBusinessMetadataSchemaRegistryClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class GetBusinessMetadataSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetCatalogIntegrationCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Tableflow API Key.
    """
    secret: _builtins.str
    """
    The Tableflow API Secret.

    > **Note:** A Tableflow API key consists of a key and a secret. Tableflow API keys are required to interact with Catalog Integrations in Confluent Cloud.

    !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `CatalogIntegration` data source, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
    """

@pulumi.input_type
class GetCatalogIntegrationCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Tableflow API Key.
        :param _builtins.str secret: The Tableflow API Secret.
               
               > **Note:** A Tableflow API key consists of a key and a secret. Tableflow API keys are required to interact with Catalog Integrations in Confluent Cloud.
               
               !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `CatalogIntegration` data source, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Tableflow API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Tableflow API Secret.

        > **Note:** A Tableflow API key consists of a key and a secret. Tableflow API keys are required to interact with Catalog Integrations in Confluent Cloud.

        !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `CatalogIntegration` data source, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetCatalogIntegrationEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment, for example, `env-abc123`.
    """

@pulumi.input_type
class GetCatalogIntegrationEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetCatalogIntegrationKafkaClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Kafka cluster, for example, `lkc-abc123`.
    """

@pulumi.input_type
class GetCatalogIntegrationKafkaClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetCertificatePoolCertificateAuthorityArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Certificate Authority for this Certificate Pool, for example, `op-123abc`.
    """

@pulumi.input_type
class GetCertificatePoolCertificateAuthorityArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Certificate Authority for this Certificate Pool, for example, `op-123abc`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Certificate Authority for this Certificate Pool, for example, `op-123abc`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetClusterLinkCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Kafka API Key.
    """
    secret: _builtins.str
    """
    The Kafka API Secret.

    > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.

    !> **Warning:** Terraform doesn't encrypt the sensitive `credentials` value of the `ClusterLink` data-source, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
    """

@pulumi.input_type
class GetClusterLinkCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Kafka API Key.
        :param _builtins.str secret: The Kafka API Secret.
               
               > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.
               
               !> **Warning:** Terraform doesn't encrypt the sensitive `credentials` value of the `ClusterLink` data-source, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Kafka API Secret.

        > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.

        !> **Warning:** Terraform doesn't encrypt the sensitive `credentials` value of the `ClusterLink` data-source, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetClusterLinkKafkaClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Kafka cluster to query for the Cluster Link, for example, `lkc-abc123`.
    """

@pulumi.input_type
class GetClusterLinkKafkaClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Kafka cluster to query for the Cluster Link, for example, `lkc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Kafka cluster to query for the Cluster Link, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetConnectArtifactEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Connect Artifact belongs to.
    """

@pulumi.input_type
class GetConnectArtifactEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Connect Artifact belongs to.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Connect Artifact belongs to.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetDnsRecordEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the DNS Record belongs to, for example, `env-123abc`.
    """

@pulumi.input_type
class GetDnsRecordEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the DNS Record belongs to, for example, `env-123abc`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the DNS Record belongs to, for example, `env-123abc`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetEndpointFilterArgsDict(TypedDict):
    environment: 'GetEndpointFilterEnvironmentArgsDict'
    """
    (Computed Configuration Block) supports the following:
    """
    service: _builtins.str
    """
    The Confluent Cloud service. Accepted values are: `KAFKA`, `SCHEMA_REGISTRY`, `FLINK`.
    """
    cloud: NotRequired[_builtins.str]
    """
    The cloud service provider. Accepted values are: `AWS`, `GCP`, `AZURE`.
    """
    is_private: NotRequired[_builtins.bool]
    """
    Whether the endpoint is private (true) or public (false).
    """
    region: NotRequired[_builtins.str]
    """
    The cloud service provider region in which the resource is located, for example, `us-west-2`.
    """
    resource: NotRequired[_builtins.str]
    """
    The resource associated with the endpoint. The resource can be one of Kafka Cluster ID (example: `lkc-12345`), or Schema Registry Cluster ID (example: `lsrc-12345`). May be omitted if not associated with a resource.
    """

@pulumi.input_type
class GetEndpointFilterArgs:
    def __init__(__self__, *,
                 environment: 'GetEndpointFilterEnvironmentArgs',
                 service: _builtins.str,
                 cloud: Optional[_builtins.str] = None,
                 is_private: Optional[_builtins.bool] = None,
                 region: Optional[_builtins.str] = None,
                 resource: Optional[_builtins.str] = None):
        """
        :param 'GetEndpointFilterEnvironmentArgs' environment: (Computed Configuration Block) supports the following:
        :param _builtins.str service: The Confluent Cloud service. Accepted values are: `KAFKA`, `SCHEMA_REGISTRY`, `FLINK`.
        :param _builtins.str cloud: The cloud service provider. Accepted values are: `AWS`, `GCP`, `AZURE`.
        :param _builtins.bool is_private: Whether the endpoint is private (true) or public (false).
        :param _builtins.str region: The cloud service provider region in which the resource is located, for example, `us-west-2`.
        :param _builtins.str resource: The resource associated with the endpoint. The resource can be one of Kafka Cluster ID (example: `lkc-12345`), or Schema Registry Cluster ID (example: `lsrc-12345`). May be omitted if not associated with a resource.
        """
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "service", service)
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if is_private is not None:
            pulumi.set(__self__, "is_private", is_private)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> 'GetEndpointFilterEnvironmentArgs':
        """
        (Computed Configuration Block) supports the following:
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: 'GetEndpointFilterEnvironmentArgs'):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        The Confluent Cloud service. Accepted values are: `KAFKA`, `SCHEMA_REGISTRY`, `FLINK`.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: _builtins.str):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> Optional[_builtins.str]:
        """
        The cloud service provider. Accepted values are: `AWS`, `GCP`, `AZURE`.
        """
        return pulumi.get(self, "cloud")

    @cloud.setter
    def cloud(self, value: Optional[_builtins.str]):
        pulumi.set(self, "cloud", value)

    @_builtins.property
    @pulumi.getter(name="isPrivate")
    def is_private(self) -> Optional[_builtins.bool]:
        """
        Whether the endpoint is private (true) or public (false).
        """
        return pulumi.get(self, "is_private")

    @is_private.setter
    def is_private(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_private", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The cloud service provider region in which the resource is located, for example, `us-west-2`.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> Optional[_builtins.str]:
        """
        The resource associated with the endpoint. The resource can be one of Kafka Cluster ID (example: `lkc-12345`), or Schema Registry Cluster ID (example: `lsrc-12345`). May be omitted if not associated with a resource.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[_builtins.str]):
        pulumi.set(self, "resource", value)


class GetEndpointFilterEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Endpoint belongs to, for example, `env-123abc`.
    """

@pulumi.input_type
class GetEndpointFilterEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Endpoint belongs to, for example, `env-123abc`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Endpoint belongs to, for example, `env-123abc`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetEnvironmentStreamGovernanceArgsDict(TypedDict):
    package: _builtins.str
    """
    Stream Governance Package. 'ESSENTIALS' or 'ADVANCED'
    """

@pulumi.input_type
class GetEnvironmentStreamGovernanceArgs:
    def __init__(__self__, *,
                 package: _builtins.str):
        """
        :param _builtins.str package: Stream Governance Package. 'ESSENTIALS' or 'ADVANCED'
        """
        pulumi.set(__self__, "package", package)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        """
        Stream Governance Package. 'ESSENTIALS' or 'ADVANCED'
        """
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: _builtins.str):
        pulumi.set(self, "package", value)


class GetFlinkArtifactEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Flink Artifact belongs to, for example, `env-xyz456`.
    """

@pulumi.input_type
class GetFlinkArtifactEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Flink Artifact belongs to, for example, `env-xyz456`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Flink Artifact belongs to, for example, `env-xyz456`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetFlinkComputePoolEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Flink Compute Pool belongs to, for example, `env-xyz456`.

    > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
    """

@pulumi.input_type
class GetFlinkComputePoolEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Flink Compute Pool belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Flink Compute Pool belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetFlinkConnectionComputePoolArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Flink Compute Pool, for example, `lfcp-abc123`.
    """

@pulumi.input_type
class GetFlinkConnectionComputePoolArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Flink Compute Pool, for example, `lfcp-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Flink Compute Pool, for example, `lfcp-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetFlinkConnectionCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Flink API Key.
    """
    secret: _builtins.str
    """
    The Flink API Secret.

    > **Note:** A Flink API key consists of a key and a secret. Flink API keys are required to interact with Flink Connections in Confluent Cloud. Each Flink API key is valid for one specific Flink Region.

    > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Flink API key, create a new Flink API key, update the `credentials` block in all configuration files to use the new Flink API key, run `pulumi up -target="confluent_flink_connection.example"`, and remove the old Flink API key. Alternatively, in case the old Flink API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_flink_connection.example" -out=rotate-flink-api-key` and `pulumi up rotate-flink-api-key` instead.
    """

@pulumi.input_type
class GetFlinkConnectionCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Flink API Key.
        :param _builtins.str secret: The Flink API Secret.
               
               > **Note:** A Flink API key consists of a key and a secret. Flink API keys are required to interact with Flink Connections in Confluent Cloud. Each Flink API key is valid for one specific Flink Region.
               
               > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Flink API key, create a new Flink API key, update the `credentials` block in all configuration files to use the new Flink API key, run `pulumi up -target="confluent_flink_connection.example"`, and remove the old Flink API key. Alternatively, in case the old Flink API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_flink_connection.example" -out=rotate-flink-api-key` and `pulumi up rotate-flink-api-key` instead.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Flink API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Flink API Secret.

        > **Note:** A Flink API key consists of a key and a secret. Flink API keys are required to interact with Flink Connections in Confluent Cloud. Each Flink API key is valid for one specific Flink Region.

        > **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Flink API key, create a new Flink API key, update the `credentials` block in all configuration files to use the new Flink API key, run `pulumi up -target="confluent_flink_connection.example"`, and remove the old Flink API key. Alternatively, in case the old Flink API Key was deleted already, you might need to run `pulumi preview -refresh=false -target="confluent_flink_connection.example" -out=rotate-flink-api-key` and `pulumi up rotate-flink-api-key` instead.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetFlinkConnectionEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment, for example, `env-abc123`.
    """

@pulumi.input_type
class GetFlinkConnectionEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetFlinkConnectionOrganizationArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Organization, for example, `1111aaaa-11aa-11aa-11aa-111111aaaaaa`.
    """

@pulumi.input_type
class GetFlinkConnectionOrganizationArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Organization, for example, `1111aaaa-11aa-11aa-11aa-111111aaaaaa`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Organization, for example, `1111aaaa-11aa-11aa-11aa-111111aaaaaa`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetFlinkConnectionPrincipalArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Principal the Flink Connection runs as, for example, `sa-abc123`.
    """

@pulumi.input_type
class GetFlinkConnectionPrincipalArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Principal the Flink Connection runs as, for example, `sa-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Principal the Flink Connection runs as, for example, `sa-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetGatewayEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Gateway belongs to, for example, `env-123abc`.
    """

@pulumi.input_type
class GetGatewayEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Gateway belongs to, for example, `env-123abc`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Gateway belongs to, for example, `env-123abc`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetGatewaysEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Gateways belong to, for example, `env-123abc`.
    """

@pulumi.input_type
class GetGatewaysEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Gateways belong to, for example, `env-123abc`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Gateways belong to, for example, `env-123abc`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetGatewaysFilterArgsDict(TypedDict):
    display_names: NotRequired[Sequence[_builtins.str]]
    """
    Filter the results by exact match for spec.display_name. Pass multiple times to see results matching any of the values, for example, `["prod-gateway-ingress-use1", "prod-gateway-ingress-use2"]`.
    """
    gateway_types: NotRequired[Sequence[_builtins.str]]
    """
    Filter the results by exact match for gateway_type. Pass multiple times to see results matching any of the values. Valid values are: `AwsEgressPrivateLink`, `AwsIngressPrivateLink`, `AwsPeering`, `AwsPrivateNetworkInterface`, `AzureEgressPrivateLink`, `AzurePeering`, `GcpEgressPrivateServiceConnect`, `GcpPeering`.
    """
    ids: NotRequired[Sequence[_builtins.str]]
    """
    Filter the results by exact match for id. Pass multiple times to see results matching any of the values, for example, `["gw-abc123", "gw-def456"]`.
    """
    phases: NotRequired[Sequence[_builtins.str]]
    """
    Filter the results by exact match for status.phase. Pass multiple times to see results matching any of the values. Valid values are: `CREATED`, `PROVISIONING`, `READY`, `FAILED`, `DEPROVISIONING`, `EXPIRED`.
    """
    regions: NotRequired[Sequence[_builtins.str]]
    """
    Filter the results by exact match for spec.config.region. Pass multiple times to see results matching any of the values, for example, `["us-east-1", "us-west-2"]`.
    """

@pulumi.input_type
class GetGatewaysFilterArgs:
    def __init__(__self__, *,
                 display_names: Optional[Sequence[_builtins.str]] = None,
                 gateway_types: Optional[Sequence[_builtins.str]] = None,
                 ids: Optional[Sequence[_builtins.str]] = None,
                 phases: Optional[Sequence[_builtins.str]] = None,
                 regions: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] display_names: Filter the results by exact match for spec.display_name. Pass multiple times to see results matching any of the values, for example, `["prod-gateway-ingress-use1", "prod-gateway-ingress-use2"]`.
        :param Sequence[_builtins.str] gateway_types: Filter the results by exact match for gateway_type. Pass multiple times to see results matching any of the values. Valid values are: `AwsEgressPrivateLink`, `AwsIngressPrivateLink`, `AwsPeering`, `AwsPrivateNetworkInterface`, `AzureEgressPrivateLink`, `AzurePeering`, `GcpEgressPrivateServiceConnect`, `GcpPeering`.
        :param Sequence[_builtins.str] ids: Filter the results by exact match for id. Pass multiple times to see results matching any of the values, for example, `["gw-abc123", "gw-def456"]`.
        :param Sequence[_builtins.str] phases: Filter the results by exact match for status.phase. Pass multiple times to see results matching any of the values. Valid values are: `CREATED`, `PROVISIONING`, `READY`, `FAILED`, `DEPROVISIONING`, `EXPIRED`.
        :param Sequence[_builtins.str] regions: Filter the results by exact match for spec.config.region. Pass multiple times to see results matching any of the values, for example, `["us-east-1", "us-west-2"]`.
        """
        if display_names is not None:
            pulumi.set(__self__, "display_names", display_names)
        if gateway_types is not None:
            pulumi.set(__self__, "gateway_types", gateway_types)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if phases is not None:
            pulumi.set(__self__, "phases", phases)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)

    @_builtins.property
    @pulumi.getter(name="displayNames")
    def display_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Filter the results by exact match for spec.display_name. Pass multiple times to see results matching any of the values, for example, `["prod-gateway-ingress-use1", "prod-gateway-ingress-use2"]`.
        """
        return pulumi.get(self, "display_names")

    @display_names.setter
    def display_names(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "display_names", value)

    @_builtins.property
    @pulumi.getter(name="gatewayTypes")
    def gateway_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        Filter the results by exact match for gateway_type. Pass multiple times to see results matching any of the values. Valid values are: `AwsEgressPrivateLink`, `AwsIngressPrivateLink`, `AwsPeering`, `AwsPrivateNetworkInterface`, `AzureEgressPrivateLink`, `AzurePeering`, `GcpEgressPrivateServiceConnect`, `GcpPeering`.
        """
        return pulumi.get(self, "gateway_types")

    @gateway_types.setter
    def gateway_types(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "gateway_types", value)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Filter the results by exact match for id. Pass multiple times to see results matching any of the values, for example, `["gw-abc123", "gw-def456"]`.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "ids", value)

    @_builtins.property
    @pulumi.getter
    def phases(self) -> Optional[Sequence[_builtins.str]]:
        """
        Filter the results by exact match for status.phase. Pass multiple times to see results matching any of the values. Valid values are: `CREATED`, `PROVISIONING`, `READY`, `FAILED`, `DEPROVISIONING`, `EXPIRED`.
        """
        return pulumi.get(self, "phases")

    @phases.setter
    def phases(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "phases", value)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Filter the results by exact match for spec.config.region. Pass multiple times to see results matching any of the values, for example, `["us-east-1", "us-west-2"]`.
        """
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "regions", value)


class GetIdentityPoolIdentityProviderArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Identity Provider associated with the Identity Pool, for example, `op-abc123`.

    > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
    """

@pulumi.input_type
class GetIdentityPoolIdentityProviderArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Identity Provider associated with the Identity Pool, for example, `op-abc123`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Identity Provider associated with the Identity Pool, for example, `op-abc123`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetIpAddressesFilterArgsDict(TypedDict):
    address_types: NotRequired[Sequence[_builtins.str]]
    """
    A list of address types to filter by. Accepted values are: `EGRESS`, `INGRESS`.
    """
    clouds: NotRequired[Sequence[_builtins.str]]
    """
    A list of clouds to filter by. Accepted values are: `AWS`, `AZURE`, and `GCP`.
    """
    regions: NotRequired[Sequence[_builtins.str]]
    """
    A list of regions to filter by.
    """
    services: NotRequired[Sequence[_builtins.str]]
    """
    A list of services to filter by. Accepted values are: `CONNECT`, `KAFKA`.
    """

@pulumi.input_type
class GetIpAddressesFilterArgs:
    def __init__(__self__, *,
                 address_types: Optional[Sequence[_builtins.str]] = None,
                 clouds: Optional[Sequence[_builtins.str]] = None,
                 regions: Optional[Sequence[_builtins.str]] = None,
                 services: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] address_types: A list of address types to filter by. Accepted values are: `EGRESS`, `INGRESS`.
        :param Sequence[_builtins.str] clouds: A list of clouds to filter by. Accepted values are: `AWS`, `AZURE`, and `GCP`.
        :param Sequence[_builtins.str] regions: A list of regions to filter by.
        :param Sequence[_builtins.str] services: A list of services to filter by. Accepted values are: `CONNECT`, `KAFKA`.
        """
        if address_types is not None:
            pulumi.set(__self__, "address_types", address_types)
        if clouds is not None:
            pulumi.set(__self__, "clouds", clouds)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter(name="addressTypes")
    def address_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of address types to filter by. Accepted values are: `EGRESS`, `INGRESS`.
        """
        return pulumi.get(self, "address_types")

    @address_types.setter
    def address_types(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "address_types", value)

    @_builtins.property
    @pulumi.getter
    def clouds(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of clouds to filter by. Accepted values are: `AWS`, `AZURE`, and `GCP`.
        """
        return pulumi.get(self, "clouds")

    @clouds.setter
    def clouds(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "clouds", value)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of regions to filter by.
        """
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "regions", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of services to filter by. Accepted values are: `CONNECT`, `KAFKA`.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "services", value)


class GetKafkaClusterBasicArgsDict(TypedDict):
    max_ecku: _builtins.int
    """
    (Optional Number) The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs. For more details, see [Maximum eCKU requirements](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#minimum-maximum-ecku-requirements).
    """

@pulumi.input_type
class GetKafkaClusterBasicArgs:
    def __init__(__self__, *,
                 max_ecku: _builtins.int):
        """
        :param _builtins.int max_ecku: (Optional Number) The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs. For more details, see [Maximum eCKU requirements](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#minimum-maximum-ecku-requirements).
        """
        pulumi.set(__self__, "max_ecku", max_ecku)

    @_builtins.property
    @pulumi.getter(name="maxEcku")
    def max_ecku(self) -> _builtins.int:
        """
        (Optional Number) The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs. For more details, see [Maximum eCKU requirements](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#minimum-maximum-ecku-requirements).
        """
        return pulumi.get(self, "max_ecku")

    @max_ecku.setter
    def max_ecku(self, value: _builtins.int):
        pulumi.set(self, "max_ecku", value)


class GetKafkaClusterDedicatedArgsDict(TypedDict):
    cku: _builtins.int
    """
    (Required Number) The number of Confluent Kafka Units (CKUs) for Dedicated cluster types. The minimum number of CKUs for `SINGLE_ZONE` dedicated clusters is `1` whereas `MULTI_ZONE` dedicated clusters must have `2` CKUs or more.
    """
    encryption_key: _builtins.str
    """
    The ID of the encryption key that is used to encrypt the data in the Kafka cluster.
    """
    zones: Sequence[_builtins.str]
    """
    (Required List of String) The list of zones the cluster is in.
    - On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
    - On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones), for example, `us-central1-c`.
    - On Azure, zones are Confluent-chosen names (for example, `1`, `2`, `3`) since Azure does not have universal zone identifiers.
    """

@pulumi.input_type
class GetKafkaClusterDedicatedArgs:
    def __init__(__self__, *,
                 cku: _builtins.int,
                 encryption_key: _builtins.str,
                 zones: Sequence[_builtins.str]):
        """
        :param _builtins.int cku: (Required Number) The number of Confluent Kafka Units (CKUs) for Dedicated cluster types. The minimum number of CKUs for `SINGLE_ZONE` dedicated clusters is `1` whereas `MULTI_ZONE` dedicated clusters must have `2` CKUs or more.
        :param _builtins.str encryption_key: The ID of the encryption key that is used to encrypt the data in the Kafka cluster.
        :param Sequence[_builtins.str] zones: (Required List of String) The list of zones the cluster is in.
               - On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
               - On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones), for example, `us-central1-c`.
               - On Azure, zones are Confluent-chosen names (for example, `1`, `2`, `3`) since Azure does not have universal zone identifiers.
        """
        pulumi.set(__self__, "cku", cku)
        pulumi.set(__self__, "encryption_key", encryption_key)
        pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter
    def cku(self) -> _builtins.int:
        """
        (Required Number) The number of Confluent Kafka Units (CKUs) for Dedicated cluster types. The minimum number of CKUs for `SINGLE_ZONE` dedicated clusters is `1` whereas `MULTI_ZONE` dedicated clusters must have `2` CKUs or more.
        """
        return pulumi.get(self, "cku")

    @cku.setter
    def cku(self, value: _builtins.int):
        pulumi.set(self, "cku", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> _builtins.str:
        """
        The ID of the encryption key that is used to encrypt the data in the Kafka cluster.
        """
        return pulumi.get(self, "encryption_key")

    @encryption_key.setter
    def encryption_key(self, value: _builtins.str):
        pulumi.set(self, "encryption_key", value)

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Sequence[_builtins.str]:
        """
        (Required List of String) The list of zones the cluster is in.
        - On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
        - On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones), for example, `us-central1-c`.
        - On Azure, zones are Confluent-chosen names (for example, `1`, `2`, `3`) since Azure does not have universal zone identifiers.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "zones", value)


class GetKafkaClusterEnterpriseArgsDict(TypedDict):
    max_ecku: _builtins.int
    """
    (Optional Number) The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs. For more details, see [Maximum eCKU requirements](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#minimum-maximum-ecku-requirements).
    """

@pulumi.input_type
class GetKafkaClusterEnterpriseArgs:
    def __init__(__self__, *,
                 max_ecku: _builtins.int):
        """
        :param _builtins.int max_ecku: (Optional Number) The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs. For more details, see [Maximum eCKU requirements](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#minimum-maximum-ecku-requirements).
        """
        pulumi.set(__self__, "max_ecku", max_ecku)

    @_builtins.property
    @pulumi.getter(name="maxEcku")
    def max_ecku(self) -> _builtins.int:
        """
        (Optional Number) The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs. For more details, see [Maximum eCKU requirements](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#minimum-maximum-ecku-requirements).
        """
        return pulumi.get(self, "max_ecku")

    @max_ecku.setter
    def max_ecku(self, value: _builtins.int):
        pulumi.set(self, "max_ecku", value)


class GetKafkaClusterEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Kafka cluster belongs to, for example, `env-xyz456`.

    > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
    """

@pulumi.input_type
class GetKafkaClusterEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Kafka cluster belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Kafka cluster belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetKafkaClusterFreightArgsDict(TypedDict):
    max_ecku: _builtins.int
    """
    (Optional Number) The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs. For more details, see [Maximum eCKU requirements](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#minimum-maximum-ecku-requirements).
    """
    zones: Sequence[_builtins.str]
    """
    (Required List of String) The list of zones the cluster is in.
    - On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
    - On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones), for example, `us-central1-c`.
    - On Azure, zones are Confluent-chosen names (for example, `1`, `2`, `3`) since Azure does not have universal zone identifiers.
    """

@pulumi.input_type
class GetKafkaClusterFreightArgs:
    def __init__(__self__, *,
                 max_ecku: _builtins.int,
                 zones: Sequence[_builtins.str]):
        """
        :param _builtins.int max_ecku: (Optional Number) The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs. For more details, see [Maximum eCKU requirements](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#minimum-maximum-ecku-requirements).
        :param Sequence[_builtins.str] zones: (Required List of String) The list of zones the cluster is in.
               - On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
               - On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones), for example, `us-central1-c`.
               - On Azure, zones are Confluent-chosen names (for example, `1`, `2`, `3`) since Azure does not have universal zone identifiers.
        """
        pulumi.set(__self__, "max_ecku", max_ecku)
        pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter(name="maxEcku")
    def max_ecku(self) -> _builtins.int:
        """
        (Optional Number) The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs. For more details, see [Maximum eCKU requirements](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#minimum-maximum-ecku-requirements).
        """
        return pulumi.get(self, "max_ecku")

    @max_ecku.setter
    def max_ecku(self, value: _builtins.int):
        pulumi.set(self, "max_ecku", value)

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Sequence[_builtins.str]:
        """
        (Required List of String) The list of zones the cluster is in.
        - On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html), for example, `use1-az3`.
        - On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones), for example, `us-central1-c`.
        - On Azure, zones are Confluent-chosen names (for example, `1`, `2`, `3`) since Azure does not have universal zone identifiers.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "zones", value)


class GetKafkaClusterStandardArgsDict(TypedDict):
    max_ecku: _builtins.int
    """
    (Optional Number) The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs. For more details, see [Maximum eCKU requirements](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#minimum-maximum-ecku-requirements).
    """

@pulumi.input_type
class GetKafkaClusterStandardArgs:
    def __init__(__self__, *,
                 max_ecku: _builtins.int):
        """
        :param _builtins.int max_ecku: (Optional Number) The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs. For more details, see [Maximum eCKU requirements](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#minimum-maximum-ecku-requirements).
        """
        pulumi.set(__self__, "max_ecku", max_ecku)

    @_builtins.property
    @pulumi.getter(name="maxEcku")
    def max_ecku(self) -> _builtins.int:
        """
        (Optional Number) The maximum number of Elastic Confluent Kafka Units (eCKUs) that Kafka clusters should auto-scale to. Kafka clusters with "HIGH" availability must have at least two eCKUs. For more details, see [Maximum eCKU requirements](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#minimum-maximum-ecku-requirements).
        """
        return pulumi.get(self, "max_ecku")

    @max_ecku.setter
    def max_ecku(self, value: _builtins.int):
        pulumi.set(self, "max_ecku", value)


class GetKafkaClustersEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Kafka clusters belongs to, for example, `env-xyz456`.
    """

@pulumi.input_type
class GetKafkaClustersEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Kafka clusters belongs to, for example, `env-xyz456`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Kafka clusters belongs to, for example, `env-xyz456`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetKafkaTopicCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Kafka API Key.
    """
    secret: _builtins.str
    """
    The Kafka API Secret.

    > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.

    !> **Warning:** Terraform doesn't encrypt the sensitive `credentials` value of the `KafkaTopic` data source, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
    """

@pulumi.input_type
class GetKafkaTopicCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Kafka API Key.
        :param _builtins.str secret: The Kafka API Secret.
               
               > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.
               
               !> **Warning:** Terraform doesn't encrypt the sensitive `credentials` value of the `KafkaTopic` data source, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Kafka API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Kafka API Secret.

        > **Note:** A Kafka API key consists of a key and a secret. Kafka API keys are required to interact with Kafka clusters in Confluent Cloud. Each Kafka API key is valid for one specific Kafka cluster.

        !> **Warning:** Terraform doesn't encrypt the sensitive `credentials` value of the `KafkaTopic` data source, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetKafkaTopicKafkaClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Kafka cluster, for example, `lkc-abc123`.
    """

@pulumi.input_type
class GetKafkaTopicKafkaClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetKsqlClusterEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the ksqlDB cluster belongs to, for example, `env-xyz456`.

    > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
    """

@pulumi.input_type
class GetKsqlClusterEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the ksqlDB cluster belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the ksqlDB cluster belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetNetworkAwArgsDict(TypedDict):
    account: _builtins.str
    """
    (Required String) The AWS account ID associated with the Confluent Cloud VPC.
    """
    private_link_endpoint_service: _builtins.str
    """
    (Optional String) The endpoint service of the Confluent Cloud VPC (used for PrivateLink) if available.
    """
    vpc: _builtins.str
    """
    (Required String) The Confluent Cloud VPC ID.
    """

@pulumi.input_type
class GetNetworkAwArgs:
    def __init__(__self__, *,
                 account: _builtins.str,
                 private_link_endpoint_service: _builtins.str,
                 vpc: _builtins.str):
        """
        :param _builtins.str account: (Required String) The AWS account ID associated with the Confluent Cloud VPC.
        :param _builtins.str private_link_endpoint_service: (Optional String) The endpoint service of the Confluent Cloud VPC (used for PrivateLink) if available.
        :param _builtins.str vpc: (Required String) The Confluent Cloud VPC ID.
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "private_link_endpoint_service", private_link_endpoint_service)
        pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter
    def account(self) -> _builtins.str:
        """
        (Required String) The AWS account ID associated with the Confluent Cloud VPC.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: _builtins.str):
        pulumi.set(self, "account", value)

    @_builtins.property
    @pulumi.getter(name="privateLinkEndpointService")
    def private_link_endpoint_service(self) -> _builtins.str:
        """
        (Optional String) The endpoint service of the Confluent Cloud VPC (used for PrivateLink) if available.
        """
        return pulumi.get(self, "private_link_endpoint_service")

    @private_link_endpoint_service.setter
    def private_link_endpoint_service(self, value: _builtins.str):
        pulumi.set(self, "private_link_endpoint_service", value)

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> _builtins.str:
        """
        (Required String) The Confluent Cloud VPC ID.
        """
        return pulumi.get(self, "vpc")

    @vpc.setter
    def vpc(self, value: _builtins.str):
        pulumi.set(self, "vpc", value)


class GetNetworkAzureArgsDict(TypedDict):
    private_link_service_aliases: Mapping[str, _builtins.str]
    """
    (Optional Map) The mapping of zones to Private Link Service Aliases if available. Keys are zones and values are [Azure Private Link Service Aliases](https://docs.microsoft.com/en-us/azure/private-link/private-link-service-overview#share-your-service).
    """

@pulumi.input_type
class GetNetworkAzureArgs:
    def __init__(__self__, *,
                 private_link_service_aliases: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] private_link_service_aliases: (Optional Map) The mapping of zones to Private Link Service Aliases if available. Keys are zones and values are [Azure Private Link Service Aliases](https://docs.microsoft.com/en-us/azure/private-link/private-link-service-overview#share-your-service).
        """
        pulumi.set(__self__, "private_link_service_aliases", private_link_service_aliases)

    @_builtins.property
    @pulumi.getter(name="privateLinkServiceAliases")
    def private_link_service_aliases(self) -> Mapping[str, _builtins.str]:
        """
        (Optional Map) The mapping of zones to Private Link Service Aliases if available. Keys are zones and values are [Azure Private Link Service Aliases](https://docs.microsoft.com/en-us/azure/private-link/private-link-service-overview#share-your-service).
        """
        return pulumi.get(self, "private_link_service_aliases")

    @private_link_service_aliases.setter
    def private_link_service_aliases(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "private_link_service_aliases", value)


class GetNetworkDnsConfigArgsDict(TypedDict):
    resolution: _builtins.str
    """
    (Required String) Network DNS resolution.
    When resolution is `CHASED_PRIVATE`, clusters in this network require both public and private DNS to resolve cluster endpoints.
    When resolution is `PRIVATE`, clusters in this network only require private DNS to resolve cluster endpoints.
    """

@pulumi.input_type
class GetNetworkDnsConfigArgs:
    def __init__(__self__, *,
                 resolution: _builtins.str):
        """
        :param _builtins.str resolution: (Required String) Network DNS resolution.
               When resolution is `CHASED_PRIVATE`, clusters in this network require both public and private DNS to resolve cluster endpoints.
               When resolution is `PRIVATE`, clusters in this network only require private DNS to resolve cluster endpoints.
        """
        pulumi.set(__self__, "resolution", resolution)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> _builtins.str:
        """
        (Required String) Network DNS resolution.
        When resolution is `CHASED_PRIVATE`, clusters in this network require both public and private DNS to resolve cluster endpoints.
        When resolution is `PRIVATE`, clusters in this network only require private DNS to resolve cluster endpoints.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: _builtins.str):
        pulumi.set(self, "resolution", value)


class GetNetworkEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Network belongs to, for example, `env-xyz456`.

    > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
    """

@pulumi.input_type
class GetNetworkEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Network belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Network belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetNetworkGcpArgsDict(TypedDict):
    private_service_connect_service_attachments: Mapping[str, _builtins.str]
    """
    (Optional Map) The mapping of zones to Private Service Connect Service Attachments if available. Keys are zones and values are [GCP Private Service Connect service attachment](https://cloud.google.com/vpc/docs/configure-private-service-connect-producer#api_7).
    """
    project: _builtins.str
    """
    (Required String) The GCP Project ID associated with the Confluent Cloud VPC.
    """
    vpc_network: _builtins.str
    """
    (Required String) The network name of the Confluent Cloud VPC.
    """

@pulumi.input_type
class GetNetworkGcpArgs:
    def __init__(__self__, *,
                 private_service_connect_service_attachments: Mapping[str, _builtins.str],
                 project: _builtins.str,
                 vpc_network: _builtins.str):
        """
        :param Mapping[str, _builtins.str] private_service_connect_service_attachments: (Optional Map) The mapping of zones to Private Service Connect Service Attachments if available. Keys are zones and values are [GCP Private Service Connect service attachment](https://cloud.google.com/vpc/docs/configure-private-service-connect-producer#api_7).
        :param _builtins.str project: (Required String) The GCP Project ID associated with the Confluent Cloud VPC.
        :param _builtins.str vpc_network: (Required String) The network name of the Confluent Cloud VPC.
        """
        pulumi.set(__self__, "private_service_connect_service_attachments", private_service_connect_service_attachments)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "vpc_network", vpc_network)

    @_builtins.property
    @pulumi.getter(name="privateServiceConnectServiceAttachments")
    def private_service_connect_service_attachments(self) -> Mapping[str, _builtins.str]:
        """
        (Optional Map) The mapping of zones to Private Service Connect Service Attachments if available. Keys are zones and values are [GCP Private Service Connect service attachment](https://cloud.google.com/vpc/docs/configure-private-service-connect-producer#api_7).
        """
        return pulumi.get(self, "private_service_connect_service_attachments")

    @private_service_connect_service_attachments.setter
    def private_service_connect_service_attachments(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "private_service_connect_service_attachments", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        (Required String) The GCP Project ID associated with the Confluent Cloud VPC.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: _builtins.str):
        pulumi.set(self, "project", value)

    @_builtins.property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> _builtins.str:
        """
        (Required String) The network name of the Confluent Cloud VPC.
        """
        return pulumi.get(self, "vpc_network")

    @vpc_network.setter
    def vpc_network(self, value: _builtins.str):
        pulumi.set(self, "vpc_network", value)


class GetNetworkLinkEndpointEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
    """

@pulumi.input_type
class GetNetworkLinkEndpointEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Network Link Endpoint belongs to, for example, `env-xyz456`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetNetworkLinkServiceAcceptArgsDict(TypedDict):
    environments: Sequence[_builtins.str]
    """
    (Optional List of Strings) List of environments ids from which connections can be accepted. All networks within the list of environment will be allowed.
    """
    networks: Sequence[_builtins.str]
    """
    (Optional List of Strings) List of network ids from which connections can be accepted.
    """

@pulumi.input_type
class GetNetworkLinkServiceAcceptArgs:
    def __init__(__self__, *,
                 environments: Sequence[_builtins.str],
                 networks: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] environments: (Optional List of Strings) List of environments ids from which connections can be accepted. All networks within the list of environment will be allowed.
        :param Sequence[_builtins.str] networks: (Optional List of Strings) List of network ids from which connections can be accepted.
        """
        pulumi.set(__self__, "environments", environments)
        pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter
    def environments(self) -> Sequence[_builtins.str]:
        """
        (Optional List of Strings) List of environments ids from which connections can be accepted. All networks within the list of environment will be allowed.
        """
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "environments", value)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Sequence[_builtins.str]:
        """
        (Optional List of Strings) List of network ids from which connections can be accepted.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "networks", value)


class GetNetworkLinkServiceEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Network Link Service belongs to, for example, `env-1234`.

    > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
    """

@pulumi.input_type
class GetNetworkLinkServiceEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Network Link Service belongs to, for example, `env-1234`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Network Link Service belongs to, for example, `env-1234`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetPeeringEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Peering belongs to, for example, `env-xyz456`.

    > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
    """

@pulumi.input_type
class GetPeeringEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Peering belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Peering belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetPrivateLinkAccessEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Private Link Access belongs to, for example, `env-xyz456`.

    > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
    """

@pulumi.input_type
class GetPrivateLinkAccessEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Private Link Access belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Private Link Access belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetPrivateLinkAttachmentConnectionEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Private Link Attachment Connection belongs to, for example `env-xyz456`.
    """

@pulumi.input_type
class GetPrivateLinkAttachmentConnectionEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Private Link Attachment Connection belongs to, for example `env-xyz456`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Private Link Attachment Connection belongs to, for example `env-xyz456`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetPrivateLinkAttachmentEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Private Link Attachment belongs to, for example `env-xyz456`.
    """

@pulumi.input_type
class GetPrivateLinkAttachmentEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Private Link Attachment belongs to, for example `env-xyz456`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Private Link Attachment belongs to, for example `env-xyz456`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetProviderIntegrationAuthorizationEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class GetProviderIntegrationAuthorizationEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetProviderIntegrationEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Provider Integration belongs to, for example, `env-xyz456`.

    > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
    """

@pulumi.input_type
class GetProviderIntegrationEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Provider Integration belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Provider Integration belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetProviderIntegrationSetupEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
    """

@pulumi.input_type
class GetProviderIntegrationSetupEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Provider Integration belongs to, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetSchemaCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Schema Registry API Key.
    """
    secret: _builtins.str
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class GetSchemaCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Schema Registry API Key.
        :param _builtins.str secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetSchemaMetadataArgsDict(TypedDict):
    properties: Mapping[str, _builtins.str]
    """
    (Optional Map) The custom properties to set:
    """
    sensitives: Sequence[_builtins.str]
    """
    (Optional List of Strings) A list of metadata properties to be encrypted.
    """
    tags: Sequence['GetSchemaMetadataTagArgsDict']
    """
    (Optional String List) The tags to which the rule applies, if any.
    """

@pulumi.input_type
class GetSchemaMetadataArgs:
    def __init__(__self__, *,
                 properties: Mapping[str, _builtins.str],
                 sensitives: Sequence[_builtins.str],
                 tags: Sequence['GetSchemaMetadataTagArgs']):
        """
        :param Mapping[str, _builtins.str] properties: (Optional Map) The custom properties to set:
        :param Sequence[_builtins.str] sensitives: (Optional List of Strings) A list of metadata properties to be encrypted.
        :param Sequence['GetSchemaMetadataTagArgs'] tags: (Optional String List) The tags to which the rule applies, if any.
        """
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "sensitives", sensitives)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Mapping[str, _builtins.str]:
        """
        (Optional Map) The custom properties to set:
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def sensitives(self) -> Sequence[_builtins.str]:
        """
        (Optional List of Strings) A list of metadata properties to be encrypted.
        """
        return pulumi.get(self, "sensitives")

    @sensitives.setter
    def sensitives(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "sensitives", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['GetSchemaMetadataTagArgs']:
        """
        (Optional String List) The tags to which the rule applies, if any.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Sequence['GetSchemaMetadataTagArgs']):
        pulumi.set(self, "tags", value)


class GetSchemaMetadataTagArgsDict(TypedDict):
    key: _builtins.str
    """
    (Required String) The setting name.
    """
    values: Sequence[_builtins.str]
    """
    (Required List of Strings) The list of tags.
    """

@pulumi.input_type
class GetSchemaMetadataTagArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: (Required String) The setting name.
        :param Sequence[_builtins.str] values: (Required List of Strings) The list of tags.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Required String) The setting name.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Required List of Strings) The list of tags.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


class GetSchemaRegistryClusterConfigCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Schema Registry API Key.
    """
    secret: _builtins.str
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class GetSchemaRegistryClusterConfigCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Schema Registry API Key.
        :param _builtins.str secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetSchemaRegistryClusterConfigSchemaRegistryClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class GetSchemaRegistryClusterConfigSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetSchemaRegistryClusterEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Schema Registry cluster belongs to, for example, `env-xyz456`.
    """

@pulumi.input_type
class GetSchemaRegistryClusterEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Schema Registry cluster belongs to, for example, `env-xyz456`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Schema Registry cluster belongs to, for example, `env-xyz456`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetSchemaRegistryClusterModeCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Schema Registry API Key.
    """
    secret: _builtins.str
    """
    The Schema Registry API Secret.

    > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
    """

@pulumi.input_type
class GetSchemaRegistryClusterModeCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Schema Registry API Key.
        :param _builtins.str secret: The Schema Registry API Secret.
               
               > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Schema Registry API Secret.

        > **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetSchemaRegistryClusterModeSchemaRegistryClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class GetSchemaRegistryClusterModeSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetSchemaRegistryClustersEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Schema Registry cluster belongs to, for example, `env-xyz456`.
    - If no environment id is specified, clusters from all environments will be displayed.
    """

@pulumi.input_type
class GetSchemaRegistryClustersEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Schema Registry cluster belongs to, for example, `env-xyz456`.
               - If no environment id is specified, clusters from all environments will be displayed.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Schema Registry cluster belongs to, for example, `env-xyz456`.
        - If no environment id is specified, clusters from all environments will be displayed.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetSchemaRegistryDekCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Schema Registry API Key.
    """
    secret: _builtins.str
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class GetSchemaRegistryDekCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Schema Registry API Key.
        :param _builtins.str secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetSchemaRegistryDekSchemaRegistryClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class GetSchemaRegistryDekSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetSchemaRegistryKekCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Schema Registry API Key.
    """
    secret: _builtins.str
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class GetSchemaRegistryKekCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Schema Registry API Key.
        :param _builtins.str secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetSchemaRegistryKekSchemaRegistryClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class GetSchemaRegistryKekSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetSchemaRulesetArgsDict(TypedDict):
    domain_rules: NotRequired[Sequence['GetSchemaRulesetDomainRuleArgsDict']]
    """
    (Optional List of Blocks) supports the following:
    """
    migration_rules: NotRequired[Sequence['GetSchemaRulesetMigrationRuleArgsDict']]
    """
    (Optional List of Blocks) supports the following:
    """

@pulumi.input_type
class GetSchemaRulesetArgs:
    def __init__(__self__, *,
                 domain_rules: Optional[Sequence['GetSchemaRulesetDomainRuleArgs']] = None,
                 migration_rules: Optional[Sequence['GetSchemaRulesetMigrationRuleArgs']] = None):
        """
        :param Sequence['GetSchemaRulesetDomainRuleArgs'] domain_rules: (Optional List of Blocks) supports the following:
        :param Sequence['GetSchemaRulesetMigrationRuleArgs'] migration_rules: (Optional List of Blocks) supports the following:
        """
        if domain_rules is not None:
            pulumi.set(__self__, "domain_rules", domain_rules)
        if migration_rules is not None:
            pulumi.set(__self__, "migration_rules", migration_rules)

    @_builtins.property
    @pulumi.getter(name="domainRules")
    def domain_rules(self) -> Optional[Sequence['GetSchemaRulesetDomainRuleArgs']]:
        """
        (Optional List of Blocks) supports the following:
        """
        return pulumi.get(self, "domain_rules")

    @domain_rules.setter
    def domain_rules(self, value: Optional[Sequence['GetSchemaRulesetDomainRuleArgs']]):
        pulumi.set(self, "domain_rules", value)

    @_builtins.property
    @pulumi.getter(name="migrationRules")
    def migration_rules(self) -> Optional[Sequence['GetSchemaRulesetMigrationRuleArgs']]:
        """
        (Optional List of Blocks) supports the following:
        """
        return pulumi.get(self, "migration_rules")

    @migration_rules.setter
    def migration_rules(self, value: Optional[Sequence['GetSchemaRulesetMigrationRuleArgs']]):
        pulumi.set(self, "migration_rules", value)


class GetSchemaRulesetDomainRuleArgsDict(TypedDict):
    kind: _builtins.str
    """
    (Required String) The kind of the rule. Accepted values are `CONDITION` and `TRANSFORM`. `CONDITION` - validate the value of a field, `TRANSFORM` - transform the value of a field. Data quality rules use `CONDITION` kind, data transformation, encryption and migration rules use `TRANSFORM` kind.
    """
    mode: _builtins.str
    """
    (Required String) The mode of the rule. Accepted values are `UPGRADE`, `DOWNGRADE`, `UPDOWN`, `WRITE`, `READ`, and `WRITEREAD`.
    """
    name: _builtins.str
    """
    (Required String) A user-defined name that can be used to reference the rule.
    """
    params: Mapping[str, _builtins.str]
    """
    (Optional Configuration Block) A set of static parameters for the rule, which is optional. These are key-value pairs that are passed to the rule.
    """
    tags: Sequence[_builtins.str]
    """
    (Optional String List) The tags to which the rule applies, if any.
    """
    type: _builtins.str
    """
    (Required String) The type of rule, which invokes a specific rule executor that that will run the rule. Google Common Expression Language (`CEL`) is used for data quality and transformation rules, Confluent `ENCRYPT` is used for data encryption rules, and `JSONata` is used for migration rules.
    """
    disabled: NotRequired[_builtins.bool]
    """
    (Optional Boolean) The boolean flag to control whether the rule should be disabled.
    """
    doc: NotRequired[_builtins.str]
    """
    (Optional String) An optional description of the rule.
    """
    expr: NotRequired[_builtins.str]
    """
    (Optional String) The rule body. Data quality and transformation rules use `CEL` language expressions, data migration rules use `JSONata` expressions. Defaults to "".
    """
    on_failure: NotRequired[_builtins.str]
    """
    (Optional String) An optional action to execute if the rule fails, otherwise the built-in action type `ERROR` is used. For `UPDOWN` and `WRITEREAD` rules, one can specify two actions separated by commas, as mentioned above.
    """
    on_success: NotRequired[_builtins.str]
    """
    (Optional String) An optional action to execute if the rule succeeds, otherwise the built-in action type `NONE` is used. For `UPDOWN` and `WRITEREAD` rules, one can specify two actions separated by commas, such as `NONE,ERROR` for a `WRITEREAD` rule. In this case `NONE` applies to `WRITE` and `ERROR` applies to `READ`.
    """

@pulumi.input_type
class GetSchemaRulesetDomainRuleArgs:
    def __init__(__self__, *,
                 kind: _builtins.str,
                 mode: _builtins.str,
                 name: _builtins.str,
                 params: Mapping[str, _builtins.str],
                 tags: Sequence[_builtins.str],
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 doc: Optional[_builtins.str] = None,
                 expr: Optional[_builtins.str] = None,
                 on_failure: Optional[_builtins.str] = None,
                 on_success: Optional[_builtins.str] = None):
        """
        :param _builtins.str kind: (Required String) The kind of the rule. Accepted values are `CONDITION` and `TRANSFORM`. `CONDITION` - validate the value of a field, `TRANSFORM` - transform the value of a field. Data quality rules use `CONDITION` kind, data transformation, encryption and migration rules use `TRANSFORM` kind.
        :param _builtins.str mode: (Required String) The mode of the rule. Accepted values are `UPGRADE`, `DOWNGRADE`, `UPDOWN`, `WRITE`, `READ`, and `WRITEREAD`.
        :param _builtins.str name: (Required String) A user-defined name that can be used to reference the rule.
        :param Mapping[str, _builtins.str] params: (Optional Configuration Block) A set of static parameters for the rule, which is optional. These are key-value pairs that are passed to the rule.
        :param Sequence[_builtins.str] tags: (Optional String List) The tags to which the rule applies, if any.
        :param _builtins.str type: (Required String) The type of rule, which invokes a specific rule executor that that will run the rule. Google Common Expression Language (`CEL`) is used for data quality and transformation rules, Confluent `ENCRYPT` is used for data encryption rules, and `JSONata` is used for migration rules.
        :param _builtins.bool disabled: (Optional Boolean) The boolean flag to control whether the rule should be disabled.
        :param _builtins.str doc: (Optional String) An optional description of the rule.
        :param _builtins.str expr: (Optional String) The rule body. Data quality and transformation rules use `CEL` language expressions, data migration rules use `JSONata` expressions. Defaults to "".
        :param _builtins.str on_failure: (Optional String) An optional action to execute if the rule fails, otherwise the built-in action type `ERROR` is used. For `UPDOWN` and `WRITEREAD` rules, one can specify two actions separated by commas, as mentioned above.
        :param _builtins.str on_success: (Optional String) An optional action to execute if the rule succeeds, otherwise the built-in action type `NONE` is used. For `UPDOWN` and `WRITEREAD` rules, one can specify two actions separated by commas, such as `NONE,ERROR` for a `WRITEREAD` rule. In this case `NONE` applies to `WRITE` and `ERROR` applies to `READ`.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if doc is not None:
            pulumi.set(__self__, "doc", doc)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        (Required String) The kind of the rule. Accepted values are `CONDITION` and `TRANSFORM`. `CONDITION` - validate the value of a field, `TRANSFORM` - transform the value of a field. Data quality rules use `CONDITION` kind, data transformation, encryption and migration rules use `TRANSFORM` kind.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: _builtins.str):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        (Required String) The mode of the rule. Accepted values are `UPGRADE`, `DOWNGRADE`, `UPDOWN`, `WRITE`, `READ`, and `WRITEREAD`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: _builtins.str):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Required String) A user-defined name that can be used to reference the rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Mapping[str, _builtins.str]:
        """
        (Optional Configuration Block) A set of static parameters for the rule, which is optional. These are key-value pairs that are passed to the rule.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        (Optional String List) The tags to which the rule applies, if any.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        (Required String) The type of rule, which invokes a specific rule executor that that will run the rule. Google Common Expression Language (`CEL`) is used for data quality and transformation rules, Confluent `ENCRYPT` is used for data encryption rules, and `JSONata` is used for migration rules.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Optional Boolean) The boolean flag to control whether the rule should be disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def doc(self) -> Optional[_builtins.str]:
        """
        (Optional String) An optional description of the rule.
        """
        return pulumi.get(self, "doc")

    @doc.setter
    def doc(self, value: Optional[_builtins.str]):
        pulumi.set(self, "doc", value)

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional[_builtins.str]:
        """
        (Optional String) The rule body. Data quality and transformation rules use `CEL` language expressions, data migration rules use `JSONata` expressions. Defaults to "".
        """
        return pulumi.get(self, "expr")

    @expr.setter
    def expr(self, value: Optional[_builtins.str]):
        pulumi.set(self, "expr", value)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[_builtins.str]:
        """
        (Optional String) An optional action to execute if the rule fails, otherwise the built-in action type `ERROR` is used. For `UPDOWN` and `WRITEREAD` rules, one can specify two actions separated by commas, as mentioned above.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[_builtins.str]):
        pulumi.set(self, "on_failure", value)

    @_builtins.property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[_builtins.str]:
        """
        (Optional String) An optional action to execute if the rule succeeds, otherwise the built-in action type `NONE` is used. For `UPDOWN` and `WRITEREAD` rules, one can specify two actions separated by commas, such as `NONE,ERROR` for a `WRITEREAD` rule. In this case `NONE` applies to `WRITE` and `ERROR` applies to `READ`.
        """
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[_builtins.str]):
        pulumi.set(self, "on_success", value)


class GetSchemaRulesetMigrationRuleArgsDict(TypedDict):
    kind: _builtins.str
    """
    (Required String) The kind of the rule. Accepted values are `CONDITION` and `TRANSFORM`. `CONDITION` - validate the value of a field, `TRANSFORM` - transform the value of a field. Data quality rules use `CONDITION` kind, data transformation, encryption and migration rules use `TRANSFORM` kind.
    """
    mode: _builtins.str
    """
    (Required String) The mode of the rule. Accepted values are `UPGRADE`, `DOWNGRADE`, `UPDOWN`, `WRITE`, `READ`, and `WRITEREAD`.
    """
    name: _builtins.str
    """
    (Required String) A user-defined name that can be used to reference the rule.
    """
    params: Mapping[str, _builtins.str]
    """
    (Optional Configuration Block) A set of static parameters for the rule, which is optional. These are key-value pairs that are passed to the rule.
    """
    tags: Sequence[_builtins.str]
    """
    (Optional String List) The tags to which the rule applies, if any.
    """
    type: _builtins.str
    """
    (Required String) The type of rule, which invokes a specific rule executor that that will run the rule. Google Common Expression Language (`CEL`) is used for data quality and transformation rules, Confluent `ENCRYPT` is used for data encryption rules, and `JSONata` is used for migration rules.
    """
    disabled: NotRequired[_builtins.bool]
    """
    (Optional Boolean) The boolean flag to control whether the rule should be disabled.
    """
    doc: NotRequired[_builtins.str]
    """
    (Optional String) An optional description of the rule.
    """
    expr: NotRequired[_builtins.str]
    """
    (Optional String) The rule body. Data quality and transformation rules use `CEL` language expressions, data migration rules use `JSONata` expressions. Defaults to "".
    """
    on_failure: NotRequired[_builtins.str]
    """
    (Optional String) An optional action to execute if the rule fails, otherwise the built-in action type `ERROR` is used. For `UPDOWN` and `WRITEREAD` rules, one can specify two actions separated by commas, as mentioned above.
    """
    on_success: NotRequired[_builtins.str]
    """
    (Optional String) An optional action to execute if the rule succeeds, otherwise the built-in action type `NONE` is used. For `UPDOWN` and `WRITEREAD` rules, one can specify two actions separated by commas, such as `NONE,ERROR` for a `WRITEREAD` rule. In this case `NONE` applies to `WRITE` and `ERROR` applies to `READ`.
    """

@pulumi.input_type
class GetSchemaRulesetMigrationRuleArgs:
    def __init__(__self__, *,
                 kind: _builtins.str,
                 mode: _builtins.str,
                 name: _builtins.str,
                 params: Mapping[str, _builtins.str],
                 tags: Sequence[_builtins.str],
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 doc: Optional[_builtins.str] = None,
                 expr: Optional[_builtins.str] = None,
                 on_failure: Optional[_builtins.str] = None,
                 on_success: Optional[_builtins.str] = None):
        """
        :param _builtins.str kind: (Required String) The kind of the rule. Accepted values are `CONDITION` and `TRANSFORM`. `CONDITION` - validate the value of a field, `TRANSFORM` - transform the value of a field. Data quality rules use `CONDITION` kind, data transformation, encryption and migration rules use `TRANSFORM` kind.
        :param _builtins.str mode: (Required String) The mode of the rule. Accepted values are `UPGRADE`, `DOWNGRADE`, `UPDOWN`, `WRITE`, `READ`, and `WRITEREAD`.
        :param _builtins.str name: (Required String) A user-defined name that can be used to reference the rule.
        :param Mapping[str, _builtins.str] params: (Optional Configuration Block) A set of static parameters for the rule, which is optional. These are key-value pairs that are passed to the rule.
        :param Sequence[_builtins.str] tags: (Optional String List) The tags to which the rule applies, if any.
        :param _builtins.str type: (Required String) The type of rule, which invokes a specific rule executor that that will run the rule. Google Common Expression Language (`CEL`) is used for data quality and transformation rules, Confluent `ENCRYPT` is used for data encryption rules, and `JSONata` is used for migration rules.
        :param _builtins.bool disabled: (Optional Boolean) The boolean flag to control whether the rule should be disabled.
        :param _builtins.str doc: (Optional String) An optional description of the rule.
        :param _builtins.str expr: (Optional String) The rule body. Data quality and transformation rules use `CEL` language expressions, data migration rules use `JSONata` expressions. Defaults to "".
        :param _builtins.str on_failure: (Optional String) An optional action to execute if the rule fails, otherwise the built-in action type `ERROR` is used. For `UPDOWN` and `WRITEREAD` rules, one can specify two actions separated by commas, as mentioned above.
        :param _builtins.str on_success: (Optional String) An optional action to execute if the rule succeeds, otherwise the built-in action type `NONE` is used. For `UPDOWN` and `WRITEREAD` rules, one can specify two actions separated by commas, such as `NONE,ERROR` for a `WRITEREAD` rule. In this case `NONE` applies to `WRITE` and `ERROR` applies to `READ`.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if doc is not None:
            pulumi.set(__self__, "doc", doc)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        (Required String) The kind of the rule. Accepted values are `CONDITION` and `TRANSFORM`. `CONDITION` - validate the value of a field, `TRANSFORM` - transform the value of a field. Data quality rules use `CONDITION` kind, data transformation, encryption and migration rules use `TRANSFORM` kind.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: _builtins.str):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        (Required String) The mode of the rule. Accepted values are `UPGRADE`, `DOWNGRADE`, `UPDOWN`, `WRITE`, `READ`, and `WRITEREAD`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: _builtins.str):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Required String) A user-defined name that can be used to reference the rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Mapping[str, _builtins.str]:
        """
        (Optional Configuration Block) A set of static parameters for the rule, which is optional. These are key-value pairs that are passed to the rule.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        (Optional String List) The tags to which the rule applies, if any.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        (Required String) The type of rule, which invokes a specific rule executor that that will run the rule. Google Common Expression Language (`CEL`) is used for data quality and transformation rules, Confluent `ENCRYPT` is used for data encryption rules, and `JSONata` is used for migration rules.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Optional Boolean) The boolean flag to control whether the rule should be disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def doc(self) -> Optional[_builtins.str]:
        """
        (Optional String) An optional description of the rule.
        """
        return pulumi.get(self, "doc")

    @doc.setter
    def doc(self, value: Optional[_builtins.str]):
        pulumi.set(self, "doc", value)

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional[_builtins.str]:
        """
        (Optional String) The rule body. Data quality and transformation rules use `CEL` language expressions, data migration rules use `JSONata` expressions. Defaults to "".
        """
        return pulumi.get(self, "expr")

    @expr.setter
    def expr(self, value: Optional[_builtins.str]):
        pulumi.set(self, "expr", value)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[_builtins.str]:
        """
        (Optional String) An optional action to execute if the rule fails, otherwise the built-in action type `ERROR` is used. For `UPDOWN` and `WRITEREAD` rules, one can specify two actions separated by commas, as mentioned above.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[_builtins.str]):
        pulumi.set(self, "on_failure", value)

    @_builtins.property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[_builtins.str]:
        """
        (Optional String) An optional action to execute if the rule succeeds, otherwise the built-in action type `NONE` is used. For `UPDOWN` and `WRITEREAD` rules, one can specify two actions separated by commas, such as `NONE,ERROR` for a `WRITEREAD` rule. In this case `NONE` applies to `WRITE` and `ERROR` applies to `READ`.
        """
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[_builtins.str]):
        pulumi.set(self, "on_success", value)


class GetSchemaSchemaRegistryClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class GetSchemaSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetSchemasCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Schema Registry API Key.
    """
    secret: _builtins.str
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class GetSchemasCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Schema Registry API Key.
        :param _builtins.str secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetSchemasFilterArgsDict(TypedDict):
    deleted: NotRequired[_builtins.bool]
    """
    The boolean flag to control whether to return soft deleted schemas. Defaults to `false`.
    """
    latest_only: NotRequired[_builtins.bool]
    """
    The boolean flag to control whether to return latest schema versions only for each matching subject. Defaults to `false`.
    """
    subject_prefix: NotRequired[_builtins.str]
    """
    The prefix of the subjects (in other words, the namespaces), representing the subjects under which the schemas are registered.
    """

@pulumi.input_type
class GetSchemasFilterArgs:
    def __init__(__self__, *,
                 deleted: Optional[_builtins.bool] = None,
                 latest_only: Optional[_builtins.bool] = None,
                 subject_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.bool deleted: The boolean flag to control whether to return soft deleted schemas. Defaults to `false`.
        :param _builtins.bool latest_only: The boolean flag to control whether to return latest schema versions only for each matching subject. Defaults to `false`.
        :param _builtins.str subject_prefix: The prefix of the subjects (in other words, the namespaces), representing the subjects under which the schemas are registered.
        """
        if deleted is not None:
            pulumi.set(__self__, "deleted", deleted)
        if latest_only is not None:
            pulumi.set(__self__, "latest_only", latest_only)
        if subject_prefix is not None:
            pulumi.set(__self__, "subject_prefix", subject_prefix)

    @_builtins.property
    @pulumi.getter
    def deleted(self) -> Optional[_builtins.bool]:
        """
        The boolean flag to control whether to return soft deleted schemas. Defaults to `false`.
        """
        return pulumi.get(self, "deleted")

    @deleted.setter
    def deleted(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "deleted", value)

    @_builtins.property
    @pulumi.getter(name="latestOnly")
    def latest_only(self) -> Optional[_builtins.bool]:
        """
        The boolean flag to control whether to return latest schema versions only for each matching subject. Defaults to `false`.
        """
        return pulumi.get(self, "latest_only")

    @latest_only.setter
    def latest_only(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "latest_only", value)

    @_builtins.property
    @pulumi.getter(name="subjectPrefix")
    def subject_prefix(self) -> Optional[_builtins.str]:
        """
        The prefix of the subjects (in other words, the namespaces), representing the subjects under which the schemas are registered.
        """
        return pulumi.get(self, "subject_prefix")

    @subject_prefix.setter
    def subject_prefix(self, value: Optional[_builtins.str]):
        pulumi.set(self, "subject_prefix", value)


class GetSchemasSchemaRegistryClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class GetSchemasSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetSubjectConfigCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Schema Registry API Key.
    """
    secret: _builtins.str
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class GetSubjectConfigCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Schema Registry API Key.
        :param _builtins.str secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetSubjectConfigSchemaRegistryClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class GetSubjectConfigSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetSubjectModeCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Schema Registry API Key.
    """
    secret: _builtins.str
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class GetSubjectModeCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Schema Registry API Key.
        :param _builtins.str secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetSubjectModeSchemaRegistryClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class GetSubjectModeSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetTableflowTopicCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Tableflow API Key.
    """
    secret: _builtins.str
    """
    The Tableflow API Secret.

    > **Note:** A Tableflow API key consists of a key and a secret. Tableflow API keys are required to interact with Tableflow Topics in Confluent Cloud.

    !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `TableflowTopic` data source, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
    """

@pulumi.input_type
class GetTableflowTopicCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Tableflow API Key.
        :param _builtins.str secret: The Tableflow API Secret.
               
               > **Note:** A Tableflow API key consists of a key and a secret. Tableflow API keys are required to interact with Tableflow Topics in Confluent Cloud.
               
               !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `TableflowTopic` data source, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Tableflow API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Tableflow API Secret.

        > **Note:** A Tableflow API key consists of a key and a secret. Tableflow API keys are required to interact with Tableflow Topics in Confluent Cloud.

        !> **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn't encrypt the sensitive `credentials` value of the `TableflowTopic` data source, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetTableflowTopicEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment, for example, `env-abc123`.
    """

@pulumi.input_type
class GetTableflowTopicEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment, for example, `env-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment, for example, `env-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetTableflowTopicKafkaClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Kafka cluster, for example, `lkc-abc123`.
    """

@pulumi.input_type
class GetTableflowTopicKafkaClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Kafka cluster, for example, `lkc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetTagBindingCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Schema Registry API Key.
    """
    secret: _builtins.str
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class GetTagBindingCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Schema Registry API Key.
        :param _builtins.str secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetTagBindingSchemaRegistryClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class GetTagBindingSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetTagCredentialsArgsDict(TypedDict):
    key: _builtins.str
    """
    The Schema Registry API Key.
    """
    secret: _builtins.str
    """
    The Schema Registry API Secret.
    """

@pulumi.input_type
class GetTagCredentialsArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str key: The Schema Registry API Key.
        :param _builtins.str secret: The Schema Registry API Secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Schema Registry API Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The Schema Registry API Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


class GetTagSchemaRegistryClusterArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
    """

@pulumi.input_type
class GetTagSchemaRegistryClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Schema Registry cluster, for example, `lsrc-abc123`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


class GetTransitGatewayAttachmentEnvironmentArgsDict(TypedDict):
    id: _builtins.str
    """
    The ID of the Environment that the Transit Gateway Attachment belongs to, for example, `env-xyz456`.

    > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
    """

@pulumi.input_type
class GetTransitGatewayAttachmentEnvironmentArgs:
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the Environment that the Transit Gateway Attachment belongs to, for example, `env-xyz456`.
               
               > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Environment that the Transit Gateway Attachment belongs to, for example, `env-xyz456`.

        > **Note:** Exactly one from the `id` and `display_name` attributes must be specified.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)


