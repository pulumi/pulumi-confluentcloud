// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.ConfluentCloud
{
    /// <summary>
    /// [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](https://docs.confluent.io/cloud/current/api.html#section/Versioning/API-Lifecycle-Policy)
    /// 
    /// `confluentcloud.RoleBinding` provides a Role Binding resource that enables creating, reading, and deleting role bindings on Confluent Cloud.
    /// 
    /// &gt; **Note:** For more information on the Role Bindings, see [Predefined RBAC roles in Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/access-control/rbac/predefined-rbac-roles.html).
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using ConfluentCloud = Pulumi.ConfluentCloud;
    /// using Std = Pulumi.Std;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var org_example_rb = new ConfluentCloud.RoleBinding("org-example-rb", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "MetricsViewer",
    ///         CrnPattern = demo.ResourceName,
    ///     });
    /// 
    ///     var environment_example_rb = new ConfluentCloud.RoleBinding("environment-example-rb", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "EnvironmentAdmin",
    ///         CrnPattern = stag.ResourceName,
    ///     });
    /// 
    ///     var environment_example_rb_skip_sync = new ConfluentCloud.RoleBinding("environment-example-rb-skip-sync", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "EnvironmentAdmin",
    ///         CrnPattern = stag.ResourceName,
    ///         DisableWaitForReady = true,
    ///     });
    /// 
    ///     var environment_example_rb_2 = new ConfluentCloud.RoleBinding("environment-example-rb-2", new()
    ///     {
    ///         Principal = $"User:{testConfluentIdentityPool.Id}",
    ///         RoleName = "EnvironmentAdmin",
    ///         CrnPattern = stag.ResourceName,
    ///     });
    /// 
    ///     var data_discovery_example_rb = new ConfluentCloud.RoleBinding("data-discovery-example-rb", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "DataDiscovery",
    ///         CrnPattern = stag.ResourceName,
    ///     });
    /// 
    ///     var network_example_rb = new ConfluentCloud.RoleBinding("network-example-rb", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "NetworkAdmin",
    ///         CrnPattern = demo.ResourceName,
    ///     });
    /// 
    ///     var cluster_example_rb = new ConfluentCloud.RoleBinding("cluster-example-rb", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "CloudClusterAdmin",
    ///         CrnPattern = basic.RbacCrn,
    ///     });
    /// 
    ///     var topic_example_rb = new ConfluentCloud.RoleBinding("topic-example-rb", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "DeveloperWrite",
    ///         CrnPattern = $"{standard.RbacCrn}/kafka={standard.Id}/topic={orders.TopicName}",
    ///     });
    /// 
    ///     var topic_example_rb_2 = new ConfluentCloud.RoleBinding("topic-example-rb-2", new()
    ///     {
    ///         Principal = $"User:{testConfluentIdentityPool.Id}",
    ///         RoleName = "DeveloperWrite",
    ///         CrnPattern = $"{standard.RbacCrn}/kafka={standard.Id}/topic={orders.TopicName}",
    ///     });
    /// 
    ///     var group_example_rb = new ConfluentCloud.RoleBinding("group-example-rb", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "DeveloperRead",
    ///         CrnPattern = $"{basic.RbacCrn}/kafka={standard.Id}/group=confluent_cli_consumer_*",
    ///     });
    /// 
    ///     var group_mapping_example_rb = new ConfluentCloud.RoleBinding("group-mapping-example-rb", new()
    ///     {
    ///         Principal = $"User:{application_developers.Id}",
    ///         RoleName = "EnvironmentAdmin",
    ///         CrnPattern = stag.ResourceName,
    ///     });
    /// 
    ///     var transaction_example_rb = new ConfluentCloud.RoleBinding("transaction-example-rb", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "DeveloperRead",
    ///         CrnPattern = $"{basic.RbacCrn}/kafka={standard.Id}/transactional-id=my_transaction",
    ///     });
    /// 
    ///     var connectorName = Std.Index.Lookup.Invoke(new()
    ///     {
    ///         Map = testConfluentConnector.ConfigNonsensitive,
    ///         Key = "name",
    ///         Default = "\"name\" attribute is missing",
    ///     }).Result;
    /// 
    ///     var connector_example_rb = new ConfluentCloud.RoleBinding("connector-example-rb", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "DeveloperRead",
    ///         CrnPattern = $"{standard.RbacCrn}/connector={connectorName}",
    ///     });
    /// 
    ///     var all_subjects_example_rb = new ConfluentCloud.RoleBinding("all-subjects-example-rb", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "DeveloperRead",
    ///         CrnPattern = $"{example.ResourceName}/subject=*",
    ///     });
    /// 
    ///     var subject_foo_example_rb = new ConfluentCloud.RoleBinding("subject-foo-example-rb", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "DeveloperRead",
    ///         CrnPattern = $"{example.ResourceName}/subject=foo",
    ///     });
    /// 
    ///     var subject_with_abc_prefix_example_rb = new ConfluentCloud.RoleBinding("subject-with-abc-prefix-example-rb", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "DeveloperRead",
    ///         CrnPattern = $"{example.ResourceName}/subject=abc*",
    ///     });
    /// 
    ///     var kek_example_rb = new ConfluentCloud.RoleBinding("kek-example-rb", new()
    ///     {
    ///         Principal = $"User:{test.Id}",
    ///         RoleName = "DeveloperRead",
    ///         CrnPattern = $"{example.ResourceName}/kek=kek-name",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Getting Started
    /// 
    /// The following end-to-end examples might help to get started with `confluentcloud.RoleBinding` resource:
    ///   * standard-kafka-rbac: _Standard_ Kafka cluster with authorization using RBAC
    ///   * dedicated-public-kafka-rbac: _Dedicated_ Kafka cluster that is accessible over the public internet with authorization using RBAC
    ///   * dedicated-privatelink-aws-kafka-rbac: _Dedicated_ Kafka cluster on AWS that is accessible via PrivateLink connections with authorization using RBAC
    ///   * dedicated-privatelink-azure-kafka-rbac: _Dedicated_ Kafka cluster on Azure that is accessible via PrivateLink connections with authorization using RBAC
    ///   * dedicated-vnet-peering-azure-kafka-rbac: _Dedicated_ Kafka cluster on Azure that is accessible via VPC Peering connections with authorization using RBAC
    ///   * dedicated-vpc-peering-aws-kafka-rbac: _Dedicated_ Kafka cluster on AWS that is accessible via VPC Peering connections with authorization using RBAC
    ///   * dedicated-vpc-peering-gcp-kafka-rbac: _Dedicated_ Kafka cluster on GCP that is accessible via VPC Peering connections with authorization using RBAC
    ///   * dedicated-transit-gateway-attachment-aws-kafka-acls: _Dedicated_ Kafka cluster on AWS that is accessible via Transit Gateway Endpoint with authorization using ACLs
    ///   * dedicated-transit-gateway-attachment-aws-kafka-rbac: _Dedicated_ Kafka cluster on AWS that is accessible via Transit Gateway Endpoint with authorization using RBAC
    ///   * enterprise-privatelinkattachment-aws-kafka-acls: _Enterprise_ Kafka cluster on AWS that is accessible via PrivateLink connections with authorization using ACLs
    /// 
    /// ## Example of using TimeSleep
    /// 
    /// This configuration introduces a 360-second custom delay after the creation of a role binding, before creating a Kafka topic.
    /// 
    /// For context, using `DisableWaitForReady = false` (the default setting) results in a 90-second hardcoded delay, while opting for `DisableWaitForReady = true` results in a 0-second delay.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using ConfluentCloud = Pulumi.ConfluentCloud;
    /// using Time = Pulumi.Time;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var app_manager_kafka_cluster_admin_skip_sync = new ConfluentCloud.RoleBinding("app-manager-kafka-cluster-admin-skip-sync", new()
    ///     {
    ///         Principal = $"User:{app_manager.Id}",
    ///         RoleName = "CloudClusterAdmin",
    ///         CrnPattern = standard.RbacCrn,
    ///         DisableWaitForReady = true,
    ///     });
    /// 
    ///     var wait360SecondsAfterRoleBinding = new Time.Index.Sleep("wait_360_seconds_after_role_binding", new()
    ///     {
    ///         CreateDuration = "360s",
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             app_manager_kafka_cluster_admin_skip_sync,
    ///         },
    ///     });
    /// 
    ///     var orders = new ConfluentCloud.KafkaTopic("orders", new()
    ///     {
    ///         KafkaCluster = new ConfluentCloud.Inputs.KafkaTopicKafkaClusterArgs
    ///         {
    ///             Id = standard.Id,
    ///         },
    ///         TopicName = "orders",
    ///         RestEndpoint = standard.RestEndpoint,
    ///         Credentials = new ConfluentCloud.Inputs.KafkaTopicCredentialsArgs
    ///         {
    ///             Key = app_manager_kafka_api_key.Id,
    ///             Secret = app_manager_kafka_api_key.Secret,
    ///         },
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             wait360SecondsAfterRoleBinding,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// &gt; **Note:** `CONFLUENT_CLOUD_API_KEY` and `CONFLUENT_CLOUD_API_SECRET` environment variables must be set before importing a Role Binding.
    /// 
    /// You can import a Role Binding by using Role Binding ID, for example:
    /// 
    /// ```sh
    /// $ export CONFLUENT_CLOUD_API_KEY="&lt;cloud_api_key&gt;"
    /// $ export CONFLUENT_CLOUD_API_SECRET="&lt;cloud_api_secret&gt;"
    /// $ pulumi import confluentcloud:index/roleBinding:RoleBinding my_rb rb-f3a90de
    /// ```
    /// 
    /// !&gt; **Warning:** Do not forget to delete terminal command history afterwards for security purposes.
    /// </summary>
    [ConfluentCloudResourceType("confluentcloud:index/roleBinding:RoleBinding")]
    public partial class RoleBinding : global::Pulumi.CustomResource
    {
        /// <summary>
        /// A [Confluent Resource Name (CRN)](https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)) that specifies the scope and resource patterns necessary for the role to bind.
        /// </summary>
        [Output("crnPattern")]
        public Output<string> CrnPattern { get; private set; } = null!;

        /// <summary>
        /// An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `False`.
        /// 
        /// !&gt; **Warning:** When `DisableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
        /// For example, if you're creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
        /// This setting is best suited for scenarios where you're provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
        /// 
        /// &gt; **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
        /// 
        /// &gt; **Note:** You can also use `TimeSleep` resource of HashiCorp's `Time` TF provider to configure a custom waiting period, see this example for more details.
        /// </summary>
        [Output("disableWaitForReady")]
        public Output<bool?> DisableWaitForReady { get; private set; } = null!;

        /// <summary>
        /// A principal User to bind the role to, for example, "User:u-111aaa" for binding to a user "u-111aaa", or "User:sa-111aaa" for binding to a service account "sa-111aaa".
        /// </summary>
        [Output("principal")]
        public Output<string> Principal { get; private set; } = null!;

        /// <summary>
        /// A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
        /// </summary>
        [Output("roleName")]
        public Output<string> RoleName { get; private set; } = null!;


        /// <summary>
        /// Create a RoleBinding resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public RoleBinding(string name, RoleBindingArgs args, CustomResourceOptions? options = null)
            : base("confluentcloud:index/roleBinding:RoleBinding", name, args ?? new RoleBindingArgs(), MakeResourceOptions(options, ""))
        {
        }

        private RoleBinding(string name, Input<string> id, RoleBindingState? state = null, CustomResourceOptions? options = null)
            : base("confluentcloud:index/roleBinding:RoleBinding", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing RoleBinding resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static RoleBinding Get(string name, Input<string> id, RoleBindingState? state = null, CustomResourceOptions? options = null)
        {
            return new RoleBinding(name, id, state, options);
        }
    }

    public sealed class RoleBindingArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// A [Confluent Resource Name (CRN)](https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)) that specifies the scope and resource patterns necessary for the role to bind.
        /// </summary>
        [Input("crnPattern", required: true)]
        public Input<string> CrnPattern { get; set; } = null!;

        /// <summary>
        /// An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `False`.
        /// 
        /// !&gt; **Warning:** When `DisableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
        /// For example, if you're creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
        /// This setting is best suited for scenarios where you're provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
        /// 
        /// &gt; **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
        /// 
        /// &gt; **Note:** You can also use `TimeSleep` resource of HashiCorp's `Time` TF provider to configure a custom waiting period, see this example for more details.
        /// </summary>
        [Input("disableWaitForReady")]
        public Input<bool>? DisableWaitForReady { get; set; }

        /// <summary>
        /// A principal User to bind the role to, for example, "User:u-111aaa" for binding to a user "u-111aaa", or "User:sa-111aaa" for binding to a service account "sa-111aaa".
        /// </summary>
        [Input("principal", required: true)]
        public Input<string> Principal { get; set; } = null!;

        /// <summary>
        /// A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
        /// </summary>
        [Input("roleName", required: true)]
        public Input<string> RoleName { get; set; } = null!;

        public RoleBindingArgs()
        {
        }
        public static new RoleBindingArgs Empty => new RoleBindingArgs();
    }

    public sealed class RoleBindingState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// A [Confluent Resource Name (CRN)](https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)) that specifies the scope and resource patterns necessary for the role to bind.
        /// </summary>
        [Input("crnPattern")]
        public Input<string>? CrnPattern { get; set; }

        /// <summary>
        /// An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `False`.
        /// 
        /// !&gt; **Warning:** When `DisableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
        /// For example, if you're creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
        /// This setting is best suited for scenarios where you're provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
        /// 
        /// &gt; **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
        /// 
        /// &gt; **Note:** You can also use `TimeSleep` resource of HashiCorp's `Time` TF provider to configure a custom waiting period, see this example for more details.
        /// </summary>
        [Input("disableWaitForReady")]
        public Input<bool>? DisableWaitForReady { get; set; }

        /// <summary>
        /// A principal User to bind the role to, for example, "User:u-111aaa" for binding to a user "u-111aaa", or "User:sa-111aaa" for binding to a service account "sa-111aaa".
        /// </summary>
        [Input("principal")]
        public Input<string>? Principal { get; set; }

        /// <summary>
        /// A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
        /// </summary>
        [Input("roleName")]
        public Input<string>? RoleName { get; set; }

        public RoleBindingState()
        {
        }
        public static new RoleBindingState Empty => new RoleBindingState();
    }
}
