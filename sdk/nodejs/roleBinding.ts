// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](https://docs.confluent.io/cloud/current/api.html#section/Versioning/API-Lifecycle-Policy)
 *
 * `confluentcloud.RoleBinding` provides a Role Binding resource that enables creating, reading, and deleting role bindings on Confluent Cloud.
 *
 * > **Note:** For more information on the Role Bindings, see [Predefined RBAC roles in Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/access-control/rbac/predefined-rbac-roles.html).
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as confluentcloud from "@pulumi/confluentcloud";
 * import * as std from "@pulumi/std";
 *
 * const org_example_rb = new confluentcloud.RoleBinding("org-example-rb", {
 *     principal: `User:${test.id}`,
 *     roleName: "MetricsViewer",
 *     crnPattern: demo.resourceName,
 * });
 * const environment_example_rb = new confluentcloud.RoleBinding("environment-example-rb", {
 *     principal: `User:${test.id}`,
 *     roleName: "EnvironmentAdmin",
 *     crnPattern: stag.resourceName,
 * });
 * const environment_example_rb_skip_sync = new confluentcloud.RoleBinding("environment-example-rb-skip-sync", {
 *     principal: `User:${test.id}`,
 *     roleName: "EnvironmentAdmin",
 *     crnPattern: stag.resourceName,
 *     disableWaitForReady: true,
 * });
 * const environment_example_rb_2 = new confluentcloud.RoleBinding("environment-example-rb-2", {
 *     principal: `User:${testConfluentIdentityPool.id}`,
 *     roleName: "EnvironmentAdmin",
 *     crnPattern: stag.resourceName,
 * });
 * const data_discovery_example_rb = new confluentcloud.RoleBinding("data-discovery-example-rb", {
 *     principal: `User:${test.id}`,
 *     roleName: "DataDiscovery",
 *     crnPattern: stag.resourceName,
 * });
 * const network_example_rb = new confluentcloud.RoleBinding("network-example-rb", {
 *     principal: `User:${test.id}`,
 *     roleName: "NetworkAdmin",
 *     crnPattern: demo.resourceName,
 * });
 * const cluster_example_rb = new confluentcloud.RoleBinding("cluster-example-rb", {
 *     principal: `User:${test.id}`,
 *     roleName: "CloudClusterAdmin",
 *     crnPattern: basic.rbacCrn,
 * });
 * const topic_example_rb = new confluentcloud.RoleBinding("topic-example-rb", {
 *     principal: `User:${test.id}`,
 *     roleName: "DeveloperWrite",
 *     crnPattern: `${standard.rbacCrn}/kafka=${standard.id}/topic=${orders.topicName}`,
 * });
 * const topic_example_rb_2 = new confluentcloud.RoleBinding("topic-example-rb-2", {
 *     principal: `User:${testConfluentIdentityPool.id}`,
 *     roleName: "DeveloperWrite",
 *     crnPattern: `${standard.rbacCrn}/kafka=${standard.id}/topic=${orders.topicName}`,
 * });
 * const group_example_rb = new confluentcloud.RoleBinding("group-example-rb", {
 *     principal: `User:${test.id}`,
 *     roleName: "DeveloperRead",
 *     crnPattern: `${basic.rbacCrn}/kafka=${standard.id}/group=confluent_cli_consumer_*`,
 * });
 * const group_mapping_example_rb = new confluentcloud.RoleBinding("group-mapping-example-rb", {
 *     principal: `User:${application_developers.id}`,
 *     roleName: "EnvironmentAdmin",
 *     crnPattern: stag.resourceName,
 * });
 * const transaction_example_rb = new confluentcloud.RoleBinding("transaction-example-rb", {
 *     principal: `User:${test.id}`,
 *     roleName: "DeveloperRead",
 *     crnPattern: `${basic.rbacCrn}/kafka=${standard.id}/transactional-id=my_transaction`,
 * });
 * const connectorName = std.index.lookup({
 *     map: testConfluentConnector.configNonsensitive,
 *     key: "name",
 *     "default": "\"name\" attribute is missing",
 * }).result;
 * const connector_example_rb = new confluentcloud.RoleBinding("connector-example-rb", {
 *     principal: `User:${test.id}`,
 *     roleName: "DeveloperRead",
 *     crnPattern: `${standard.rbacCrn}/connector=${connectorName}`,
 * });
 * const all_subjects_example_rb = new confluentcloud.RoleBinding("all-subjects-example-rb", {
 *     principal: `User:${test.id}`,
 *     roleName: "DeveloperRead",
 *     crnPattern: `${example.resourceName}/subject=*`,
 * });
 * const subject_foo_example_rb = new confluentcloud.RoleBinding("subject-foo-example-rb", {
 *     principal: `User:${test.id}`,
 *     roleName: "DeveloperRead",
 *     crnPattern: `${example.resourceName}/subject=foo`,
 * });
 * const subject_with_abc_prefix_example_rb = new confluentcloud.RoleBinding("subject-with-abc-prefix-example-rb", {
 *     principal: `User:${test.id}`,
 *     roleName: "DeveloperRead",
 *     crnPattern: `${example.resourceName}/subject=abc*`,
 * });
 * const kek_example_rb = new confluentcloud.RoleBinding("kek-example-rb", {
 *     principal: `User:${test.id}`,
 *     roleName: "DeveloperRead",
 *     crnPattern: `${example.resourceName}/kek=kek-name`,
 * });
 * ```
 *
 * ## Getting Started
 *
 * The following end-to-end examples might help to get started with `confluentcloud.RoleBinding` resource:
 *   * standard-kafka-rbac: _Standard_ Kafka cluster with authorization using RBAC
 *   * dedicated-public-kafka-rbac: _Dedicated_ Kafka cluster that is accessible over the public internet with authorization using RBAC
 *   * dedicated-privatelink-aws-kafka-rbac: _Dedicated_ Kafka cluster on AWS that is accessible via PrivateLink connections with authorization using RBAC
 *   * dedicated-privatelink-azure-kafka-rbac: _Dedicated_ Kafka cluster on Azure that is accessible via PrivateLink connections with authorization using RBAC
 *   * dedicated-vnet-peering-azure-kafka-rbac: _Dedicated_ Kafka cluster on Azure that is accessible via VPC Peering connections with authorization using RBAC
 *   * dedicated-vpc-peering-aws-kafka-rbac: _Dedicated_ Kafka cluster on AWS that is accessible via VPC Peering connections with authorization using RBAC
 *   * dedicated-vpc-peering-gcp-kafka-rbac: _Dedicated_ Kafka cluster on GCP that is accessible via VPC Peering connections with authorization using RBAC
 *   * dedicated-transit-gateway-attachment-aws-kafka-acls: _Dedicated_ Kafka cluster on AWS that is accessible via Transit Gateway Endpoint with authorization using ACLs
 *   * dedicated-transit-gateway-attachment-aws-kafka-rbac: _Dedicated_ Kafka cluster on AWS that is accessible via Transit Gateway Endpoint with authorization using RBAC
 *   * enterprise-privatelinkattachment-aws-kafka-acls: _Enterprise_ Kafka cluster on AWS that is accessible via PrivateLink connections with authorization using ACLs
 *
 * ## Example of using timeSleep
 *
 * This configuration introduces a 360-second custom delay after the creation of a role binding, before creating a Kafka topic.
 *
 * For context, using `disableWaitForReady = false` (the default setting) results in a 90-second hardcoded delay, while opting for `disableWaitForReady = true` results in a 0-second delay.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as confluentcloud from "@pulumi/confluentcloud";
 * import * as time from "@pulumi/time";
 *
 * const app_manager_kafka_cluster_admin_skip_sync = new confluentcloud.RoleBinding("app-manager-kafka-cluster-admin-skip-sync", {
 *     principal: `User:${app_manager.id}`,
 *     roleName: "CloudClusterAdmin",
 *     crnPattern: standard.rbacCrn,
 *     disableWaitForReady: true,
 * });
 * const wait360SecondsAfterRoleBinding = new time.index.Sleep("wait_360_seconds_after_role_binding", {createDuration: "360s"}, {
 *     dependsOn: [app_manager_kafka_cluster_admin_skip_sync],
 * });
 * const orders = new confluentcloud.KafkaTopic("orders", {
 *     kafkaCluster: {
 *         id: standard.id,
 *     },
 *     topicName: "orders",
 *     restEndpoint: standard.restEndpoint,
 *     credentials: {
 *         key: app_manager_kafka_api_key.id,
 *         secret: app_manager_kafka_api_key.secret,
 *     },
 * }, {
 *     dependsOn: [wait360SecondsAfterRoleBinding],
 * });
 * ```
 *
 * ## Import
 *
 * > **Note:** `CONFLUENT_CLOUD_API_KEY` and `CONFLUENT_CLOUD_API_SECRET` environment variables must be set before importing a Role Binding.
 *
 * You can import a Role Binding by using Role Binding ID, for example:
 *
 * ```sh
 * $ export CONFLUENT_CLOUD_API_KEY="<cloud_api_key>"
 * $ export CONFLUENT_CLOUD_API_SECRET="<cloud_api_secret>"
 * $ pulumi import confluentcloud:index/roleBinding:RoleBinding my_rb rb-f3a90de
 * ```
 *
 * !> **Warning:** Do not forget to delete terminal command history afterwards for security purposes.
 */
export class RoleBinding extends pulumi.CustomResource {
    /**
     * Get an existing RoleBinding resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: RoleBindingState, opts?: pulumi.CustomResourceOptions): RoleBinding {
        return new RoleBinding(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'confluentcloud:index/roleBinding:RoleBinding';

    /**
     * Returns true if the given object is an instance of RoleBinding.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is RoleBinding {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === RoleBinding.__pulumiType;
    }

    /**
     * A [Confluent Resource Name (CRN)](https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)) that specifies the scope and resource patterns necessary for the role to bind.
     */
    declare public readonly crnPattern: pulumi.Output<string>;
    /**
     * An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `false`.
     *
     * !> **Warning:** When `disableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
     * For example, if you're creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
     * This setting is best suited for scenarios where you're provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
     *
     * > **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
     *
     * > **Note:** You can also use `timeSleep` resource of HashiCorp's `time` TF provider to configure a custom waiting period, see this example for more details.
     */
    declare public readonly disableWaitForReady: pulumi.Output<boolean | undefined>;
    /**
     * A principal User to bind the role to, for example, "User:u-111aaa" for binding to a user "u-111aaa", or "User:sa-111aaa" for binding to a service account "sa-111aaa".
     */
    declare public readonly principal: pulumi.Output<string>;
    /**
     * A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
     */
    declare public readonly roleName: pulumi.Output<string>;

    /**
     * Create a RoleBinding resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: RoleBindingArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: RoleBindingArgs | RoleBindingState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as RoleBindingState | undefined;
            resourceInputs["crnPattern"] = state?.crnPattern;
            resourceInputs["disableWaitForReady"] = state?.disableWaitForReady;
            resourceInputs["principal"] = state?.principal;
            resourceInputs["roleName"] = state?.roleName;
        } else {
            const args = argsOrState as RoleBindingArgs | undefined;
            if (args?.crnPattern === undefined && !opts.urn) {
                throw new Error("Missing required property 'crnPattern'");
            }
            if (args?.principal === undefined && !opts.urn) {
                throw new Error("Missing required property 'principal'");
            }
            if (args?.roleName === undefined && !opts.urn) {
                throw new Error("Missing required property 'roleName'");
            }
            resourceInputs["crnPattern"] = args?.crnPattern;
            resourceInputs["disableWaitForReady"] = args?.disableWaitForReady;
            resourceInputs["principal"] = args?.principal;
            resourceInputs["roleName"] = args?.roleName;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(RoleBinding.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering RoleBinding resources.
 */
export interface RoleBindingState {
    /**
     * A [Confluent Resource Name (CRN)](https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)) that specifies the scope and resource patterns necessary for the role to bind.
     */
    crnPattern?: pulumi.Input<string>;
    /**
     * An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `false`.
     *
     * !> **Warning:** When `disableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
     * For example, if you're creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
     * This setting is best suited for scenarios where you're provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
     *
     * > **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
     *
     * > **Note:** You can also use `timeSleep` resource of HashiCorp's `time` TF provider to configure a custom waiting period, see this example for more details.
     */
    disableWaitForReady?: pulumi.Input<boolean>;
    /**
     * A principal User to bind the role to, for example, "User:u-111aaa" for binding to a user "u-111aaa", or "User:sa-111aaa" for binding to a service account "sa-111aaa".
     */
    principal?: pulumi.Input<string>;
    /**
     * A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
     */
    roleName?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a RoleBinding resource.
 */
export interface RoleBindingArgs {
    /**
     * A [Confluent Resource Name (CRN)](https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)) that specifies the scope and resource patterns necessary for the role to bind.
     */
    crnPattern: pulumi.Input<string>;
    /**
     * An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `false`.
     *
     * !> **Warning:** When `disableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
     * For example, if you're creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
     * This setting is best suited for scenarios where you're provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
     *
     * > **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
     *
     * > **Note:** You can also use `timeSleep` resource of HashiCorp's `time` TF provider to configure a custom waiting period, see this example for more details.
     */
    disableWaitForReady?: pulumi.Input<boolean>;
    /**
     * A principal User to bind the role to, for example, "User:u-111aaa" for binding to a user "u-111aaa", or "User:sa-111aaa" for binding to a service account "sa-111aaa".
     */
    principal: pulumi.Input<string>;
    /**
     * A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
     */
    roleName: pulumi.Input<string>;
}
