// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](https://docs.confluent.io/cloud/current/api.html#section/Versioning/API-Lifecycle-Policy)
 *
 * `confluentcloud.ApiKey` provides an API Key resource that enables creating, editing, and deleting Cloud API Keys, Cluster API Keys (Kafka API Key, ksqlDB API Key, Schema Registry API Key, Flink API Key, Tableflow API Key) on Confluent Cloud.
 *
 * > **Note:** It is recommended to set `lifecycle { preventDestroy = true }` on production instances to prevent accidental API Key deletion. This setting rejects plans that would destroy or recreate the API Key, such as attempting to change uneditable attributes. Read more about it in the Terraform docs.
 *
 * ## Example Usage
 *
 * ### Example Kafka API Key
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as confluentcloud from "@pulumi/confluentcloud";
 *
 * const app_manager_kafka_api_key = new confluentcloud.ApiKey("app-manager-kafka-api-key", {
 *     displayName: "app-manager-kafka-api-key",
 *     description: "Kafka API Key that is owned by 'app-manager' service account",
 *     owner: {
 *         id: app_manager.id,
 *         apiVersion: app_manager.apiVersion,
 *         kind: app_manager.kind,
 *     },
 *     managedResource: {
 *         id: basic.id,
 *         apiVersion: basic.apiVersion,
 *         kind: basic.kind,
 *         environments: [{
 *             id: staging.id,
 *         }],
 *     },
 * });
 * ```
 *
 * ### Example ksqlDB API Key
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as confluentcloud from "@pulumi/confluentcloud";
 *
 * const ksqldb_api_key = new confluentcloud.ApiKey("ksqldb-api-key", {
 *     displayName: "ksqldb-api-key",
 *     description: "KsqlDB API Key that is owned by 'app-manager' service account",
 *     owner: {
 *         id: app_manager.id,
 *         apiVersion: app_manager.apiVersion,
 *         kind: app_manager.kind,
 *     },
 *     managedResource: {
 *         id: main.id,
 *         apiVersion: main.apiVersion,
 *         kind: main.kind,
 *         environments: [{
 *             id: staging.id,
 *         }],
 *     },
 * });
 * ```
 *
 * ### Example Schema Registry API Key
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as confluentcloud from "@pulumi/confluentcloud";
 *
 * const env_manager_schema_registry_api_key = new confluentcloud.ApiKey("env-manager-schema-registry-api-key", {
 *     displayName: "env-manager-schema-registry-api-key",
 *     description: "Schema Registry API Key that is owned by 'env-manager' service account",
 *     owner: {
 *         id: env_manager.id,
 *         apiVersion: env_manager.apiVersion,
 *         kind: env_manager.kind,
 *     },
 *     managedResource: {
 *         id: essentials.id,
 *         apiVersion: essentials.apiVersion,
 *         kind: essentials.kind,
 *         environments: [{
 *             id: staging.id,
 *         }],
 *     },
 * });
 * ```
 *
 * ### Example Flink API Key
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as confluentcloud from "@pulumi/confluentcloud";
 *
 * const env_manager_flink_api_key = new confluentcloud.ApiKey("env-manager-flink-api-key", {
 *     displayName: "env-manager-flink-api-key",
 *     description: "Flink API Key that is owned by 'env-manager' service account",
 *     owner: {
 *         id: env_manager.id,
 *         apiVersion: env_manager.apiVersion,
 *         kind: env_manager.kind,
 *     },
 *     managedResource: {
 *         id: example.id,
 *         apiVersion: example.apiVersion,
 *         kind: example.kind,
 *         environments: [{
 *             id: staging.id,
 *         }],
 *     },
 * });
 * ```
 *
 * ### Example Tableflow API Key
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as confluentcloud from "@pulumi/confluentcloud";
 *
 * const env_manager_tableflow_api_key = new confluentcloud.ApiKey("env-manager-tableflow-api-key", {
 *     displayName: "env-manager-tableflow-api-key",
 *     description: "Tableflow API Key that is owned by 'env-manager' service account",
 *     owner: {
 *         id: env_manager.id,
 *         apiVersion: env_manager.apiVersion,
 *         kind: env_manager.kind,
 *     },
 *     managedResource: {
 *         id: "tableflow",
 *         apiVersion: "tableflow/v1",
 *         kind: "Tableflow",
 *     },
 * });
 * ```
 *
 * ### Example Cloud API Key
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as confluentcloud from "@pulumi/confluentcloud";
 *
 * const env_manager_cloud_api_key = new confluentcloud.ApiKey("env-manager-cloud-api-key", {
 *     displayName: "env-manager-cloud-api-key",
 *     description: "Cloud API Key that is owned by 'env-manager' service account",
 *     owner: {
 *         id: env_manager.id,
 *         apiVersion: env_manager.apiVersion,
 *         kind: env_manager.kind,
 *     },
 * });
 * ```
 *
 * ## Getting Started
 *
 * The following end-to-end examples might help to get started with `confluentcloud.ApiKey` resource:
 *   * basic-kafka-acls: _Basic_ Kafka cluster with authorization using ACLs
 *   * basic-kafka-acls-with-alias: _Basic_ Kafka cluster with authorization using ACLs
 *   * standard-kafka-acls: _Standard_ Kafka cluster with authorization using ACLs
 *   * standard-kafka-rbac: _Standard_ Kafka cluster with authorization using RBAC
 *   * dedicated-public-kafka-acls: _Dedicated_ Kafka cluster that is accessible over the public internet with authorization using ACLs
 *   * dedicated-public-kafka-rbac: _Dedicated_ Kafka cluster that is accessible over the public internet with authorization using RBAC
 *   * dedicated-privatelink-aws-kafka-acls: _Dedicated_ Kafka cluster on AWS that is accessible via PrivateLink connections with authorization using ACLs
 *   * dedicated-privatelink-aws-kafka-rbac: _Dedicated_ Kafka cluster on AWS that is accessible via PrivateLink connections with authorization using RBAC
 *   * dedicated-privatelink-azure-kafka-rbac: _Dedicated_ Kafka cluster on Azure that is accessible via PrivateLink connections with authorization using RBAC
 *   * dedicated-privatelink-azure-kafka-acls: _Dedicated_ Kafka cluster on Azure that is accessible via PrivateLink connections with authorization using ACLs
 *   * dedicated-private-service-connect-gcp-kafka-acls: _Dedicated_ Kafka cluster on GCP that is accessible via Private Service Connect connections with authorization using ACLs
 *   * dedicated-private-service-connect-gcp-kafka-rbac: _Dedicated_ Kafka cluster on GCP that is accessible via Private Service Connect connections with authorization using RBAC
 *   * dedicated-vnet-peering-azure-kafka-acls: _Dedicated_ Kafka cluster on Azure that is accessible via VPC Peering connections with authorization using ACLs
 *   * dedicated-vnet-peering-azure-kafka-rbac: _Dedicated_ Kafka cluster on Azure that is accessible via VPC Peering connections with authorization using RBAC
 *   * dedicated-vpc-peering-aws-kafka-acls: _Dedicated_ Kafka cluster on AWS that is accessible via VPC Peering connections with authorization using ACLs
 *   * dedicated-vpc-peering-aws-kafka-rbac: _Dedicated_ Kafka cluster on AWS that is accessible via VPC Peering connections with authorization using RBAC
 *   * dedicated-vpc-peering-gcp-kafka-acls: _Dedicated_ Kafka cluster on GCP that is accessible via VPC Peering connections with authorization using ACLs
 *   * dedicated-vpc-peering-gcp-kafka-rbac: _Dedicated_ Kafka cluster on GCP that is accessible via VPC Peering connections with authorization using RBAC
 *   * dedicated-transit-gateway-attachment-aws-kafka-acls: _Dedicated_ Kafka cluster on AWS that is accessible via Transit Gateway Endpoint with authorization using ACLs
 *   * dedicated-transit-gateway-attachment-aws-kafka-rbac: _Dedicated_ Kafka cluster on AWS that is accessible via Transit Gateway Endpoint with authorization using RBAC
 *   * enterprise-privatelinkattachment-aws-kafka-acls: _Enterprise_ Kafka cluster on AWS that is accessible via PrivateLink connections with authorization using ACLs
 *
 * ## Import
 *
 * > **Note:** You must set the `API_KEY_SECRET` (`secret`) environment variable before importing an API Key.
 *
 * You can import a Cluster API Key by using the Environment ID and Cluster API Key ID in the format `<Environment ID>/<Cluster API Key ID>`, for example:
 *
 * ```sh
 * $ export CONFLUENT_CLOUD_API_KEY="<cloud_api_key>"
 * $ export CONFLUENT_CLOUD_API_SECRET="<cloud_api_secret>"
 * $ export API_KEY_SECRET="<api_key_secret>"
 * ```
 *
 * Option #1: Cluster API Key
 *
 * ```sh
 * $ pulumi import confluentcloud:index/apiKey:ApiKey example_kafka_api_key "env-abc123/UTT6WDRXX7FHD2GV"
 * ```
 *
 * You can import a Cloud or Tableflow API Key by using Cloud or Tableflow API Key ID, for example:
 *
 * ```sh
 * $ export CONFLUENT_CLOUD_API_KEY="<cloud_api_key>"
 * $ export CONFLUENT_CLOUD_API_SECRET="<cloud_api_secret>"
 * $ export API_KEY_SECRET="<api_key_secret>"
 * ```
 *
 * Option #2: Cloud or Tableflow API Key
 *
 * ```sh
 * $ pulumi import confluentcloud:index/apiKey:ApiKey example_cloud_api_key "4UEXOMMWIBE5KZQG"
 * ```
 *
 * !> **Warning:** Do not forget to delete terminal command history afterwards for security purposes.
 */
export class ApiKey extends pulumi.CustomResource {
    /**
     * Get an existing ApiKey resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ApiKeyState, opts?: pulumi.CustomResourceOptions): ApiKey {
        return new ApiKey(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'confluentcloud:index/apiKey:ApiKey';

    /**
     * Returns true if the given object is an instance of ApiKey.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ApiKey {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ApiKey.__pulumiType;
    }

    /**
     * A free-form description of the API Account.
     */
    declare public readonly description: pulumi.Output<string | undefined>;
    /**
     * An optional flag to disable wait-for-readiness on create. Its primary use case is for Cluster API Keys for private networking options when readiness check fails. Must be unset when importing. Defaults to `false`.
     */
    declare public readonly disableWaitForReady: pulumi.Output<boolean | undefined>;
    /**
     * A human-readable name for the API Key.
     */
    declare public readonly displayName: pulumi.Output<string>;
    /**
     * The resource associated with this object. The only resource that is supported is 'cmk.v2.Cluster', 'srcm.v2.Cluster', 'srcm.v3.Cluster'.
     */
    declare public readonly managedResource: pulumi.Output<outputs.ApiKeyManagedResource | undefined>;
    /**
     * The owner to which the API Key belongs. The owner can be one of 'iam.v2.User', 'iam.v2.ServiceAccount'.
     */
    declare public readonly owner: pulumi.Output<outputs.ApiKeyOwner>;
    /**
     * (Required String, Sensitive) The secret of the API Key.
     */
    declare public /*out*/ readonly secret: pulumi.Output<string>;

    /**
     * Create a ApiKey resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ApiKeyArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ApiKeyArgs | ApiKeyState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ApiKeyState | undefined;
            resourceInputs["description"] = state?.description;
            resourceInputs["disableWaitForReady"] = state?.disableWaitForReady;
            resourceInputs["displayName"] = state?.displayName;
            resourceInputs["managedResource"] = state?.managedResource;
            resourceInputs["owner"] = state?.owner;
            resourceInputs["secret"] = state?.secret;
        } else {
            const args = argsOrState as ApiKeyArgs | undefined;
            if (args?.owner === undefined && !opts.urn) {
                throw new Error("Missing required property 'owner'");
            }
            resourceInputs["description"] = args?.description;
            resourceInputs["disableWaitForReady"] = args?.disableWaitForReady;
            resourceInputs["displayName"] = args?.displayName;
            resourceInputs["managedResource"] = args?.managedResource;
            resourceInputs["owner"] = args?.owner;
            resourceInputs["secret"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["secret"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(ApiKey.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering ApiKey resources.
 */
export interface ApiKeyState {
    /**
     * A free-form description of the API Account.
     */
    description?: pulumi.Input<string>;
    /**
     * An optional flag to disable wait-for-readiness on create. Its primary use case is for Cluster API Keys for private networking options when readiness check fails. Must be unset when importing. Defaults to `false`.
     */
    disableWaitForReady?: pulumi.Input<boolean>;
    /**
     * A human-readable name for the API Key.
     */
    displayName?: pulumi.Input<string>;
    /**
     * The resource associated with this object. The only resource that is supported is 'cmk.v2.Cluster', 'srcm.v2.Cluster', 'srcm.v3.Cluster'.
     */
    managedResource?: pulumi.Input<inputs.ApiKeyManagedResource>;
    /**
     * The owner to which the API Key belongs. The owner can be one of 'iam.v2.User', 'iam.v2.ServiceAccount'.
     */
    owner?: pulumi.Input<inputs.ApiKeyOwner>;
    /**
     * (Required String, Sensitive) The secret of the API Key.
     */
    secret?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a ApiKey resource.
 */
export interface ApiKeyArgs {
    /**
     * A free-form description of the API Account.
     */
    description?: pulumi.Input<string>;
    /**
     * An optional flag to disable wait-for-readiness on create. Its primary use case is for Cluster API Keys for private networking options when readiness check fails. Must be unset when importing. Defaults to `false`.
     */
    disableWaitForReady?: pulumi.Input<boolean>;
    /**
     * A human-readable name for the API Key.
     */
    displayName?: pulumi.Input<string>;
    /**
     * The resource associated with this object. The only resource that is supported is 'cmk.v2.Cluster', 'srcm.v2.Cluster', 'srcm.v3.Cluster'.
     */
    managedResource?: pulumi.Input<inputs.ApiKeyManagedResource>;
    /**
     * The owner to which the API Key belongs. The owner can be one of 'iam.v2.User', 'iam.v2.ServiceAccount'.
     */
    owner: pulumi.Input<inputs.ApiKeyOwner>;
}
