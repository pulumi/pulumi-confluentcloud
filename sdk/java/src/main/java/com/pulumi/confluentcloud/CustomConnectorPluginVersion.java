// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.confluentcloud;

import com.pulumi.confluentcloud.CustomConnectorPluginVersionArgs;
import com.pulumi.confluentcloud.Utilities;
import com.pulumi.confluentcloud.inputs.CustomConnectorPluginVersionState;
import com.pulumi.confluentcloud.outputs.CustomConnectorPluginVersionConnectorClass;
import com.pulumi.confluentcloud.outputs.CustomConnectorPluginVersionEnvironment;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * ## Example Usage
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.confluentcloud.CustomConnectorPluginVersion;
 * import com.pulumi.confluentcloud.CustomConnectorPluginVersionArgs;
 * import com.pulumi.confluentcloud.inputs.CustomConnectorPluginVersionConnectorClassArgs;
 * import com.pulumi.confluentcloud.inputs.CustomConnectorPluginVersionEnvironmentArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var source = new CustomConnectorPluginVersion("source", CustomConnectorPluginVersionArgs.builder()
 *             .version("v1.2.4")
 *             .cloud("AWS")
 *             .documentationLink("https://www.confluent.io/hub/confluentinc/kafka-connect-datagen")
 *             .connectorClasses(CustomConnectorPluginVersionConnectorClassArgs.builder()
 *                 .connectorClassName("io.confluent.kafka.connect.datagen.DatagenConnector")
 *                 .connectorType("SOURCE")
 *                 .build())
 *             .sensitiveConfigProperties()
 *             .filename("confluentinc-kafka-connect-datagen-0.6.2.zip")
 *             .pluginId("ccp-dev-123")
 *             .environment(CustomConnectorPluginVersionEnvironmentArgs.builder()
 *                 .id("env-devc0k7oxp")
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(plugin)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * You can import a Custom Connector Plugin by using a Custom Connector Plugin ID, in the format `&lt;Environment ID&gt;/&lt;Plugin ID&gt;/&lt;Version ID&gt;`. The following example shows how to import a Custom Connector Plugin:
 * 
 * $ export CONFLUENT_CLOUD_API_KEY=&#34;&lt;cloud_api_key&gt;&#34;
 * 
 * $ export CONFLUENT_CLOUD_API_SECRET=&#34;&lt;cloud_api_secret&gt;&#34;
 * 
 * ```sh
 * $ pulumi import confluentcloud:index/customConnectorPluginVersion:CustomConnectorPluginVersion main env-123/plug-123/ccp-ver123xyz
 * ```
 * 
 * !&gt; **Warning:** Do not forget to delete terminal command history afterwards for security purposes.
 * 
 */
@ResourceType(type="confluentcloud:index/customConnectorPluginVersion:CustomConnectorPluginVersion")
public class CustomConnectorPluginVersion extends com.pulumi.resources.CustomResource {
    /**
     * (Required String) The API Version of the schema version of the plugin version, for example, `ccpm/v1`.
     * 
     */
    @Export(name="apiVersion", refs={String.class}, tree="[0]")
    private Output<String> apiVersion;

    /**
     * @return (Required String) The API Version of the schema version of the plugin version, for example, `ccpm/v1`.
     * 
     */
    public Output<String> apiVersion() {
        return this.apiVersion;
    }
    /**
     * Cloud provider where the Custom Connector Plugin Version archive is uploaded. Accepted values are: `AWS`, `AZURE`, `GCP`.
     * 
     */
    @Export(name="cloud", refs={String.class}, tree="[0]")
    private Output<String> cloud;

    /**
     * @return Cloud provider where the Custom Connector Plugin Version archive is uploaded. Accepted values are: `AWS`, `AZURE`, `GCP`.
     * 
     */
    public Output<String> cloud() {
        return this.cloud;
    }
    /**
     * The Java class name or alias for the connector. You can get the connector class from the connector documentation provided by the developer.
     * 
     */
    @Export(name="connectorClasses", refs={List.class,CustomConnectorPluginVersionConnectorClass.class}, tree="[0,1]")
    private Output<List<CustomConnectorPluginVersionConnectorClass>> connectorClasses;

    /**
     * @return The Java class name or alias for the connector. You can get the connector class from the connector documentation provided by the developer.
     * 
     */
    public Output<List<CustomConnectorPluginVersionConnectorClass>> connectorClasses() {
        return this.connectorClasses;
    }
    /**
     * The documentation link of the Custom Connector Plugin Version.
     * 
     */
    @Export(name="documentationLink", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> documentationLink;

    /**
     * @return The documentation link of the Custom Connector Plugin Version.
     * 
     */
    public Output<Optional<String>> documentationLink() {
        return Codegen.optional(this.documentationLink);
    }
    /**
     * Environment objects represent an isolated namespace for your Confluent resources for organizational purposes.
     * 
     */
    @Export(name="environment", refs={CustomConnectorPluginVersionEnvironment.class}, tree="[0]")
    private Output<CustomConnectorPluginVersionEnvironment> environment;

    /**
     * @return Environment objects represent an isolated namespace for your Confluent resources for organizational purposes.
     * 
     */
    public Output<CustomConnectorPluginVersionEnvironment> environment() {
        return this.environment;
    }
    /**
     * The path to the Custom Connector Plugin Version archive to be uploaded. Accepted archive formats are: `.jar`, `.zip`.
     * 
     */
    @Export(name="filename", refs={String.class}, tree="[0]")
    private Output<String> filename;

    /**
     * @return The path to the Custom Connector Plugin Version archive to be uploaded. Accepted archive formats are: `.jar`, `.zip`.
     * 
     */
    public Output<String> filename() {
        return this.filename;
    }
    /**
     * (Required String) The kind of the Plugin Version, for example, `CustomConnectPluginVersion`.
     * 
     */
    @Export(name="kind", refs={String.class}, tree="[0]")
    private Output<String> kind;

    /**
     * @return (Required String) The kind of the Plugin Version, for example, `CustomConnectPluginVersion`.
     * 
     */
    public Output<String> kind() {
        return this.kind;
    }
    /**
     * The ID of the plugin created using `confluentcloud.Plugin` resource, or through other ways.
     * 
     */
    @Export(name="pluginId", refs={String.class}, tree="[0]")
    private Output<String> pluginId;

    /**
     * @return The ID of the plugin created using `confluentcloud.Plugin` resource, or through other ways.
     * 
     */
    public Output<String> pluginId() {
        return this.pluginId;
    }
    /**
     * The list of sensitive properties. A sensitive property is a connector configuration property that must be hidden after a user enters the property value when setting up the connector, for example, passwords, keys, and tokens. Refer to the developer documentation and add all required and optional sensitive properties that a user could potentially configure for the connector. Marking a property as sensitive ensures that these fields are handled appropriately within the Confluent infrastructure. This includes masking fields, for example in exception logging, and encrypting field values in the underlying data store. You must identify all sensitive properties. Failure to identify sensitive properties can result in the sensitive property value being stored in plain text rather than in encrypted format. Only add connector-specific sensitive properties. Kafka keys, passwords, and service account information should not be entered here.
     * 
     */
    @Export(name="sensitiveConfigProperties", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> sensitiveConfigProperties;

    /**
     * @return The list of sensitive properties. A sensitive property is a connector configuration property that must be hidden after a user enters the property value when setting up the connector, for example, passwords, keys, and tokens. Refer to the developer documentation and add all required and optional sensitive properties that a user could potentially configure for the connector. Marking a property as sensitive ensures that these fields are handled appropriately within the Confluent infrastructure. This includes masking fields, for example in exception logging, and encrypting field values in the underlying data store. You must identify all sensitive properties. Failure to identify sensitive properties can result in the sensitive property value being stored in plain text rather than in encrypted format. Only add connector-specific sensitive properties. Kafka keys, passwords, and service account information should not be entered here.
     * 
     */
    public Output<Optional<List<String>>> sensitiveConfigProperties() {
        return Codegen.optional(this.sensitiveConfigProperties);
    }
    /**
     * The version number of the plugin version we want to create. This must start with the character `v` and follow semantic versioning.
     * 
     */
    @Export(name="version", refs={String.class}, tree="[0]")
    private Output<String> version;

    /**
     * @return The version number of the plugin version we want to create. This must start with the character `v` and follow semantic versioning.
     * 
     */
    public Output<String> version() {
        return this.version;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public CustomConnectorPluginVersion(java.lang.String name) {
        this(name, CustomConnectorPluginVersionArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public CustomConnectorPluginVersion(java.lang.String name, CustomConnectorPluginVersionArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public CustomConnectorPluginVersion(java.lang.String name, CustomConnectorPluginVersionArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("confluentcloud:index/customConnectorPluginVersion:CustomConnectorPluginVersion", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private CustomConnectorPluginVersion(java.lang.String name, Output<java.lang.String> id, @Nullable CustomConnectorPluginVersionState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("confluentcloud:index/customConnectorPluginVersion:CustomConnectorPluginVersion", name, state, makeResourceOptions(options, id), false);
    }

    private static CustomConnectorPluginVersionArgs makeArgs(CustomConnectorPluginVersionArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? CustomConnectorPluginVersionArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static CustomConnectorPluginVersion get(java.lang.String name, Output<java.lang.String> id, @Nullable CustomConnectorPluginVersionState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new CustomConnectorPluginVersion(name, id, state, options);
    }
}
