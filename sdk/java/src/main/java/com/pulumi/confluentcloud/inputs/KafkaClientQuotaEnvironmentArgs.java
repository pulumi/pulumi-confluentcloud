// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.confluentcloud.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.String;
import java.util.Objects;


public final class KafkaClientQuotaEnvironmentArgs extends com.pulumi.resources.ResourceArgs {

    public static final KafkaClientQuotaEnvironmentArgs Empty = new KafkaClientQuotaEnvironmentArgs();

    /**
     * The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.
     * 
     * &gt; **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.
     * 
     * &gt; **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
     * 
     */
    @Import(name="id", required=true)
    private Output<String> id;

    /**
     * @return The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.
     * 
     * &gt; **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.
     * 
     * &gt; **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
     * 
     */
    public Output<String> id() {
        return this.id;
    }

    private KafkaClientQuotaEnvironmentArgs() {}

    private KafkaClientQuotaEnvironmentArgs(KafkaClientQuotaEnvironmentArgs $) {
        this.id = $.id;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(KafkaClientQuotaEnvironmentArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private KafkaClientQuotaEnvironmentArgs $;

        public Builder() {
            $ = new KafkaClientQuotaEnvironmentArgs();
        }

        public Builder(KafkaClientQuotaEnvironmentArgs defaults) {
            $ = new KafkaClientQuotaEnvironmentArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param id The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.
         * 
         * &gt; **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.
         * 
         * &gt; **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
         * 
         * @return builder
         * 
         */
        public Builder id(Output<String> id) {
            $.id = id;
            return this;
        }

        /**
         * @param id The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.
         * 
         * &gt; **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.
         * 
         * &gt; **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
         * 
         * @return builder
         * 
         */
        public Builder id(String id) {
            return id(Output.of(id));
        }

        public KafkaClientQuotaEnvironmentArgs build() {
            $.id = Objects.requireNonNull($.id, "expected parameter 'id' to be non-null");
            return $;
        }
    }

}
