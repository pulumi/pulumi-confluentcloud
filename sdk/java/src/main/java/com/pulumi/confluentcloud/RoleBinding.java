// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.confluentcloud;

import com.pulumi.confluentcloud.RoleBindingArgs;
import com.pulumi.confluentcloud.Utilities;
import com.pulumi.confluentcloud.inputs.RoleBindingState;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.String;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](https://docs.confluent.io/cloud/current/api.html#section/Versioning/API-Lifecycle-Policy)
 * 
 * `confluentcloud.RoleBinding` provides a Role Binding resource that enables creating, reading, and deleting role bindings on Confluent Cloud.
 * 
 * &gt; **Note:** For more information on the Role Bindings, see [Predefined RBAC roles in Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/access-control/rbac/predefined-rbac-roles.html).
 * 
 * ## Example Usage
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.confluentcloud.RoleBinding;
 * import com.pulumi.confluentcloud.RoleBindingArgs;
 * import com.pulumi.std.StdFunctions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var org_example_rb = new RoleBinding("org-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("MetricsViewer")
 *             .crnPattern(demo.resourceName())
 *             .build());
 * 
 *         var environment_example_rb = new RoleBinding("environment-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("EnvironmentAdmin")
 *             .crnPattern(stag.resourceName())
 *             .build());
 * 
 *         var environment_example_rb_skip_sync = new RoleBinding("environment-example-rb-skip-sync", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("EnvironmentAdmin")
 *             .crnPattern(stag.resourceName())
 *             .disableWaitForReady(true)
 *             .build());
 * 
 *         var environment_example_rb_2 = new RoleBinding("environment-example-rb-2", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", testConfluentIdentityPool.id()))
 *             .roleName("EnvironmentAdmin")
 *             .crnPattern(stag.resourceName())
 *             .build());
 * 
 *         var data_discovery_example_rb = new RoleBinding("data-discovery-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("DataDiscovery")
 *             .crnPattern(stag.resourceName())
 *             .build());
 * 
 *         var network_example_rb = new RoleBinding("network-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("NetworkAdmin")
 *             .crnPattern(demo.resourceName())
 *             .build());
 * 
 *         var cluster_example_rb = new RoleBinding("cluster-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("CloudClusterAdmin")
 *             .crnPattern(basic.rbacCrn())
 *             .build());
 * 
 *         var topic_example_rb = new RoleBinding("topic-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("DeveloperWrite")
 *             .crnPattern(String.format("%s/kafka=%s/topic=%s", standard.rbacCrn(),standard.id(),orders.topicName()))
 *             .build());
 * 
 *         var topic_example_rb_2 = new RoleBinding("topic-example-rb-2", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", testConfluentIdentityPool.id()))
 *             .roleName("DeveloperWrite")
 *             .crnPattern(String.format("%s/kafka=%s/topic=%s", standard.rbacCrn(),standard.id(),orders.topicName()))
 *             .build());
 * 
 *         var group_example_rb = new RoleBinding("group-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("DeveloperRead")
 *             .crnPattern(String.format("%s/kafka=%s/group=confluent_cli_consumer_*", basic.rbacCrn(),standard.id()))
 *             .build());
 * 
 *         var group_mapping_example_rb = new RoleBinding("group-mapping-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", application_developers.id()))
 *             .roleName("EnvironmentAdmin")
 *             .crnPattern(stag.resourceName())
 *             .build());
 * 
 *         var transaction_example_rb = new RoleBinding("transaction-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("DeveloperRead")
 *             .crnPattern(String.format("%s/kafka=%s/transactional-id=my_transaction", basic.rbacCrn(),standard.id()))
 *             .build());
 * 
 *         final var connectorName = StdFunctions.lookup(Map.ofEntries(
 *             Map.entry("map", testConfluentConnector.configNonsensitive()),
 *             Map.entry("key", "name"),
 *             Map.entry("default", "\"name\" attribute is missing")
 *         )).result();
 * 
 *         var connector_example_rb = new RoleBinding("connector-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("DeveloperRead")
 *             .crnPattern(String.format("%s/connector=%s", standard.rbacCrn(),connectorName))
 *             .build());
 * 
 *         var all_subjects_example_rb = new RoleBinding("all-subjects-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("DeveloperRead")
 *             .crnPattern(String.format("%s/subject=*", example.resourceName()))
 *             .build());
 * 
 *         var subject_foo_example_rb = new RoleBinding("subject-foo-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("DeveloperRead")
 *             .crnPattern(String.format("%s/subject=foo", example.resourceName()))
 *             .build());
 * 
 *         var subject_with_abc_prefix_example_rb = new RoleBinding("subject-with-abc-prefix-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("DeveloperRead")
 *             .crnPattern(String.format("%s/subject=abc*", example.resourceName()))
 *             .build());
 * 
 *         var kek_example_rb = new RoleBinding("kek-example-rb", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", test.id()))
 *             .roleName("DeveloperRead")
 *             .crnPattern(String.format("%s/kek=kek-name", example.resourceName()))
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Getting Started
 * 
 * The following end-to-end examples might help to get started with `confluentcloud.RoleBinding` resource:
 *   * standard-kafka-rbac: _Standard_ Kafka cluster with authorization using RBAC
 *   * dedicated-public-kafka-rbac: _Dedicated_ Kafka cluster that is accessible over the public internet with authorization using RBAC
 *   * dedicated-privatelink-aws-kafka-rbac: _Dedicated_ Kafka cluster on AWS that is accessible via PrivateLink connections with authorization using RBAC
 *   * dedicated-privatelink-azure-kafka-rbac: _Dedicated_ Kafka cluster on Azure that is accessible via PrivateLink connections with authorization using RBAC
 *   * dedicated-vnet-peering-azure-kafka-rbac: _Dedicated_ Kafka cluster on Azure that is accessible via VPC Peering connections with authorization using RBAC
 *   * dedicated-vpc-peering-aws-kafka-rbac: _Dedicated_ Kafka cluster on AWS that is accessible via VPC Peering connections with authorization using RBAC
 *   * dedicated-vpc-peering-gcp-kafka-rbac: _Dedicated_ Kafka cluster on GCP that is accessible via VPC Peering connections with authorization using RBAC
 *   * dedicated-transit-gateway-attachment-aws-kafka-acls: _Dedicated_ Kafka cluster on AWS that is accessible via Transit Gateway Endpoint with authorization using ACLs
 *   * dedicated-transit-gateway-attachment-aws-kafka-rbac: _Dedicated_ Kafka cluster on AWS that is accessible via Transit Gateway Endpoint with authorization using RBAC
 *   * enterprise-privatelinkattachment-aws-kafka-acls: _Enterprise_ Kafka cluster on AWS that is accessible via PrivateLink connections with authorization using ACLs
 * 
 * ## Example of using timeSleep
 * 
 * This configuration introduces a 360-second custom delay after the creation of a role binding, before creating a Kafka topic.
 * 
 * For context, using `disableWaitForReady = false` (the default setting) results in a 90-second hardcoded delay, while opting for `disableWaitForReady = true` results in a 0-second delay.
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.confluentcloud.RoleBinding;
 * import com.pulumi.confluentcloud.RoleBindingArgs;
 * import com.pulumi.time.Sleep;
 * import com.pulumi.time.SleepArgs;
 * import com.pulumi.confluentcloud.KafkaTopic;
 * import com.pulumi.confluentcloud.KafkaTopicArgs;
 * import com.pulumi.confluentcloud.inputs.KafkaTopicKafkaClusterArgs;
 * import com.pulumi.confluentcloud.inputs.KafkaTopicCredentialsArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var app_manager_kafka_cluster_admin_skip_sync = new RoleBinding("app-manager-kafka-cluster-admin-skip-sync", RoleBindingArgs.builder()
 *             .principal(String.format("User:%s", app_manager.id()))
 *             .roleName("CloudClusterAdmin")
 *             .crnPattern(standard.rbacCrn())
 *             .disableWaitForReady(true)
 *             .build());
 * 
 *         var wait360SecondsAfterRoleBinding = new Sleep("wait360SecondsAfterRoleBinding", SleepArgs.builder()
 *             .createDuration("360s")
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(List.of(app_manager_kafka_cluster_admin_skip_sync))
 *                 .build());
 * 
 *         var orders = new KafkaTopic("orders", KafkaTopicArgs.builder()
 *             .kafkaCluster(KafkaTopicKafkaClusterArgs.builder()
 *                 .id(standard.id())
 *                 .build())
 *             .topicName("orders")
 *             .restEndpoint(standard.restEndpoint())
 *             .credentials(KafkaTopicCredentialsArgs.builder()
 *                 .key(app_manager_kafka_api_key.id())
 *                 .secret(app_manager_kafka_api_key.secret())
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(wait360SecondsAfterRoleBinding)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Import
 * 
 * &gt; **Note:** `CONFLUENT_CLOUD_API_KEY` and `CONFLUENT_CLOUD_API_SECRET` environment variables must be set before importing a Role Binding.
 * 
 * You can import a Role Binding by using Role Binding ID, for example:
 * 
 * ```sh
 * $ export CONFLUENT_CLOUD_API_KEY=&#34;&lt;cloud_api_key&gt;&#34;
 * $ export CONFLUENT_CLOUD_API_SECRET=&#34;&lt;cloud_api_secret&gt;&#34;
 * $ pulumi import confluentcloud:index/roleBinding:RoleBinding my_rb rb-f3a90de
 * ```
 * 
 * !&gt; **Warning:** Do not forget to delete terminal command history afterwards for security purposes.
 * 
 */
@ResourceType(type="confluentcloud:index/roleBinding:RoleBinding")
public class RoleBinding extends com.pulumi.resources.CustomResource {
    /**
     * A [Confluent Resource Name (CRN)](&lt;https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)&gt;) that specifies the scope and resource patterns necessary for the role to bind.
     * 
     */
    @Export(name="crnPattern", refs={String.class}, tree="[0]")
    private Output<String> crnPattern;

    /**
     * @return A [Confluent Resource Name (CRN)](&lt;https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)&gt;) that specifies the scope and resource patterns necessary for the role to bind.
     * 
     */
    public Output<String> crnPattern() {
        return this.crnPattern;
    }
    /**
     * An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `false`.
     * 
     * !&gt; **Warning:** When `disableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
     * For example, if you&#39;re creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
     * This setting is best suited for scenarios where you&#39;re provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
     * 
     * &gt; **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
     * 
     * &gt; **Note:** You can also use `timeSleep` resource of HashiCorp&#39;s `time` TF provider to configure a custom waiting period, see this example for more details.
     * 
     */
    @Export(name="disableWaitForReady", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> disableWaitForReady;

    /**
     * @return An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `false`.
     * 
     * !&gt; **Warning:** When `disableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
     * For example, if you&#39;re creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
     * This setting is best suited for scenarios where you&#39;re provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
     * 
     * &gt; **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
     * 
     * &gt; **Note:** You can also use `timeSleep` resource of HashiCorp&#39;s `time` TF provider to configure a custom waiting period, see this example for more details.
     * 
     */
    public Output<Optional<Boolean>> disableWaitForReady() {
        return Codegen.optional(this.disableWaitForReady);
    }
    /**
     * A principal User to bind the role to, for example, &#34;User:u-111aaa&#34; for binding to a user &#34;u-111aaa&#34;, or &#34;User:sa-111aaa&#34; for binding to a service account &#34;sa-111aaa&#34;.
     * 
     */
    @Export(name="principal", refs={String.class}, tree="[0]")
    private Output<String> principal;

    /**
     * @return A principal User to bind the role to, for example, &#34;User:u-111aaa&#34; for binding to a user &#34;u-111aaa&#34;, or &#34;User:sa-111aaa&#34; for binding to a service account &#34;sa-111aaa&#34;.
     * 
     */
    public Output<String> principal() {
        return this.principal;
    }
    /**
     * A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
     * 
     */
    @Export(name="roleName", refs={String.class}, tree="[0]")
    private Output<String> roleName;

    /**
     * @return A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
     * 
     */
    public Output<String> roleName() {
        return this.roleName;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public RoleBinding(java.lang.String name) {
        this(name, RoleBindingArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public RoleBinding(java.lang.String name, RoleBindingArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public RoleBinding(java.lang.String name, RoleBindingArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("confluentcloud:index/roleBinding:RoleBinding", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private RoleBinding(java.lang.String name, Output<java.lang.String> id, @Nullable RoleBindingState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("confluentcloud:index/roleBinding:RoleBinding", name, state, makeResourceOptions(options, id), false);
    }

    private static RoleBindingArgs makeArgs(RoleBindingArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? RoleBindingArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static RoleBinding get(java.lang.String name, Output<java.lang.String> id, @Nullable RoleBindingState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new RoleBinding(name, id, state, options);
    }
}
