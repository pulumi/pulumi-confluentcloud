// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.confluentcloud;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class RoleBindingArgs extends com.pulumi.resources.ResourceArgs {

    public static final RoleBindingArgs Empty = new RoleBindingArgs();

    /**
     * A [Confluent Resource Name (CRN)](&lt;https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)&gt;) that specifies the scope and resource patterns necessary for the role to bind.
     * 
     */
    @Import(name="crnPattern", required=true)
    private Output<String> crnPattern;

    /**
     * @return A [Confluent Resource Name (CRN)](&lt;https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)&gt;) that specifies the scope and resource patterns necessary for the role to bind.
     * 
     */
    public Output<String> crnPattern() {
        return this.crnPattern;
    }

    /**
     * An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `false`.
     * 
     * !&gt; **Warning:** When `disableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
     * For example, if you&#39;re creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
     * This setting is best suited for scenarios where you&#39;re provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
     * 
     * &gt; **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
     * 
     * &gt; **Note:** You can also use `timeSleep` resource of HashiCorp&#39;s `time` TF provider to configure a custom waiting period, see this example for more details.
     * 
     */
    @Import(name="disableWaitForReady")
    private @Nullable Output<Boolean> disableWaitForReady;

    /**
     * @return An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `false`.
     * 
     * !&gt; **Warning:** When `disableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
     * For example, if you&#39;re creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
     * This setting is best suited for scenarios where you&#39;re provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
     * 
     * &gt; **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
     * 
     * &gt; **Note:** You can also use `timeSleep` resource of HashiCorp&#39;s `time` TF provider to configure a custom waiting period, see this example for more details.
     * 
     */
    public Optional<Output<Boolean>> disableWaitForReady() {
        return Optional.ofNullable(this.disableWaitForReady);
    }

    /**
     * A principal User to bind the role to, for example, &#34;User:u-111aaa&#34; for binding to a user &#34;u-111aaa&#34;, or &#34;User:sa-111aaa&#34; for binding to a service account &#34;sa-111aaa&#34;.
     * 
     */
    @Import(name="principal", required=true)
    private Output<String> principal;

    /**
     * @return A principal User to bind the role to, for example, &#34;User:u-111aaa&#34; for binding to a user &#34;u-111aaa&#34;, or &#34;User:sa-111aaa&#34; for binding to a service account &#34;sa-111aaa&#34;.
     * 
     */
    public Output<String> principal() {
        return this.principal;
    }

    /**
     * A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
     * 
     */
    @Import(name="roleName", required=true)
    private Output<String> roleName;

    /**
     * @return A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
     * 
     */
    public Output<String> roleName() {
        return this.roleName;
    }

    private RoleBindingArgs() {}

    private RoleBindingArgs(RoleBindingArgs $) {
        this.crnPattern = $.crnPattern;
        this.disableWaitForReady = $.disableWaitForReady;
        this.principal = $.principal;
        this.roleName = $.roleName;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(RoleBindingArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private RoleBindingArgs $;

        public Builder() {
            $ = new RoleBindingArgs();
        }

        public Builder(RoleBindingArgs defaults) {
            $ = new RoleBindingArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param crnPattern A [Confluent Resource Name (CRN)](&lt;https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)&gt;) that specifies the scope and resource patterns necessary for the role to bind.
         * 
         * @return builder
         * 
         */
        public Builder crnPattern(Output<String> crnPattern) {
            $.crnPattern = crnPattern;
            return this;
        }

        /**
         * @param crnPattern A [Confluent Resource Name (CRN)](&lt;https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)&gt;) that specifies the scope and resource patterns necessary for the role to bind.
         * 
         * @return builder
         * 
         */
        public Builder crnPattern(String crnPattern) {
            return crnPattern(Output.of(crnPattern));
        }

        /**
         * @param disableWaitForReady An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `false`.
         * 
         * !&gt; **Warning:** When `disableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
         * For example, if you&#39;re creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
         * This setting is best suited for scenarios where you&#39;re provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
         * 
         * &gt; **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
         * 
         * &gt; **Note:** You can also use `timeSleep` resource of HashiCorp&#39;s `time` TF provider to configure a custom waiting period, see this example for more details.
         * 
         * @return builder
         * 
         */
        public Builder disableWaitForReady(@Nullable Output<Boolean> disableWaitForReady) {
            $.disableWaitForReady = disableWaitForReady;
            return this;
        }

        /**
         * @param disableWaitForReady An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `false`.
         * 
         * !&gt; **Warning:** When `disableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
         * For example, if you&#39;re creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
         * This setting is best suited for scenarios where you&#39;re provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
         * 
         * &gt; **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
         * 
         * &gt; **Note:** You can also use `timeSleep` resource of HashiCorp&#39;s `time` TF provider to configure a custom waiting period, see this example for more details.
         * 
         * @return builder
         * 
         */
        public Builder disableWaitForReady(Boolean disableWaitForReady) {
            return disableWaitForReady(Output.of(disableWaitForReady));
        }

        /**
         * @param principal A principal User to bind the role to, for example, &#34;User:u-111aaa&#34; for binding to a user &#34;u-111aaa&#34;, or &#34;User:sa-111aaa&#34; for binding to a service account &#34;sa-111aaa&#34;.
         * 
         * @return builder
         * 
         */
        public Builder principal(Output<String> principal) {
            $.principal = principal;
            return this;
        }

        /**
         * @param principal A principal User to bind the role to, for example, &#34;User:u-111aaa&#34; for binding to a user &#34;u-111aaa&#34;, or &#34;User:sa-111aaa&#34; for binding to a service account &#34;sa-111aaa&#34;.
         * 
         * @return builder
         * 
         */
        public Builder principal(String principal) {
            return principal(Output.of(principal));
        }

        /**
         * @param roleName A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
         * 
         * @return builder
         * 
         */
        public Builder roleName(Output<String> roleName) {
            $.roleName = roleName;
            return this;
        }

        /**
         * @param roleName A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
         * 
         * @return builder
         * 
         */
        public Builder roleName(String roleName) {
            return roleName(Output.of(roleName));
        }

        public RoleBindingArgs build() {
            if ($.crnPattern == null) {
                throw new MissingRequiredPropertyException("RoleBindingArgs", "crnPattern");
            }
            if ($.principal == null) {
                throw new MissingRequiredPropertyException("RoleBindingArgs", "principal");
            }
            if ($.roleName == null) {
                throw new MissingRequiredPropertyException("RoleBindingArgs", "roleName");
            }
            return $;
        }
    }

}
