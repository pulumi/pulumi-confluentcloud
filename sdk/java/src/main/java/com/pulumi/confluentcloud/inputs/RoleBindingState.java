// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.confluentcloud.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class RoleBindingState extends com.pulumi.resources.ResourceArgs {

    public static final RoleBindingState Empty = new RoleBindingState();

    /**
     * A [Confluent Resource Name (CRN)](&lt;https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)&gt;) that specifies the scope and resource patterns necessary for the role to bind.
     * 
     */
    @Import(name="crnPattern")
    private @Nullable Output<String> crnPattern;

    /**
     * @return A [Confluent Resource Name (CRN)](&lt;https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)&gt;) that specifies the scope and resource patterns necessary for the role to bind.
     * 
     */
    public Optional<Output<String>> crnPattern() {
        return Optional.ofNullable(this.crnPattern);
    }

    /**
     * An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `false`.
     * 
     * !&gt; **Warning:** When `disableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
     * For example, if you&#39;re creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
     * This setting is best suited for scenarios where you&#39;re provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
     * 
     * &gt; **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
     * 
     * &gt; **Note:** You can also use `timeSleep` resource of HashiCorp&#39;s `time` TF provider to configure a custom waiting period, see this example for more details.
     * 
     */
    @Import(name="disableWaitForReady")
    private @Nullable Output<Boolean> disableWaitForReady;

    /**
     * @return An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `false`.
     * 
     * !&gt; **Warning:** When `disableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
     * For example, if you&#39;re creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
     * This setting is best suited for scenarios where you&#39;re provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
     * 
     * &gt; **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
     * 
     * &gt; **Note:** You can also use `timeSleep` resource of HashiCorp&#39;s `time` TF provider to configure a custom waiting period, see this example for more details.
     * 
     */
    public Optional<Output<Boolean>> disableWaitForReady() {
        return Optional.ofNullable(this.disableWaitForReady);
    }

    /**
     * A principal User to bind the role to, for example, &#34;User:u-111aaa&#34; for binding to a user &#34;u-111aaa&#34;, or &#34;User:sa-111aaa&#34; for binding to a service account &#34;sa-111aaa&#34;.
     * 
     */
    @Import(name="principal")
    private @Nullable Output<String> principal;

    /**
     * @return A principal User to bind the role to, for example, &#34;User:u-111aaa&#34; for binding to a user &#34;u-111aaa&#34;, or &#34;User:sa-111aaa&#34; for binding to a service account &#34;sa-111aaa&#34;.
     * 
     */
    public Optional<Output<String>> principal() {
        return Optional.ofNullable(this.principal);
    }

    /**
     * A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
     * 
     */
    @Import(name="roleName")
    private @Nullable Output<String> roleName;

    /**
     * @return A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
     * 
     */
    public Optional<Output<String>> roleName() {
        return Optional.ofNullable(this.roleName);
    }

    private RoleBindingState() {}

    private RoleBindingState(RoleBindingState $) {
        this.crnPattern = $.crnPattern;
        this.disableWaitForReady = $.disableWaitForReady;
        this.principal = $.principal;
        this.roleName = $.roleName;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(RoleBindingState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private RoleBindingState $;

        public Builder() {
            $ = new RoleBindingState();
        }

        public Builder(RoleBindingState defaults) {
            $ = new RoleBindingState(Objects.requireNonNull(defaults));
        }

        /**
         * @param crnPattern A [Confluent Resource Name (CRN)](&lt;https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)&gt;) that specifies the scope and resource patterns necessary for the role to bind.
         * 
         * @return builder
         * 
         */
        public Builder crnPattern(@Nullable Output<String> crnPattern) {
            $.crnPattern = crnPattern;
            return this;
        }

        /**
         * @param crnPattern A [Confluent Resource Name (CRN)](&lt;https://docs.confluent.io/cloud/current/api.html#section/Identifiers-and-URLs/Confluent-Resource-Names-(CRNs)&gt;) that specifies the scope and resource patterns necessary for the role to bind.
         * 
         * @return builder
         * 
         */
        public Builder crnPattern(String crnPattern) {
            return crnPattern(Output.of(crnPattern));
        }

        /**
         * @param disableWaitForReady An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `false`.
         * 
         * !&gt; **Warning:** When `disableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
         * For example, if you&#39;re creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
         * This setting is best suited for scenarios where you&#39;re provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
         * 
         * &gt; **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
         * 
         * &gt; **Note:** You can also use `timeSleep` resource of HashiCorp&#39;s `time` TF provider to configure a custom waiting period, see this example for more details.
         * 
         * @return builder
         * 
         */
        public Builder disableWaitForReady(@Nullable Output<Boolean> disableWaitForReady) {
            $.disableWaitForReady = disableWaitForReady;
            return this;
        }

        /**
         * @param disableWaitForReady An optional flag to disable wait-for-readiness on create. Must be unset when importing. Defaults to `false`.
         * 
         * !&gt; **Warning:** When `disableWaitForReady = true` is used, Terraform skips waiting for role bindings to fully propagate. This can lead to a situation where Terraform attempts to create resources before the service account has the necessary permissions—resulting in HTTP 403 Forbidden errors.
         * For example, if you&#39;re creating a new service account, a new Kafka API Key, a new `CloudClusterAdmin` role binding, and a Kafka topic in a single run (see this code snippet), the topic creation may fail if the role binding hasn’t taken effect yet. Without that role, the service account won’t have permission to create the topic.
         * This setting is best suited for scenarios where you&#39;re provisioning a large number of role bindings without dependent resources, as it significantly speeds up the apply process.
         * 
         * &gt; **Note:** If you encounter HTTP 403 Forbidden errors when creating role bindings, you can rerun `pulumi up` after a few minutes, once the role bindings have had time to propagate.
         * 
         * &gt; **Note:** You can also use `timeSleep` resource of HashiCorp&#39;s `time` TF provider to configure a custom waiting period, see this example for more details.
         * 
         * @return builder
         * 
         */
        public Builder disableWaitForReady(Boolean disableWaitForReady) {
            return disableWaitForReady(Output.of(disableWaitForReady));
        }

        /**
         * @param principal A principal User to bind the role to, for example, &#34;User:u-111aaa&#34; for binding to a user &#34;u-111aaa&#34;, or &#34;User:sa-111aaa&#34; for binding to a service account &#34;sa-111aaa&#34;.
         * 
         * @return builder
         * 
         */
        public Builder principal(@Nullable Output<String> principal) {
            $.principal = principal;
            return this;
        }

        /**
         * @param principal A principal User to bind the role to, for example, &#34;User:u-111aaa&#34; for binding to a user &#34;u-111aaa&#34;, or &#34;User:sa-111aaa&#34; for binding to a service account &#34;sa-111aaa&#34;.
         * 
         * @return builder
         * 
         */
        public Builder principal(String principal) {
            return principal(Output.of(principal));
        }

        /**
         * @param roleName A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
         * 
         * @return builder
         * 
         */
        public Builder roleName(@Nullable Output<String> roleName) {
            $.roleName = roleName;
            return this;
        }

        /**
         * @param roleName A name of the role to bind to the principal. See [Confluent Cloud RBAC Roles](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#ccloud-rbac-roles) for a full list of supported role names.
         * 
         * @return builder
         * 
         */
        public Builder roleName(String roleName) {
            return roleName(Output.of(roleName));
        }

        public RoleBindingState build() {
            return $;
        }
    }

}
