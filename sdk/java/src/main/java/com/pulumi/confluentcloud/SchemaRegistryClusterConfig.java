// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.confluentcloud;

import com.pulumi.confluentcloud.SchemaRegistryClusterConfigArgs;
import com.pulumi.confluentcloud.Utilities;
import com.pulumi.confluentcloud.inputs.SchemaRegistryClusterConfigState;
import com.pulumi.confluentcloud.outputs.SchemaRegistryClusterConfigCredentials;
import com.pulumi.confluentcloud.outputs.SchemaRegistryClusterConfigSchemaRegistryCluster;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](https://docs.confluent.io/cloud/current/api.html#section/Versioning/API-Lifecycle-Policy)
 * 
 * `confluentcloud.SchemaRegistryClusterConfig` provides a Schema Registry Cluster Config resource that enables updating Config on a Schema Registry cluster on Confluent Cloud.
 * 
 * &gt; **Note:** It is recommended to set `lifecycle { preventDestroy = true }` on production instances to prevent accidental Schema Registry Cluster Config deletion. This setting rejects plans that would destroy or recreate the Schema Registry Cluster Config, such as attempting to change uneditable attributes. Read more about it in the Terraform docs.
 * 
 * ## Example Usage
 * 
 * ### Option #1: Manage multiple Schema Registry clusters in the same Pulumi Stack
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.confluentcloud.SchemaRegistryClusterConfig;
 * import com.pulumi.confluentcloud.SchemaRegistryClusterConfigArgs;
 * import com.pulumi.confluentcloud.inputs.SchemaRegistryClusterConfigSchemaRegistryClusterArgs;
 * import com.pulumi.confluentcloud.inputs.SchemaRegistryClusterConfigCredentialsArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new SchemaRegistryClusterConfig("example", SchemaRegistryClusterConfigArgs.builder()
 *             .schemaRegistryCluster(SchemaRegistryClusterConfigSchemaRegistryClusterArgs.builder()
 *                 .id(essentials.id())
 *                 .build())
 *             .restEndpoint(essentials.restEndpoint())
 *             .compatibilityLevel("FULL")
 *             .credentials(SchemaRegistryClusterConfigCredentialsArgs.builder()
 *                 .key("<Schema Registry API Key for data.confluent_schema_registry_cluster.essentials>")
 *                 .secret("<Schema Registry API Secret for data.confluent_schema_registry_cluster.essentials>")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Option #2: Manage a single Schema Registry cluster in the same Pulumi Stack
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.confluentcloud.SchemaRegistryClusterConfig;
 * import com.pulumi.confluentcloud.SchemaRegistryClusterConfigArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new SchemaRegistryClusterConfig("example", SchemaRegistryClusterConfigArgs.builder()
 *             .compatibilityLevel("FULL")
 *             .compatibilityGroup("abc.cg.version")
 *             .normalize(true)
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Import
 * 
 * You can import a Schema Registry Cluster Config by using the Schema Registry cluster ID, Subject name in the format `&lt;Schema Registry cluster ID&gt;`, for example:
 * 
 * ```sh
 * $ export IMPORT_SCHEMA_REGISTRY_API_KEY=&#34;&lt;schema_registry_api_key&gt;&#34;
 * $ export IMPORT_SCHEMA_REGISTRY_API_SECRET=&#34;&lt;schema_registry_api_secret&gt;&#34;
 * $ export IMPORT_SCHEMA_REGISTRY_REST_ENDPOINT=&#34;&lt;schema_registry_rest_endpoint&gt;&#34;
 * $ pulumi import confluentcloud:index/schemaRegistryClusterConfig:SchemaRegistryClusterConfig example lsrc-abc123
 * ```
 * 
 * !&gt; **Warning:** Do not forget to delete terminal command history afterwards for security purposes.
 * 
 */
@ResourceType(type="confluentcloud:index/schemaRegistryClusterConfig:SchemaRegistryClusterConfig")
public class SchemaRegistryClusterConfig extends com.pulumi.resources.CustomResource {
    /**
     * The global Schema Registry compatibility group.
     * 
     */
    @Export(name="compatibilityGroup", refs={String.class}, tree="[0]")
    private Output<String> compatibilityGroup;

    /**
     * @return The global Schema Registry compatibility group.
     * 
     */
    public Output<String> compatibilityGroup() {
        return this.compatibilityGroup;
    }
    /**
     * The global Schema Registry compatibility level. Accepted values are: `BACKWARD`, `BACKWARD_TRANSITIVE`, `FORWARD`, `FORWARD_TRANSITIVE`, `FULL`, `FULL_TRANSITIVE`, and `NONE`. See the [Compatibility Types](https://docs.confluent.io/platform/current/schema-registry/avro.html#compatibility-types) for more details.
     * 
     */
    @Export(name="compatibilityLevel", refs={String.class}, tree="[0]")
    private Output<String> compatibilityLevel;

    /**
     * @return The global Schema Registry compatibility level. Accepted values are: `BACKWARD`, `BACKWARD_TRANSITIVE`, `FORWARD`, `FORWARD_TRANSITIVE`, `FULL`, `FULL_TRANSITIVE`, and `NONE`. See the [Compatibility Types](https://docs.confluent.io/platform/current/schema-registry/avro.html#compatibility-types) for more details.
     * 
     */
    public Output<String> compatibilityLevel() {
        return this.compatibilityLevel;
    }
    /**
     * The Cluster API Credentials.
     * 
     */
    @Export(name="credentials", refs={SchemaRegistryClusterConfigCredentials.class}, tree="[0]")
    private Output</* @Nullable */ SchemaRegistryClusterConfigCredentials> credentials;

    /**
     * @return The Cluster API Credentials.
     * 
     */
    public Output<Optional<SchemaRegistryClusterConfigCredentials>> credentials() {
        return Codegen.optional(this.credentials);
    }
    /**
     * Whether schemas are automatically normalized when registered or passed during lookups.
     * 
     */
    @Export(name="normalize", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> normalize;

    /**
     * @return Whether schemas are automatically normalized when registered or passed during lookups.
     * 
     */
    public Output<Boolean> normalize() {
        return this.normalize;
    }
    /**
     * The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
     * 
     */
    @Export(name="restEndpoint", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> restEndpoint;

    /**
     * @return The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
     * 
     */
    public Output<Optional<String>> restEndpoint() {
        return Codegen.optional(this.restEndpoint);
    }
    @Export(name="schemaRegistryCluster", refs={SchemaRegistryClusterConfigSchemaRegistryCluster.class}, tree="[0]")
    private Output</* @Nullable */ SchemaRegistryClusterConfigSchemaRegistryCluster> schemaRegistryCluster;

    public Output<Optional<SchemaRegistryClusterConfigSchemaRegistryCluster>> schemaRegistryCluster() {
        return Codegen.optional(this.schemaRegistryCluster);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public SchemaRegistryClusterConfig(java.lang.String name) {
        this(name, SchemaRegistryClusterConfigArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public SchemaRegistryClusterConfig(java.lang.String name, @Nullable SchemaRegistryClusterConfigArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public SchemaRegistryClusterConfig(java.lang.String name, @Nullable SchemaRegistryClusterConfigArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("confluentcloud:index/schemaRegistryClusterConfig:SchemaRegistryClusterConfig", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private SchemaRegistryClusterConfig(java.lang.String name, Output<java.lang.String> id, @Nullable SchemaRegistryClusterConfigState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("confluentcloud:index/schemaRegistryClusterConfig:SchemaRegistryClusterConfig", name, state, makeResourceOptions(options, id), false);
    }

    private static SchemaRegistryClusterConfigArgs makeArgs(@Nullable SchemaRegistryClusterConfigArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? SchemaRegistryClusterConfigArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "credentials"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static SchemaRegistryClusterConfig get(java.lang.String name, Output<java.lang.String> id, @Nullable SchemaRegistryClusterConfigState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new SchemaRegistryClusterConfig(name, id, state, options);
    }
}
