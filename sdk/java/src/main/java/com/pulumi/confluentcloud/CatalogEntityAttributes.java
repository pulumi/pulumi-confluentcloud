// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.confluentcloud;

import com.pulumi.confluentcloud.CatalogEntityAttributesArgs;
import com.pulumi.confluentcloud.Utilities;
import com.pulumi.confluentcloud.inputs.CatalogEntityAttributesState;
import com.pulumi.confluentcloud.outputs.CatalogEntityAttributesCredentials;
import com.pulumi.confluentcloud.outputs.CatalogEntityAttributesSchemaRegistryCluster;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](https://docs.confluent.io/cloud/current/api.html#section/Versioning/API-Lifecycle-Policy)
 * 
 * `confluentcloud.CatalogEntityAttributes` provides a Catalog Entity Attributes resource that enables creating, evolving, and deleting Catalog Entity Attributes on Confluent Cloud.
 * 
 * &gt; **Note:** It is recommended to set `lifecycle { preventDestroy = true }` on production instances to prevent accidental catalog entity attributes deletion. This setting rejects plans that would destroy or recreate the schema, such as attempting to change uneditable attributes. Read more about it in the Terraform docs.
 * 
 * ## Example Usage
 * 
 * ### Option #1: Manage multiple Schema Registry clusters in the same Pulumi Stack
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.confluentcloud.CatalogEntityAttributes;
 * import com.pulumi.confluentcloud.CatalogEntityAttributesArgs;
 * import com.pulumi.confluentcloud.inputs.CatalogEntityAttributesSchemaRegistryClusterArgs;
 * import com.pulumi.confluentcloud.inputs.CatalogEntityAttributesCredentialsArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App }{{@code
 *     public static void main(String[] args) }{{@code
 *         Pulumi.run(App::stack);
 *     }}{@code
 * 
 *     public static void stack(Context ctx) }{{@code
 *         var environment = new CatalogEntityAttributes("environment", CatalogEntityAttributesArgs.builder()
 *             .schemaRegistryCluster(CatalogEntityAttributesSchemaRegistryClusterArgs.builder()
 *                 .id(essentials.id())
 *                 .build())
 *             .restEndpoint(essentials.restEndpoint())
 *             .credentials(CatalogEntityAttributesCredentialsArgs.builder()
 *                 .key("<Schema Registry API Key for data.confluent_schema_registry_cluster.essentials>")
 *                 .secret("<Schema Registry API Secret for data.confluent_schema_registry_cluster.essentials>")
 *                 .build())
 *             .entityName(main.id())
 *             .entityType("cf_environment")
 *             .attributes(Map.of("description", "Environment description"))
 *             .build());
 * 
 *         var kafka_cluster = new CatalogEntityAttributes("kafka-cluster", CatalogEntityAttributesArgs.builder()
 *             .schemaRegistryCluster(CatalogEntityAttributesSchemaRegistryClusterArgs.builder()
 *                 .id(essentials.id())
 *                 .build())
 *             .restEndpoint(essentials.restEndpoint())
 *             .credentials(CatalogEntityAttributesCredentialsArgs.builder()
 *                 .key("<Schema Registry API Key for data.confluent_schema_registry_cluster.essentials>")
 *                 .secret("<Schema Registry API Secret for data.confluent_schema_registry_cluster.essentials>")
 *                 .build())
 *             .entityName(basic.id())
 *             .entityType("kafka_logical_cluster")
 *             .attributes(Map.of("description", "Kafka Cluster description"))
 *             .build());
 * 
 *         var topic = new CatalogEntityAttributes("topic", CatalogEntityAttributesArgs.builder()
 *             .schemaRegistryCluster(CatalogEntityAttributesSchemaRegistryClusterArgs.builder()
 *                 .id(essentials.id())
 *                 .build())
 *             .restEndpoint(essentials.restEndpoint())
 *             .credentials(CatalogEntityAttributesCredentialsArgs.builder()
 *                 .key("<Schema Registry API Key for data.confluent_schema_registry_cluster.essentials>")
 *                 .secret("<Schema Registry API Secret for data.confluent_schema_registry_cluster.essentials>")
 *                 .build())
 *             .entityName(String.format("%s:%s", basic.id(),purchase.topicName()))
 *             .entityType("kafka_topic")
 *             .attributes(Map.ofEntries(
 *                 Map.entry("owner", "dev"),
 *                 Map.entry("description", "Kafka topic for orders"),
 *                 Map.entry("ownerEmail", "dev}{@literal @}{@code gmail.com")
 *             ))
 *             .build());
 * 
 *         var schema = new CatalogEntityAttributes("schema", CatalogEntityAttributesArgs.builder()
 *             .schemaRegistryCluster(CatalogEntityAttributesSchemaRegistryClusterArgs.builder()
 *                 .id(essentials.id())
 *                 .build())
 *             .restEndpoint(essentials.restEndpoint())
 *             .credentials(CatalogEntityAttributesCredentialsArgs.builder()
 *                 .key("<Schema Registry API Key for data.confluent_schema_registry_cluster.essentials>")
 *                 .secret("<Schema Registry API Secret for data.confluent_schema_registry_cluster.essentials>")
 *                 .build())
 *             .entityName(String.format("%s:.:%s", essentials.id(),purchaseConfluentSchema.schemaIdentifier()))
 *             .entityType("sr_schema")
 *             .attributes(Map.of("description", "Schema description"))
 *             .build());
 * 
 *     }}{@code
 * }}{@code
 * }
 * </pre>
 * 
 * ### Option #2: Manage a single Schema Registry cluster in the same Pulumi Stack
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.confluentcloud.CatalogEntityAttributes;
 * import com.pulumi.confluentcloud.CatalogEntityAttributesArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App }{{@code
 *     public static void main(String[] args) }{{@code
 *         Pulumi.run(App::stack);
 *     }}{@code
 * 
 *     public static void stack(Context ctx) }{{@code
 *         var environment = new CatalogEntityAttributes("environment", CatalogEntityAttributesArgs.builder()
 *             .entityName(environmentId)
 *             .entityType("cf_environment")
 *             .attributes(Map.of("description", "Environment description"))
 *             .build());
 * 
 *         var kafka_cluster = new CatalogEntityAttributes("kafka-cluster", CatalogEntityAttributesArgs.builder()
 *             .entityName(kafkaClusterId)
 *             .entityType("kafka_logical_cluster")
 *             .attributes(Map.of("description", "Kafka Cluster description"))
 *             .build());
 * 
 *         var topic = new CatalogEntityAttributes("topic", CatalogEntityAttributesArgs.builder()
 *             .entityName(String.format("%s:%s", kafkaClusterId,kafkaTopicName))
 *             .entityType("kafka_topic")
 *             .attributes(Map.ofEntries(
 *                 Map.entry("owner", "dev"),
 *                 Map.entry("description", "Kafka topic for orders"),
 *                 Map.entry("ownerEmail", "dev}{@literal @}{@code gmail.com")
 *             ))
 *             .build());
 * 
 *         var schema = new CatalogEntityAttributes("schema", CatalogEntityAttributesArgs.builder()
 *             .entityName(String.format("%s:.:%s", schemaRegistryClusterId,purchase.schemaIdentifier()))
 *             .entityType("sr_schema")
 *             .attributes(Map.of("description", "Schema description"))
 *             .build());
 * 
 *     }}{@code
 * }}{@code
 * }
 * </pre>
 * &gt; **Note:** We also support `schemaRegistryRestEndpoint` instead of `catalogRestEndpoint` for the time being.
 * 
 * ## Import
 * 
 * You can import a Catalog Entity Attributes resource by using the Schema Registry Cluster ID, Entity name in the format `&lt;Schema Registry Cluster ID&gt;/&lt;Entity Type&gt;/&lt;Entity Name&gt;/&lt;Comma-Delimited-Attributes&gt;`, for example:
 * 
 * Option #1: Manage multiple Catalog Entity Attributes in the same Pulumi Stack
 * 
 * ```sh
 * $ export IMPORT_SCHEMA_REGISTRY_API_KEY=&#34;&lt;schema_registry_api_key&gt;&#34;
 * $ export IMPORT_SCHEMA_REGISTRY_API_SECRET=&#34;&lt;schema_registry_api_secret&gt;&#34;
 * $ export IMPORT_SCHEMA_REGISTRY_REST_ENDPOINT=&#34;&lt;schema_registry_rest_endpoint&gt;&#34;
 * $ pulumi import confluentcloud:index/catalogEntityAttributes:CatalogEntityAttributes environment lsrc-abc123/cf_environment/env-abc123/owner,description,ownerEmail
 * ```
 * 
 * Option #2: Manage a single Catalog Entity Attributes in the same Pulumi Stack
 * 
 * ```sh
 * $ pulumi import confluentcloud:index/catalogEntityAttributes:CatalogEntityAttributes environment lsrc-abc123/cf_environment/env-abc123/owner,description,ownerEmail
 * ```
 * 
 * &gt; **Note:** Use the `&lt;Schema Registry Cluster ID&gt;/&lt;Entity Type&gt;/&lt;Entity Name&gt;/` format to import a Catalog Entity Attributes resource with an empty list of attributes.
 * 
 * !&gt; **Warning:** Do not forget to delete terminal command history afterwards for security purposes.
 * 
 */
@ResourceType(type="confluentcloud:index/catalogEntityAttributes:CatalogEntityAttributes")
public class CatalogEntityAttributes extends com.pulumi.resources.CustomResource {
    /**
     * The block of key-value pair attributes. Refer to the [add-a-topic-owner-and-email](https://docs.confluent.io/cloud/current/stream-governance/stream-catalog-rest-apis.html#add-a-topic-owner-and-email) for more details.
     * 
     * &gt; **Note:** You have to set the attribute value to an empty string if you plan to delete an attribute.
     * 
     * &gt; **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
     * 
     * &gt; **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target=&#34;confluent_catalog_entity_attributes.main&#34;`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target=&#34;confluent_catalog_entity_attributes.main&#34; -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.
     * 
     * !&gt; **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn&#39;t encrypt the sensitive `credentials` value of the `confluentcloud.CatalogEntityAttributes` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
     * 
     */
    @Export(name="attributes", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> attributes;

    /**
     * @return The block of key-value pair attributes. Refer to the [add-a-topic-owner-and-email](https://docs.confluent.io/cloud/current/stream-governance/stream-catalog-rest-apis.html#add-a-topic-owner-and-email) for more details.
     * 
     * &gt; **Note:** You have to set the attribute value to an empty string if you plan to delete an attribute.
     * 
     * &gt; **Note:** A Schema Registry API key consists of a key and a secret. Schema Registry API keys are required to interact with Schema Registry clusters in Confluent Cloud. Each Schema Registry API key is valid for one specific Schema Registry cluster.
     * 
     * &gt; **Note:** Use Option #2 to simplify the key rotation process. When using Option #1, to rotate a Schema Registry API key, create a new Schema Registry API key, update the `credentials` block in all configuration files to use the new Schema Registry API key, run `pulumi up -target=&#34;confluent_catalog_entity_attributes.main&#34;`, and remove the old Schema Registry API key. Alternatively, in case the old Schema Registry API Key was deleted already, you might need to run `pulumi preview -refresh=false -target=&#34;confluent_catalog_entity_attributes.main&#34; -out=rotate-schema-registry-api-key` and `pulumi up rotate-schema-registry-api-key` instead.
     * 
     * !&gt; **Warning:** Use Option #2 to avoid exposing sensitive `credentials` value in a state file. When using Option #1, Terraform doesn&#39;t encrypt the sensitive `credentials` value of the `confluentcloud.CatalogEntityAttributes` resource, so you must keep your state file secure to avoid exposing it. Refer to the Terraform documentation to learn more about securing your state file.
     * 
     */
    public Output<Optional<Map<String,String>>> attributes() {
        return Codegen.optional(this.attributes);
    }
    /**
     * The Cluster API Credentials.
     * 
     */
    @Export(name="credentials", refs={CatalogEntityAttributesCredentials.class}, tree="[0]")
    private Output</* @Nullable */ CatalogEntityAttributesCredentials> credentials;

    /**
     * @return The Cluster API Credentials.
     * 
     */
    public Output<Optional<CatalogEntityAttributesCredentials>> credentials() {
        return Codegen.optional(this.credentials);
    }
    /**
     * The qualified name of the entity, for example, `${data.confluent_schema_registry_cluster.essentials.id}:.:${confluent_schema.purchase.schema_identifier}`, `${data.confluent_schema_registry_cluster.essentials.id}:${confluent_kafka_cluster.basic.id}:${confluent_kafka_topic.purchase.topic_name}`. Refer to the [Examples of qualified names](https://docs.confluent.io/cloud/current/stream-governance/stream-catalog-rest-apis.html#examples-of-qualified-names) to see the full list of supported values for the `entityName` attribute.
     * 
     */
    @Export(name="entityName", refs={String.class}, tree="[0]")
    private Output<String> entityName;

    /**
     * @return The qualified name of the entity, for example, `${data.confluent_schema_registry_cluster.essentials.id}:.:${confluent_schema.purchase.schema_identifier}`, `${data.confluent_schema_registry_cluster.essentials.id}:${confluent_kafka_cluster.basic.id}:${confluent_kafka_topic.purchase.topic_name}`. Refer to the [Examples of qualified names](https://docs.confluent.io/cloud/current/stream-governance/stream-catalog-rest-apis.html#examples-of-qualified-names) to see the full list of supported values for the `entityName` attribute.
     * 
     */
    public Output<String> entityName() {
        return this.entityName;
    }
    /**
     * The entity type, for example, `cfEnvironment`, `kafkaLogicalCluster`, `kafkaTopic`, `srSchema`, etc. Refer to the [Entity types](https://docs.confluent.io/cloud/current/stream-governance/stream-catalog-rest-apis.html#entity-types) to see the full list of supported values for the `entityType` attribute.
     * 
     */
    @Export(name="entityType", refs={String.class}, tree="[0]")
    private Output<String> entityType;

    /**
     * @return The entity type, for example, `cfEnvironment`, `kafkaLogicalCluster`, `kafkaTopic`, `srSchema`, etc. Refer to the [Entity types](https://docs.confluent.io/cloud/current/stream-governance/stream-catalog-rest-apis.html#entity-types) to see the full list of supported values for the `entityType` attribute.
     * 
     */
    public Output<String> entityType() {
        return this.entityType;
    }
    /**
     * The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
     * 
     */
    @Export(name="restEndpoint", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> restEndpoint;

    /**
     * @return The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
     * 
     */
    public Output<Optional<String>> restEndpoint() {
        return Codegen.optional(this.restEndpoint);
    }
    @Export(name="schemaRegistryCluster", refs={CatalogEntityAttributesSchemaRegistryCluster.class}, tree="[0]")
    private Output</* @Nullable */ CatalogEntityAttributesSchemaRegistryCluster> schemaRegistryCluster;

    public Output<Optional<CatalogEntityAttributesSchemaRegistryCluster>> schemaRegistryCluster() {
        return Codegen.optional(this.schemaRegistryCluster);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public CatalogEntityAttributes(java.lang.String name) {
        this(name, CatalogEntityAttributesArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public CatalogEntityAttributes(java.lang.String name, CatalogEntityAttributesArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public CatalogEntityAttributes(java.lang.String name, CatalogEntityAttributesArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("confluentcloud:index/catalogEntityAttributes:CatalogEntityAttributes", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private CatalogEntityAttributes(java.lang.String name, Output<java.lang.String> id, @Nullable CatalogEntityAttributesState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("confluentcloud:index/catalogEntityAttributes:CatalogEntityAttributes", name, state, makeResourceOptions(options, id), false);
    }

    private static CatalogEntityAttributesArgs makeArgs(CatalogEntityAttributesArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? CatalogEntityAttributesArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "credentials"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static CatalogEntityAttributes get(java.lang.String name, Output<java.lang.String> id, @Nullable CatalogEntityAttributesState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new CatalogEntityAttributes(name, id, state, options);
    }
}
