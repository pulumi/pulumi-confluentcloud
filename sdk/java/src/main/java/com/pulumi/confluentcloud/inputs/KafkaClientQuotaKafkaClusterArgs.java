// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.confluentcloud.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.String;
import java.util.Objects;


public final class KafkaClientQuotaKafkaClusterArgs extends com.pulumi.resources.ResourceArgs {

    public static final KafkaClientQuotaKafkaClusterArgs Empty = new KafkaClientQuotaKafkaClusterArgs();

    /**
     * The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.
     * 
     * &gt; **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.
     * 
     * &gt; **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
     * 
     */
    @Import(name="id", required=true)
    private Output<String> id;

    /**
     * @return The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.
     * 
     * &gt; **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.
     * 
     * &gt; **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
     * 
     */
    public Output<String> id() {
        return this.id;
    }

    private KafkaClientQuotaKafkaClusterArgs() {}

    private KafkaClientQuotaKafkaClusterArgs(KafkaClientQuotaKafkaClusterArgs $) {
        this.id = $.id;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(KafkaClientQuotaKafkaClusterArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private KafkaClientQuotaKafkaClusterArgs $;

        public Builder() {
            $ = new KafkaClientQuotaKafkaClusterArgs();
        }

        public Builder(KafkaClientQuotaKafkaClusterArgs defaults) {
            $ = new KafkaClientQuotaKafkaClusterArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param id The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.
         * 
         * &gt; **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.
         * 
         * &gt; **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
         * 
         * @return builder
         * 
         */
        public Builder id(Output<String> id) {
            $.id = id;
            return this;
        }

        /**
         * @param id The ID of the Environment that the corresponding Kafka Cluster belongs to, for example, `env-abc123`.
         * 
         * &gt; **Note:** Each principal assigned to a quota receives the full amount of the quota, meaning the quota is not shared by the principals it is assigned. For example, if a 10 MBps ingress quota is applied to Principals 1 and 2, Principal 1 can produce at most 10 MBps, independently of Principal 2.
         * 
         * &gt; **Note:** Define a throughput maximum, but do not guarantee a throughput floor. Applications are rate-limited through the use of the Kafka throttling mechanism. Kafka asks the client to wait before sending more data and mutes the channel, which appears as latency to the client application.
         * 
         * @return builder
         * 
         */
        public Builder id(String id) {
            return id(Output.of(id));
        }

        public KafkaClientQuotaKafkaClusterArgs build() {
            $.id = Objects.requireNonNull($.id, "expected parameter 'id' to be non-null");
            return $;
        }
    }

}
