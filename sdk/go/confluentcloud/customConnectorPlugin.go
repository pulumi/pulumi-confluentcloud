// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package confluentcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-confluentcloud/sdk/v2/go/confluentcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-confluentcloud/sdk/v2/go/confluentcloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := confluentcloud.NewCustomConnectorPlugin(ctx, "source", &confluentcloud.CustomConnectorPluginArgs{
//				DisplayName:               pulumi.String("Datagen Source Connector Plugin"),
//				DocumentationLink:         pulumi.String("https://www.confluent.io/hub/confluentinc/kafka-connect-datagen"),
//				ConnectorClass:            pulumi.String("io.confluent.kafka.connect.datagen.DatagenConnector"),
//				ConnectorType:             pulumi.String("SOURCE"),
//				SensitiveConfigProperties: pulumi.StringArray{},
//				Filename:                  pulumi.String("confluentinc-kafka-connect-datagen-0.6.2.zip"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// You can import a Custom Connector Plugin by using a Custom Connector Plugin ID, in the format `<Custom Connector Plugin>`. The following example shows how to import a Custom Connector Plugin:
//
// $ export CONFLUENT_CLOUD_API_KEY="<cloud_api_key>"
//
// $ export CONFLUENT_CLOUD_API_SECRET="<cloud_api_secret>"
//
// ```sh
// $ pulumi import confluentcloud:index/customConnectorPlugin:CustomConnectorPlugin main ccp-abc123xyz
// ```
//
// !> **Warning:** Do not forget to delete terminal command history afterwards for security purposes.
type CustomConnectorPlugin struct {
	pulumi.CustomResourceState

	// Cloud provider where the Custom Connector Plugin archive is uploaded. Defaults to `AWS`. Accepted values are: `AWS`, `AZURE`.
	Cloud pulumi.StringOutput `pulumi:"cloud"`
	// The Java class or alias for the connector. You can get the connector class from the connector documentation provided by the developer.
	ConnectorClass pulumi.StringOutput `pulumi:"connectorClass"`
	// The type of the Custom Connector Plugin. Accepted values are: `SOURCE`, `SINK`.
	ConnectorType pulumi.StringOutput `pulumi:"connectorType"`
	// The description of the Custom Connector Plugin.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The name of the Custom Connector Plugin.
	DisplayName pulumi.StringOutput `pulumi:"displayName"`
	// The documentation link of the Custom Connector Plugin.
	DocumentationLink pulumi.StringPtrOutput `pulumi:"documentationLink"`
	// The path to the Custom Connector Plugin archive to be uploaded. Accepted archive formats are: `.jar`, `.zip`.
	Filename pulumi.StringOutput `pulumi:"filename"`
	// The list of sensitive properties. A sensitive property is a connector configuration property that must be hidden after a user enters the property value when setting up the connector, for example, passwords, keys, and tokens. Refer to the developer documentation and add all required and optional sensitive properties that a user could potentially configure for the connector. Marking a property as sensitive ensures that these fields are handled appropriately within the Confluent infrastructure. This includes masking fields, for example in exception logging, and encrypting field values in the underlying data store. You must identify all sensitive properties. Failure to identify sensitive properties can result in the sensitive property value being stored in plain text rather than in encrypted format. Only add connector-specific sensitive properties. Kafka keys, passwords, and service account information should not be entered here.
	SensitiveConfigProperties pulumi.StringArrayOutput `pulumi:"sensitiveConfigProperties"`
}

// NewCustomConnectorPlugin registers a new resource with the given unique name, arguments, and options.
func NewCustomConnectorPlugin(ctx *pulumi.Context,
	name string, args *CustomConnectorPluginArgs, opts ...pulumi.ResourceOption) (*CustomConnectorPlugin, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ConnectorClass == nil {
		return nil, errors.New("invalid value for required argument 'ConnectorClass'")
	}
	if args.ConnectorType == nil {
		return nil, errors.New("invalid value for required argument 'ConnectorType'")
	}
	if args.DisplayName == nil {
		return nil, errors.New("invalid value for required argument 'DisplayName'")
	}
	if args.Filename == nil {
		return nil, errors.New("invalid value for required argument 'Filename'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource CustomConnectorPlugin
	err := ctx.RegisterResource("confluentcloud:index/customConnectorPlugin:CustomConnectorPlugin", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCustomConnectorPlugin gets an existing CustomConnectorPlugin resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCustomConnectorPlugin(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CustomConnectorPluginState, opts ...pulumi.ResourceOption) (*CustomConnectorPlugin, error) {
	var resource CustomConnectorPlugin
	err := ctx.ReadResource("confluentcloud:index/customConnectorPlugin:CustomConnectorPlugin", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CustomConnectorPlugin resources.
type customConnectorPluginState struct {
	// Cloud provider where the Custom Connector Plugin archive is uploaded. Defaults to `AWS`. Accepted values are: `AWS`, `AZURE`.
	Cloud *string `pulumi:"cloud"`
	// The Java class or alias for the connector. You can get the connector class from the connector documentation provided by the developer.
	ConnectorClass *string `pulumi:"connectorClass"`
	// The type of the Custom Connector Plugin. Accepted values are: `SOURCE`, `SINK`.
	ConnectorType *string `pulumi:"connectorType"`
	// The description of the Custom Connector Plugin.
	Description *string `pulumi:"description"`
	// The name of the Custom Connector Plugin.
	DisplayName *string `pulumi:"displayName"`
	// The documentation link of the Custom Connector Plugin.
	DocumentationLink *string `pulumi:"documentationLink"`
	// The path to the Custom Connector Plugin archive to be uploaded. Accepted archive formats are: `.jar`, `.zip`.
	Filename *string `pulumi:"filename"`
	// The list of sensitive properties. A sensitive property is a connector configuration property that must be hidden after a user enters the property value when setting up the connector, for example, passwords, keys, and tokens. Refer to the developer documentation and add all required and optional sensitive properties that a user could potentially configure for the connector. Marking a property as sensitive ensures that these fields are handled appropriately within the Confluent infrastructure. This includes masking fields, for example in exception logging, and encrypting field values in the underlying data store. You must identify all sensitive properties. Failure to identify sensitive properties can result in the sensitive property value being stored in plain text rather than in encrypted format. Only add connector-specific sensitive properties. Kafka keys, passwords, and service account information should not be entered here.
	SensitiveConfigProperties []string `pulumi:"sensitiveConfigProperties"`
}

type CustomConnectorPluginState struct {
	// Cloud provider where the Custom Connector Plugin archive is uploaded. Defaults to `AWS`. Accepted values are: `AWS`, `AZURE`.
	Cloud pulumi.StringPtrInput
	// The Java class or alias for the connector. You can get the connector class from the connector documentation provided by the developer.
	ConnectorClass pulumi.StringPtrInput
	// The type of the Custom Connector Plugin. Accepted values are: `SOURCE`, `SINK`.
	ConnectorType pulumi.StringPtrInput
	// The description of the Custom Connector Plugin.
	Description pulumi.StringPtrInput
	// The name of the Custom Connector Plugin.
	DisplayName pulumi.StringPtrInput
	// The documentation link of the Custom Connector Plugin.
	DocumentationLink pulumi.StringPtrInput
	// The path to the Custom Connector Plugin archive to be uploaded. Accepted archive formats are: `.jar`, `.zip`.
	Filename pulumi.StringPtrInput
	// The list of sensitive properties. A sensitive property is a connector configuration property that must be hidden after a user enters the property value when setting up the connector, for example, passwords, keys, and tokens. Refer to the developer documentation and add all required and optional sensitive properties that a user could potentially configure for the connector. Marking a property as sensitive ensures that these fields are handled appropriately within the Confluent infrastructure. This includes masking fields, for example in exception logging, and encrypting field values in the underlying data store. You must identify all sensitive properties. Failure to identify sensitive properties can result in the sensitive property value being stored in plain text rather than in encrypted format. Only add connector-specific sensitive properties. Kafka keys, passwords, and service account information should not be entered here.
	SensitiveConfigProperties pulumi.StringArrayInput
}

func (CustomConnectorPluginState) ElementType() reflect.Type {
	return reflect.TypeOf((*customConnectorPluginState)(nil)).Elem()
}

type customConnectorPluginArgs struct {
	// Cloud provider where the Custom Connector Plugin archive is uploaded. Defaults to `AWS`. Accepted values are: `AWS`, `AZURE`.
	Cloud *string `pulumi:"cloud"`
	// The Java class or alias for the connector. You can get the connector class from the connector documentation provided by the developer.
	ConnectorClass string `pulumi:"connectorClass"`
	// The type of the Custom Connector Plugin. Accepted values are: `SOURCE`, `SINK`.
	ConnectorType string `pulumi:"connectorType"`
	// The description of the Custom Connector Plugin.
	Description *string `pulumi:"description"`
	// The name of the Custom Connector Plugin.
	DisplayName string `pulumi:"displayName"`
	// The documentation link of the Custom Connector Plugin.
	DocumentationLink *string `pulumi:"documentationLink"`
	// The path to the Custom Connector Plugin archive to be uploaded. Accepted archive formats are: `.jar`, `.zip`.
	Filename string `pulumi:"filename"`
	// The list of sensitive properties. A sensitive property is a connector configuration property that must be hidden after a user enters the property value when setting up the connector, for example, passwords, keys, and tokens. Refer to the developer documentation and add all required and optional sensitive properties that a user could potentially configure for the connector. Marking a property as sensitive ensures that these fields are handled appropriately within the Confluent infrastructure. This includes masking fields, for example in exception logging, and encrypting field values in the underlying data store. You must identify all sensitive properties. Failure to identify sensitive properties can result in the sensitive property value being stored in plain text rather than in encrypted format. Only add connector-specific sensitive properties. Kafka keys, passwords, and service account information should not be entered here.
	SensitiveConfigProperties []string `pulumi:"sensitiveConfigProperties"`
}

// The set of arguments for constructing a CustomConnectorPlugin resource.
type CustomConnectorPluginArgs struct {
	// Cloud provider where the Custom Connector Plugin archive is uploaded. Defaults to `AWS`. Accepted values are: `AWS`, `AZURE`.
	Cloud pulumi.StringPtrInput
	// The Java class or alias for the connector. You can get the connector class from the connector documentation provided by the developer.
	ConnectorClass pulumi.StringInput
	// The type of the Custom Connector Plugin. Accepted values are: `SOURCE`, `SINK`.
	ConnectorType pulumi.StringInput
	// The description of the Custom Connector Plugin.
	Description pulumi.StringPtrInput
	// The name of the Custom Connector Plugin.
	DisplayName pulumi.StringInput
	// The documentation link of the Custom Connector Plugin.
	DocumentationLink pulumi.StringPtrInput
	// The path to the Custom Connector Plugin archive to be uploaded. Accepted archive formats are: `.jar`, `.zip`.
	Filename pulumi.StringInput
	// The list of sensitive properties. A sensitive property is a connector configuration property that must be hidden after a user enters the property value when setting up the connector, for example, passwords, keys, and tokens. Refer to the developer documentation and add all required and optional sensitive properties that a user could potentially configure for the connector. Marking a property as sensitive ensures that these fields are handled appropriately within the Confluent infrastructure. This includes masking fields, for example in exception logging, and encrypting field values in the underlying data store. You must identify all sensitive properties. Failure to identify sensitive properties can result in the sensitive property value being stored in plain text rather than in encrypted format. Only add connector-specific sensitive properties. Kafka keys, passwords, and service account information should not be entered here.
	SensitiveConfigProperties pulumi.StringArrayInput
}

func (CustomConnectorPluginArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*customConnectorPluginArgs)(nil)).Elem()
}

type CustomConnectorPluginInput interface {
	pulumi.Input

	ToCustomConnectorPluginOutput() CustomConnectorPluginOutput
	ToCustomConnectorPluginOutputWithContext(ctx context.Context) CustomConnectorPluginOutput
}

func (*CustomConnectorPlugin) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomConnectorPlugin)(nil)).Elem()
}

func (i *CustomConnectorPlugin) ToCustomConnectorPluginOutput() CustomConnectorPluginOutput {
	return i.ToCustomConnectorPluginOutputWithContext(context.Background())
}

func (i *CustomConnectorPlugin) ToCustomConnectorPluginOutputWithContext(ctx context.Context) CustomConnectorPluginOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomConnectorPluginOutput)
}

// CustomConnectorPluginArrayInput is an input type that accepts CustomConnectorPluginArray and CustomConnectorPluginArrayOutput values.
// You can construct a concrete instance of `CustomConnectorPluginArrayInput` via:
//
//	CustomConnectorPluginArray{ CustomConnectorPluginArgs{...} }
type CustomConnectorPluginArrayInput interface {
	pulumi.Input

	ToCustomConnectorPluginArrayOutput() CustomConnectorPluginArrayOutput
	ToCustomConnectorPluginArrayOutputWithContext(context.Context) CustomConnectorPluginArrayOutput
}

type CustomConnectorPluginArray []CustomConnectorPluginInput

func (CustomConnectorPluginArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CustomConnectorPlugin)(nil)).Elem()
}

func (i CustomConnectorPluginArray) ToCustomConnectorPluginArrayOutput() CustomConnectorPluginArrayOutput {
	return i.ToCustomConnectorPluginArrayOutputWithContext(context.Background())
}

func (i CustomConnectorPluginArray) ToCustomConnectorPluginArrayOutputWithContext(ctx context.Context) CustomConnectorPluginArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomConnectorPluginArrayOutput)
}

// CustomConnectorPluginMapInput is an input type that accepts CustomConnectorPluginMap and CustomConnectorPluginMapOutput values.
// You can construct a concrete instance of `CustomConnectorPluginMapInput` via:
//
//	CustomConnectorPluginMap{ "key": CustomConnectorPluginArgs{...} }
type CustomConnectorPluginMapInput interface {
	pulumi.Input

	ToCustomConnectorPluginMapOutput() CustomConnectorPluginMapOutput
	ToCustomConnectorPluginMapOutputWithContext(context.Context) CustomConnectorPluginMapOutput
}

type CustomConnectorPluginMap map[string]CustomConnectorPluginInput

func (CustomConnectorPluginMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CustomConnectorPlugin)(nil)).Elem()
}

func (i CustomConnectorPluginMap) ToCustomConnectorPluginMapOutput() CustomConnectorPluginMapOutput {
	return i.ToCustomConnectorPluginMapOutputWithContext(context.Background())
}

func (i CustomConnectorPluginMap) ToCustomConnectorPluginMapOutputWithContext(ctx context.Context) CustomConnectorPluginMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomConnectorPluginMapOutput)
}

type CustomConnectorPluginOutput struct{ *pulumi.OutputState }

func (CustomConnectorPluginOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomConnectorPlugin)(nil)).Elem()
}

func (o CustomConnectorPluginOutput) ToCustomConnectorPluginOutput() CustomConnectorPluginOutput {
	return o
}

func (o CustomConnectorPluginOutput) ToCustomConnectorPluginOutputWithContext(ctx context.Context) CustomConnectorPluginOutput {
	return o
}

// Cloud provider where the Custom Connector Plugin archive is uploaded. Defaults to `AWS`. Accepted values are: `AWS`, `AZURE`.
func (o CustomConnectorPluginOutput) Cloud() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomConnectorPlugin) pulumi.StringOutput { return v.Cloud }).(pulumi.StringOutput)
}

// The Java class or alias for the connector. You can get the connector class from the connector documentation provided by the developer.
func (o CustomConnectorPluginOutput) ConnectorClass() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomConnectorPlugin) pulumi.StringOutput { return v.ConnectorClass }).(pulumi.StringOutput)
}

// The type of the Custom Connector Plugin. Accepted values are: `SOURCE`, `SINK`.
func (o CustomConnectorPluginOutput) ConnectorType() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomConnectorPlugin) pulumi.StringOutput { return v.ConnectorType }).(pulumi.StringOutput)
}

// The description of the Custom Connector Plugin.
func (o CustomConnectorPluginOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CustomConnectorPlugin) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The name of the Custom Connector Plugin.
func (o CustomConnectorPluginOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomConnectorPlugin) pulumi.StringOutput { return v.DisplayName }).(pulumi.StringOutput)
}

// The documentation link of the Custom Connector Plugin.
func (o CustomConnectorPluginOutput) DocumentationLink() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CustomConnectorPlugin) pulumi.StringPtrOutput { return v.DocumentationLink }).(pulumi.StringPtrOutput)
}

// The path to the Custom Connector Plugin archive to be uploaded. Accepted archive formats are: `.jar`, `.zip`.
func (o CustomConnectorPluginOutput) Filename() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomConnectorPlugin) pulumi.StringOutput { return v.Filename }).(pulumi.StringOutput)
}

// The list of sensitive properties. A sensitive property is a connector configuration property that must be hidden after a user enters the property value when setting up the connector, for example, passwords, keys, and tokens. Refer to the developer documentation and add all required and optional sensitive properties that a user could potentially configure for the connector. Marking a property as sensitive ensures that these fields are handled appropriately within the Confluent infrastructure. This includes masking fields, for example in exception logging, and encrypting field values in the underlying data store. You must identify all sensitive properties. Failure to identify sensitive properties can result in the sensitive property value being stored in plain text rather than in encrypted format. Only add connector-specific sensitive properties. Kafka keys, passwords, and service account information should not be entered here.
func (o CustomConnectorPluginOutput) SensitiveConfigProperties() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CustomConnectorPlugin) pulumi.StringArrayOutput { return v.SensitiveConfigProperties }).(pulumi.StringArrayOutput)
}

type CustomConnectorPluginArrayOutput struct{ *pulumi.OutputState }

func (CustomConnectorPluginArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CustomConnectorPlugin)(nil)).Elem()
}

func (o CustomConnectorPluginArrayOutput) ToCustomConnectorPluginArrayOutput() CustomConnectorPluginArrayOutput {
	return o
}

func (o CustomConnectorPluginArrayOutput) ToCustomConnectorPluginArrayOutputWithContext(ctx context.Context) CustomConnectorPluginArrayOutput {
	return o
}

func (o CustomConnectorPluginArrayOutput) Index(i pulumi.IntInput) CustomConnectorPluginOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *CustomConnectorPlugin {
		return vs[0].([]*CustomConnectorPlugin)[vs[1].(int)]
	}).(CustomConnectorPluginOutput)
}

type CustomConnectorPluginMapOutput struct{ *pulumi.OutputState }

func (CustomConnectorPluginMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CustomConnectorPlugin)(nil)).Elem()
}

func (o CustomConnectorPluginMapOutput) ToCustomConnectorPluginMapOutput() CustomConnectorPluginMapOutput {
	return o
}

func (o CustomConnectorPluginMapOutput) ToCustomConnectorPluginMapOutputWithContext(ctx context.Context) CustomConnectorPluginMapOutput {
	return o
}

func (o CustomConnectorPluginMapOutput) MapIndex(k pulumi.StringInput) CustomConnectorPluginOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *CustomConnectorPlugin {
		return vs[0].(map[string]*CustomConnectorPlugin)[vs[1].(string)]
	}).(CustomConnectorPluginOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CustomConnectorPluginInput)(nil)).Elem(), &CustomConnectorPlugin{})
	pulumi.RegisterInputType(reflect.TypeOf((*CustomConnectorPluginArrayInput)(nil)).Elem(), CustomConnectorPluginArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CustomConnectorPluginMapInput)(nil)).Elem(), CustomConnectorPluginMap{})
	pulumi.RegisterOutputType(CustomConnectorPluginOutput{})
	pulumi.RegisterOutputType(CustomConnectorPluginArrayOutput{})
	pulumi.RegisterOutputType(CustomConnectorPluginMapOutput{})
}
