// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package confluentcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-confluentcloud/sdk/v2/go/confluentcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ### Option #1: Manage multiple Catalog Integrations in the same Pulumi Stack
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-confluentcloud/sdk/v2/go/confluentcloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := confluentcloud.NewCatalogIntegration(ctx, "example", &confluentcloud.CatalogIntegrationArgs{
//				Environment: &confluentcloud.CatalogIntegrationEnvironmentArgs{
//					Id: pulumi.Any(staging.Id),
//				},
//				KafkaCluster: &confluentcloud.CatalogIntegrationKafkaClusterArgs{
//					Id: pulumi.Any(stagingConfluentKafkaCluster.Id),
//				},
//				DisplayName: pulumi.String("catalog-integration-1"),
//				AwsGlue: &confluentcloud.CatalogIntegrationAwsGlueArgs{
//					ProviderIntegrationId: pulumi.Any(main.Id),
//				},
//				Credentials: &confluentcloud.CatalogIntegrationCredentialsArgs{
//					Key:    pulumi.Any(env_admin_tableflow_api_key.Id),
//					Secret: pulumi.Any(env_admin_tableflow_api_key.Secret),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Option #2: Manage a single Catalog Integration in the same Pulumi Stack
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-confluentcloud/sdk/v2/go/confluentcloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := confluentcloud.NewCatalogIntegration(ctx, "example", &confluentcloud.CatalogIntegrationArgs{
//				Environment: &confluentcloud.CatalogIntegrationEnvironmentArgs{
//					Id: pulumi.Any(staging.Id),
//				},
//				KafkaCluster: &confluentcloud.CatalogIntegrationKafkaClusterArgs{
//					Id: pulumi.Any(stagingConfluentKafkaCluster.Id),
//				},
//				DisplayName: pulumi.String("catalog-integration-1"),
//				Snowflake: &confluentcloud.CatalogIntegrationSnowflakeArgs{
//					Endpoint:     pulumi.String("https://vuser1_polaris.snowflakecomputing.com/"),
//					ClientId:     pulumi.String("***REDACTED***"),
//					ClientSecret: pulumi.String("***REDACTED***"),
//					Warehouse:    pulumi.String("catalog-name"),
//					AllowedScope: pulumi.String("session:role:R1"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// You can import a Catalog Integration by using the Catalog Integration name, Environment ID, and Kafka Cluster ID, in the format `<Environment ID>/<Kafka Cluster ID>/<Catalog Integration Id>`, for example:
//
// Option #1: Manage multiple Catalog Integrations in the same Pulumi Stack
//
// $ export IMPORT_TABLEFLOW_API_KEY="<tableflow_api_key>"
//
// $ export IMPORT_TABLEFLOW_API_SECRET="<tableflow_api_secret>"
//
// ```sh
// $ pulumi import confluentcloud:index/catalogIntegration:CatalogIntegration example env-abc123/lkc-abc123/tci-abc123
// ```
//
// Option #2: Manage a single Catalog Integration in the same Pulumi Stack
//
// ```sh
// $ pulumi import confluentcloud:index/catalogIntegration:CatalogIntegration example env-abc123/lkc-abc123/tci-abc123
// ```
//
// !> **Warning:** Do not forget to delete terminal command history afterwards for security purposes.
type CatalogIntegration struct {
	pulumi.CustomResourceState

	// supports the following (see [Integrate Tableflow with the AWS Glue Catalog in Confluent Cloud](https://docs.confluent.io/cloud/current/topics/tableflow/how-to-guides/catalog-integration/integrate-with-aws-glue-catalog.html) for more details):
	AwsGlue CatalogIntegrationAwsGluePtrOutput `pulumi:"awsGlue"`
	// The Cluster API Credentials.
	Credentials CatalogIntegrationCredentialsPtrOutput `pulumi:"credentials"`
	// The name of the catalog integration.
	DisplayName pulumi.StringOutput `pulumi:"displayName"`
	// Environment objects represent an isolated namespace for your Confluent resources for organizational purposes.
	Environment  CatalogIntegrationEnvironmentOutput  `pulumi:"environment"`
	KafkaCluster CatalogIntegrationKafkaClusterOutput `pulumi:"kafkaCluster"`
	// supports the following (see [Integrate Tableflow with Snowflake Open Catalog or Apache Polaris in Confluent Cloud](https://docs.confluent.io/cloud/current/topics/tableflow/how-to-guides/catalog-integration/integrate-with-snowflake-open-catalog-or-apache-polaris.html) for more details):
	Snowflake CatalogIntegrationSnowflakePtrOutput `pulumi:"snowflake"`
	// (Optional Boolean) Indicates whether the Catalog Integration should be suspended.
	Suspended pulumi.BoolOutput `pulumi:"suspended"`
}

// NewCatalogIntegration registers a new resource with the given unique name, arguments, and options.
func NewCatalogIntegration(ctx *pulumi.Context,
	name string, args *CatalogIntegrationArgs, opts ...pulumi.ResourceOption) (*CatalogIntegration, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DisplayName == nil {
		return nil, errors.New("invalid value for required argument 'DisplayName'")
	}
	if args.Environment == nil {
		return nil, errors.New("invalid value for required argument 'Environment'")
	}
	if args.KafkaCluster == nil {
		return nil, errors.New("invalid value for required argument 'KafkaCluster'")
	}
	if args.Credentials != nil {
		args.Credentials = pulumi.ToSecret(args.Credentials).(CatalogIntegrationCredentialsPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"credentials",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource CatalogIntegration
	err := ctx.RegisterResource("confluentcloud:index/catalogIntegration:CatalogIntegration", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCatalogIntegration gets an existing CatalogIntegration resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCatalogIntegration(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CatalogIntegrationState, opts ...pulumi.ResourceOption) (*CatalogIntegration, error) {
	var resource CatalogIntegration
	err := ctx.ReadResource("confluentcloud:index/catalogIntegration:CatalogIntegration", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CatalogIntegration resources.
type catalogIntegrationState struct {
	// supports the following (see [Integrate Tableflow with the AWS Glue Catalog in Confluent Cloud](https://docs.confluent.io/cloud/current/topics/tableflow/how-to-guides/catalog-integration/integrate-with-aws-glue-catalog.html) for more details):
	AwsGlue *CatalogIntegrationAwsGlue `pulumi:"awsGlue"`
	// The Cluster API Credentials.
	Credentials *CatalogIntegrationCredentials `pulumi:"credentials"`
	// The name of the catalog integration.
	DisplayName *string `pulumi:"displayName"`
	// Environment objects represent an isolated namespace for your Confluent resources for organizational purposes.
	Environment  *CatalogIntegrationEnvironment  `pulumi:"environment"`
	KafkaCluster *CatalogIntegrationKafkaCluster `pulumi:"kafkaCluster"`
	// supports the following (see [Integrate Tableflow with Snowflake Open Catalog or Apache Polaris in Confluent Cloud](https://docs.confluent.io/cloud/current/topics/tableflow/how-to-guides/catalog-integration/integrate-with-snowflake-open-catalog-or-apache-polaris.html) for more details):
	Snowflake *CatalogIntegrationSnowflake `pulumi:"snowflake"`
	// (Optional Boolean) Indicates whether the Catalog Integration should be suspended.
	Suspended *bool `pulumi:"suspended"`
}

type CatalogIntegrationState struct {
	// supports the following (see [Integrate Tableflow with the AWS Glue Catalog in Confluent Cloud](https://docs.confluent.io/cloud/current/topics/tableflow/how-to-guides/catalog-integration/integrate-with-aws-glue-catalog.html) for more details):
	AwsGlue CatalogIntegrationAwsGluePtrInput
	// The Cluster API Credentials.
	Credentials CatalogIntegrationCredentialsPtrInput
	// The name of the catalog integration.
	DisplayName pulumi.StringPtrInput
	// Environment objects represent an isolated namespace for your Confluent resources for organizational purposes.
	Environment  CatalogIntegrationEnvironmentPtrInput
	KafkaCluster CatalogIntegrationKafkaClusterPtrInput
	// supports the following (see [Integrate Tableflow with Snowflake Open Catalog or Apache Polaris in Confluent Cloud](https://docs.confluent.io/cloud/current/topics/tableflow/how-to-guides/catalog-integration/integrate-with-snowflake-open-catalog-or-apache-polaris.html) for more details):
	Snowflake CatalogIntegrationSnowflakePtrInput
	// (Optional Boolean) Indicates whether the Catalog Integration should be suspended.
	Suspended pulumi.BoolPtrInput
}

func (CatalogIntegrationState) ElementType() reflect.Type {
	return reflect.TypeOf((*catalogIntegrationState)(nil)).Elem()
}

type catalogIntegrationArgs struct {
	// supports the following (see [Integrate Tableflow with the AWS Glue Catalog in Confluent Cloud](https://docs.confluent.io/cloud/current/topics/tableflow/how-to-guides/catalog-integration/integrate-with-aws-glue-catalog.html) for more details):
	AwsGlue *CatalogIntegrationAwsGlue `pulumi:"awsGlue"`
	// The Cluster API Credentials.
	Credentials *CatalogIntegrationCredentials `pulumi:"credentials"`
	// The name of the catalog integration.
	DisplayName string `pulumi:"displayName"`
	// Environment objects represent an isolated namespace for your Confluent resources for organizational purposes.
	Environment  CatalogIntegrationEnvironment  `pulumi:"environment"`
	KafkaCluster CatalogIntegrationKafkaCluster `pulumi:"kafkaCluster"`
	// supports the following (see [Integrate Tableflow with Snowflake Open Catalog or Apache Polaris in Confluent Cloud](https://docs.confluent.io/cloud/current/topics/tableflow/how-to-guides/catalog-integration/integrate-with-snowflake-open-catalog-or-apache-polaris.html) for more details):
	Snowflake *CatalogIntegrationSnowflake `pulumi:"snowflake"`
}

// The set of arguments for constructing a CatalogIntegration resource.
type CatalogIntegrationArgs struct {
	// supports the following (see [Integrate Tableflow with the AWS Glue Catalog in Confluent Cloud](https://docs.confluent.io/cloud/current/topics/tableflow/how-to-guides/catalog-integration/integrate-with-aws-glue-catalog.html) for more details):
	AwsGlue CatalogIntegrationAwsGluePtrInput
	// The Cluster API Credentials.
	Credentials CatalogIntegrationCredentialsPtrInput
	// The name of the catalog integration.
	DisplayName pulumi.StringInput
	// Environment objects represent an isolated namespace for your Confluent resources for organizational purposes.
	Environment  CatalogIntegrationEnvironmentInput
	KafkaCluster CatalogIntegrationKafkaClusterInput
	// supports the following (see [Integrate Tableflow with Snowflake Open Catalog or Apache Polaris in Confluent Cloud](https://docs.confluent.io/cloud/current/topics/tableflow/how-to-guides/catalog-integration/integrate-with-snowflake-open-catalog-or-apache-polaris.html) for more details):
	Snowflake CatalogIntegrationSnowflakePtrInput
}

func (CatalogIntegrationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*catalogIntegrationArgs)(nil)).Elem()
}

type CatalogIntegrationInput interface {
	pulumi.Input

	ToCatalogIntegrationOutput() CatalogIntegrationOutput
	ToCatalogIntegrationOutputWithContext(ctx context.Context) CatalogIntegrationOutput
}

func (*CatalogIntegration) ElementType() reflect.Type {
	return reflect.TypeOf((**CatalogIntegration)(nil)).Elem()
}

func (i *CatalogIntegration) ToCatalogIntegrationOutput() CatalogIntegrationOutput {
	return i.ToCatalogIntegrationOutputWithContext(context.Background())
}

func (i *CatalogIntegration) ToCatalogIntegrationOutputWithContext(ctx context.Context) CatalogIntegrationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CatalogIntegrationOutput)
}

// CatalogIntegrationArrayInput is an input type that accepts CatalogIntegrationArray and CatalogIntegrationArrayOutput values.
// You can construct a concrete instance of `CatalogIntegrationArrayInput` via:
//
//	CatalogIntegrationArray{ CatalogIntegrationArgs{...} }
type CatalogIntegrationArrayInput interface {
	pulumi.Input

	ToCatalogIntegrationArrayOutput() CatalogIntegrationArrayOutput
	ToCatalogIntegrationArrayOutputWithContext(context.Context) CatalogIntegrationArrayOutput
}

type CatalogIntegrationArray []CatalogIntegrationInput

func (CatalogIntegrationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CatalogIntegration)(nil)).Elem()
}

func (i CatalogIntegrationArray) ToCatalogIntegrationArrayOutput() CatalogIntegrationArrayOutput {
	return i.ToCatalogIntegrationArrayOutputWithContext(context.Background())
}

func (i CatalogIntegrationArray) ToCatalogIntegrationArrayOutputWithContext(ctx context.Context) CatalogIntegrationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CatalogIntegrationArrayOutput)
}

// CatalogIntegrationMapInput is an input type that accepts CatalogIntegrationMap and CatalogIntegrationMapOutput values.
// You can construct a concrete instance of `CatalogIntegrationMapInput` via:
//
//	CatalogIntegrationMap{ "key": CatalogIntegrationArgs{...} }
type CatalogIntegrationMapInput interface {
	pulumi.Input

	ToCatalogIntegrationMapOutput() CatalogIntegrationMapOutput
	ToCatalogIntegrationMapOutputWithContext(context.Context) CatalogIntegrationMapOutput
}

type CatalogIntegrationMap map[string]CatalogIntegrationInput

func (CatalogIntegrationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CatalogIntegration)(nil)).Elem()
}

func (i CatalogIntegrationMap) ToCatalogIntegrationMapOutput() CatalogIntegrationMapOutput {
	return i.ToCatalogIntegrationMapOutputWithContext(context.Background())
}

func (i CatalogIntegrationMap) ToCatalogIntegrationMapOutputWithContext(ctx context.Context) CatalogIntegrationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CatalogIntegrationMapOutput)
}

type CatalogIntegrationOutput struct{ *pulumi.OutputState }

func (CatalogIntegrationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CatalogIntegration)(nil)).Elem()
}

func (o CatalogIntegrationOutput) ToCatalogIntegrationOutput() CatalogIntegrationOutput {
	return o
}

func (o CatalogIntegrationOutput) ToCatalogIntegrationOutputWithContext(ctx context.Context) CatalogIntegrationOutput {
	return o
}

// supports the following (see [Integrate Tableflow with the AWS Glue Catalog in Confluent Cloud](https://docs.confluent.io/cloud/current/topics/tableflow/how-to-guides/catalog-integration/integrate-with-aws-glue-catalog.html) for more details):
func (o CatalogIntegrationOutput) AwsGlue() CatalogIntegrationAwsGluePtrOutput {
	return o.ApplyT(func(v *CatalogIntegration) CatalogIntegrationAwsGluePtrOutput { return v.AwsGlue }).(CatalogIntegrationAwsGluePtrOutput)
}

// The Cluster API Credentials.
func (o CatalogIntegrationOutput) Credentials() CatalogIntegrationCredentialsPtrOutput {
	return o.ApplyT(func(v *CatalogIntegration) CatalogIntegrationCredentialsPtrOutput { return v.Credentials }).(CatalogIntegrationCredentialsPtrOutput)
}

// The name of the catalog integration.
func (o CatalogIntegrationOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v *CatalogIntegration) pulumi.StringOutput { return v.DisplayName }).(pulumi.StringOutput)
}

// Environment objects represent an isolated namespace for your Confluent resources for organizational purposes.
func (o CatalogIntegrationOutput) Environment() CatalogIntegrationEnvironmentOutput {
	return o.ApplyT(func(v *CatalogIntegration) CatalogIntegrationEnvironmentOutput { return v.Environment }).(CatalogIntegrationEnvironmentOutput)
}

func (o CatalogIntegrationOutput) KafkaCluster() CatalogIntegrationKafkaClusterOutput {
	return o.ApplyT(func(v *CatalogIntegration) CatalogIntegrationKafkaClusterOutput { return v.KafkaCluster }).(CatalogIntegrationKafkaClusterOutput)
}

// supports the following (see [Integrate Tableflow with Snowflake Open Catalog or Apache Polaris in Confluent Cloud](https://docs.confluent.io/cloud/current/topics/tableflow/how-to-guides/catalog-integration/integrate-with-snowflake-open-catalog-or-apache-polaris.html) for more details):
func (o CatalogIntegrationOutput) Snowflake() CatalogIntegrationSnowflakePtrOutput {
	return o.ApplyT(func(v *CatalogIntegration) CatalogIntegrationSnowflakePtrOutput { return v.Snowflake }).(CatalogIntegrationSnowflakePtrOutput)
}

// (Optional Boolean) Indicates whether the Catalog Integration should be suspended.
func (o CatalogIntegrationOutput) Suspended() pulumi.BoolOutput {
	return o.ApplyT(func(v *CatalogIntegration) pulumi.BoolOutput { return v.Suspended }).(pulumi.BoolOutput)
}

type CatalogIntegrationArrayOutput struct{ *pulumi.OutputState }

func (CatalogIntegrationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CatalogIntegration)(nil)).Elem()
}

func (o CatalogIntegrationArrayOutput) ToCatalogIntegrationArrayOutput() CatalogIntegrationArrayOutput {
	return o
}

func (o CatalogIntegrationArrayOutput) ToCatalogIntegrationArrayOutputWithContext(ctx context.Context) CatalogIntegrationArrayOutput {
	return o
}

func (o CatalogIntegrationArrayOutput) Index(i pulumi.IntInput) CatalogIntegrationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *CatalogIntegration {
		return vs[0].([]*CatalogIntegration)[vs[1].(int)]
	}).(CatalogIntegrationOutput)
}

type CatalogIntegrationMapOutput struct{ *pulumi.OutputState }

func (CatalogIntegrationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CatalogIntegration)(nil)).Elem()
}

func (o CatalogIntegrationMapOutput) ToCatalogIntegrationMapOutput() CatalogIntegrationMapOutput {
	return o
}

func (o CatalogIntegrationMapOutput) ToCatalogIntegrationMapOutputWithContext(ctx context.Context) CatalogIntegrationMapOutput {
	return o
}

func (o CatalogIntegrationMapOutput) MapIndex(k pulumi.StringInput) CatalogIntegrationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *CatalogIntegration {
		return vs[0].(map[string]*CatalogIntegration)[vs[1].(string)]
	}).(CatalogIntegrationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CatalogIntegrationInput)(nil)).Elem(), &CatalogIntegration{})
	pulumi.RegisterInputType(reflect.TypeOf((*CatalogIntegrationArrayInput)(nil)).Elem(), CatalogIntegrationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CatalogIntegrationMapInput)(nil)).Elem(), CatalogIntegrationMap{})
	pulumi.RegisterOutputType(CatalogIntegrationOutput{})
	pulumi.RegisterOutputType(CatalogIntegrationArrayOutput{})
	pulumi.RegisterOutputType(CatalogIntegrationMapOutput{})
}
