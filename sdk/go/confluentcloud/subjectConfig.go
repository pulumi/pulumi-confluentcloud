// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package confluentcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-confluentcloud/sdk/v2/go/confluentcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](https://docs.confluent.io/cloud/current/api.html#section/Versioning/API-Lifecycle-Policy)
//
// `SubjectConfig` provides a Subject Config resource that enables updating Subject Config on a Schema Registry cluster on Confluent Cloud.
//
// > **Note:** It is recommended to set `lifecycle { preventDestroy = true }` on production instances to prevent accidental subject config deletion. This setting rejects plans that would destroy or recreate the subject config, such as attempting to change uneditable attributes. Read more about it in the Terraform docs.
//
// ## Example Usage
//
// ### Option #1: Manage multiple Schema Registry clusters in the same Pulumi Stack
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-confluentcloud/sdk/v2/go/confluentcloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := confluentcloud.NewSubjectConfig(ctx, "example", &confluentcloud.SubjectConfigArgs{
//				SchemaRegistryCluster: &confluentcloud.SubjectConfigSchemaRegistryClusterArgs{
//					Id: pulumi.Any(essentials.Id),
//				},
//				RestEndpoint:       pulumi.Any(essentialsConfluentSchemaRegistryCluster.RestEndpoint),
//				SubjectName:        pulumi.String("proto-purchase-value"),
//				CompatibilityLevel: pulumi.String("BACKWARD"),
//				CompatibilityGroup: pulumi.String("abc.cg.version"),
//				Normalize:          pulumi.Bool(true),
//				Credentials: &confluentcloud.SubjectConfigCredentialsArgs{
//					Key:    pulumi.String("<Schema Registry API Key for data.confluent_schema_registry_cluster.essentials>"),
//					Secret: pulumi.String("<Schema Registry API Secret for data.confluent_schema_registry_cluster.essentials>"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Option #2: Manage a single Schema Registry cluster in the same Pulumi Stack
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-confluentcloud/sdk/v2/go/confluentcloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := confluentcloud.NewSubjectConfig(ctx, "example", &confluentcloud.SubjectConfigArgs{
//				SubjectName:        pulumi.String("proto-purchase-value"),
//				CompatibilityLevel: pulumi.String("BACKWARD"),
//				CompatibilityGroup: pulumi.String("abc.cg.version"),
//				Normalize:          pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Example: Creating a Subject Alias
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-confluentcloud/sdk/v2/go/confluentcloud"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			invokeFile, err := std.File(ctx, map[string]interface{}{
//				"input": "./schemas/avro/orders.avsc",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			// First, ensure the original subject exists with a schema
//			original, err := confluentcloud.NewSchema(ctx, "original", &confluentcloud.SchemaArgs{
//				SubjectName: pulumi.String("orders-long-subject-name-value"),
//				Format:      pulumi.String("AVRO"),
//				Schema:      invokeFile.Result,
//			})
//			if err != nil {
//				return err
//			}
//			// Create an alias that points to the original subject
//			// Any reference to "orders-value" will now resolve to "orders-long-subject-name-value"
//			_, err = confluentcloud.NewSubjectConfig(ctx, "orders_alias", &confluentcloud.SubjectConfigArgs{
//				SubjectName: pulumi.String("orders-value"),
//				Alias:       pulumi.String("orders-long-subject-name-value"),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				original,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// You can import a Subject Config by using the Schema Registry cluster ID, Subject name in the format `<Schema Registry cluster ID>/<Subject name>`, for example:
//
// ```sh
// $ export IMPORT_SCHEMA_REGISTRY_API_KEY="<schema_registry_api_key>"
// $ export IMPORT_SCHEMA_REGISTRY_API_SECRET="<schema_registry_api_secret>"
// $ export IMPORT_SCHEMA_REGISTRY_REST_ENDPOINT="<schema_registry_rest_endpoint>"
// $ pulumi import confluentcloud:index/subjectConfig:SubjectConfig example lsrc-abc123/test-subject
// ```
//
// !> **Warning:** Do not forget to delete terminal command history afterwards for security purposes.
type SubjectConfig struct {
	pulumi.CustomResourceState

	// The subject name that this subject is an alias for. Any reference to this subject will be replaced by the alias. See [Subject Aliases](https://docs.confluent.io/platform/current/schema-registry/fundamentals/index.html#subject-aliases) for more details.
	//
	// > **Note:** To create an alias for a subject, create a new subject config where `subjectName` is the alias and `alias` points to the real subject. For example, to create an alias `short-name` that points to subject `very-long-subject-name`, set `subjectName = "short-name"` and `alias = "very-long-subject-name"`.
	Alias pulumi.StringOutput `pulumi:"alias"`
	// The Compatibility Group of the specified subject.
	CompatibilityGroup pulumi.StringOutput `pulumi:"compatibilityGroup"`
	// The Compatibility Level of the specified subject. Accepted values are: `BACKWARD`, `BACKWARD_TRANSITIVE`, `FORWARD`, `FORWARD_TRANSITIVE`, `FULL`, `FULL_TRANSITIVE`, and `NONE`. See the [Compatibility Types](https://docs.confluent.io/platform/current/schema-registry/avro.html#compatibility-types) for more details.
	CompatibilityLevel pulumi.StringOutput `pulumi:"compatibilityLevel"`
	// The Cluster API Credentials.
	Credentials SubjectConfigCredentialsPtrOutput `pulumi:"credentials"`
	// Whether schemas are automatically normalized when registered or passed during lookups.
	Normalize pulumi.BoolOutput `pulumi:"normalize"`
	// The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
	RestEndpoint          pulumi.StringPtrOutput                      `pulumi:"restEndpoint"`
	SchemaRegistryCluster SubjectConfigSchemaRegistryClusterPtrOutput `pulumi:"schemaRegistryCluster"`
	// The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`.
	//
	// > **Note:** If you want to reference the subject that is located in a custom context, use the following naming pattern: `:.contextName:subjectName`. For example, use `subjectName = ":.context1:test-subject"` to reference the subject named `test-subject` in the `context1` context, and use `subjectName = "test-subject"` to reference the subject named `test-subject` in the `default` context.
	//
	// > **Note:** To configure a config at the context level, affecting all subjects created within that context, use the following naming pattern: `:.contextName:`. For example, to set the global configuration for the `context1` context, use `subjectName = ":.context1:"`.
	SubjectName pulumi.StringOutput `pulumi:"subjectName"`
}

// NewSubjectConfig registers a new resource with the given unique name, arguments, and options.
func NewSubjectConfig(ctx *pulumi.Context,
	name string, args *SubjectConfigArgs, opts ...pulumi.ResourceOption) (*SubjectConfig, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.SubjectName == nil {
		return nil, errors.New("invalid value for required argument 'SubjectName'")
	}
	if args.Credentials != nil {
		args.Credentials = pulumi.ToSecret(args.Credentials).(SubjectConfigCredentialsPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"credentials",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SubjectConfig
	err := ctx.RegisterResource("confluentcloud:index/subjectConfig:SubjectConfig", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSubjectConfig gets an existing SubjectConfig resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSubjectConfig(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SubjectConfigState, opts ...pulumi.ResourceOption) (*SubjectConfig, error) {
	var resource SubjectConfig
	err := ctx.ReadResource("confluentcloud:index/subjectConfig:SubjectConfig", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SubjectConfig resources.
type subjectConfigState struct {
	// The subject name that this subject is an alias for. Any reference to this subject will be replaced by the alias. See [Subject Aliases](https://docs.confluent.io/platform/current/schema-registry/fundamentals/index.html#subject-aliases) for more details.
	//
	// > **Note:** To create an alias for a subject, create a new subject config where `subjectName` is the alias and `alias` points to the real subject. For example, to create an alias `short-name` that points to subject `very-long-subject-name`, set `subjectName = "short-name"` and `alias = "very-long-subject-name"`.
	Alias *string `pulumi:"alias"`
	// The Compatibility Group of the specified subject.
	CompatibilityGroup *string `pulumi:"compatibilityGroup"`
	// The Compatibility Level of the specified subject. Accepted values are: `BACKWARD`, `BACKWARD_TRANSITIVE`, `FORWARD`, `FORWARD_TRANSITIVE`, `FULL`, `FULL_TRANSITIVE`, and `NONE`. See the [Compatibility Types](https://docs.confluent.io/platform/current/schema-registry/avro.html#compatibility-types) for more details.
	CompatibilityLevel *string `pulumi:"compatibilityLevel"`
	// The Cluster API Credentials.
	Credentials *SubjectConfigCredentials `pulumi:"credentials"`
	// Whether schemas are automatically normalized when registered or passed during lookups.
	Normalize *bool `pulumi:"normalize"`
	// The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
	RestEndpoint          *string                             `pulumi:"restEndpoint"`
	SchemaRegistryCluster *SubjectConfigSchemaRegistryCluster `pulumi:"schemaRegistryCluster"`
	// The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`.
	//
	// > **Note:** If you want to reference the subject that is located in a custom context, use the following naming pattern: `:.contextName:subjectName`. For example, use `subjectName = ":.context1:test-subject"` to reference the subject named `test-subject` in the `context1` context, and use `subjectName = "test-subject"` to reference the subject named `test-subject` in the `default` context.
	//
	// > **Note:** To configure a config at the context level, affecting all subjects created within that context, use the following naming pattern: `:.contextName:`. For example, to set the global configuration for the `context1` context, use `subjectName = ":.context1:"`.
	SubjectName *string `pulumi:"subjectName"`
}

type SubjectConfigState struct {
	// The subject name that this subject is an alias for. Any reference to this subject will be replaced by the alias. See [Subject Aliases](https://docs.confluent.io/platform/current/schema-registry/fundamentals/index.html#subject-aliases) for more details.
	//
	// > **Note:** To create an alias for a subject, create a new subject config where `subjectName` is the alias and `alias` points to the real subject. For example, to create an alias `short-name` that points to subject `very-long-subject-name`, set `subjectName = "short-name"` and `alias = "very-long-subject-name"`.
	Alias pulumi.StringPtrInput
	// The Compatibility Group of the specified subject.
	CompatibilityGroup pulumi.StringPtrInput
	// The Compatibility Level of the specified subject. Accepted values are: `BACKWARD`, `BACKWARD_TRANSITIVE`, `FORWARD`, `FORWARD_TRANSITIVE`, `FULL`, `FULL_TRANSITIVE`, and `NONE`. See the [Compatibility Types](https://docs.confluent.io/platform/current/schema-registry/avro.html#compatibility-types) for more details.
	CompatibilityLevel pulumi.StringPtrInput
	// The Cluster API Credentials.
	Credentials SubjectConfigCredentialsPtrInput
	// Whether schemas are automatically normalized when registered or passed during lookups.
	Normalize pulumi.BoolPtrInput
	// The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
	RestEndpoint          pulumi.StringPtrInput
	SchemaRegistryCluster SubjectConfigSchemaRegistryClusterPtrInput
	// The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`.
	//
	// > **Note:** If you want to reference the subject that is located in a custom context, use the following naming pattern: `:.contextName:subjectName`. For example, use `subjectName = ":.context1:test-subject"` to reference the subject named `test-subject` in the `context1` context, and use `subjectName = "test-subject"` to reference the subject named `test-subject` in the `default` context.
	//
	// > **Note:** To configure a config at the context level, affecting all subjects created within that context, use the following naming pattern: `:.contextName:`. For example, to set the global configuration for the `context1` context, use `subjectName = ":.context1:"`.
	SubjectName pulumi.StringPtrInput
}

func (SubjectConfigState) ElementType() reflect.Type {
	return reflect.TypeOf((*subjectConfigState)(nil)).Elem()
}

type subjectConfigArgs struct {
	// The subject name that this subject is an alias for. Any reference to this subject will be replaced by the alias. See [Subject Aliases](https://docs.confluent.io/platform/current/schema-registry/fundamentals/index.html#subject-aliases) for more details.
	//
	// > **Note:** To create an alias for a subject, create a new subject config where `subjectName` is the alias and `alias` points to the real subject. For example, to create an alias `short-name` that points to subject `very-long-subject-name`, set `subjectName = "short-name"` and `alias = "very-long-subject-name"`.
	Alias *string `pulumi:"alias"`
	// The Compatibility Group of the specified subject.
	CompatibilityGroup *string `pulumi:"compatibilityGroup"`
	// The Compatibility Level of the specified subject. Accepted values are: `BACKWARD`, `BACKWARD_TRANSITIVE`, `FORWARD`, `FORWARD_TRANSITIVE`, `FULL`, `FULL_TRANSITIVE`, and `NONE`. See the [Compatibility Types](https://docs.confluent.io/platform/current/schema-registry/avro.html#compatibility-types) for more details.
	CompatibilityLevel *string `pulumi:"compatibilityLevel"`
	// The Cluster API Credentials.
	Credentials *SubjectConfigCredentials `pulumi:"credentials"`
	// Whether schemas are automatically normalized when registered or passed during lookups.
	Normalize *bool `pulumi:"normalize"`
	// The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
	RestEndpoint          *string                             `pulumi:"restEndpoint"`
	SchemaRegistryCluster *SubjectConfigSchemaRegistryCluster `pulumi:"schemaRegistryCluster"`
	// The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`.
	//
	// > **Note:** If you want to reference the subject that is located in a custom context, use the following naming pattern: `:.contextName:subjectName`. For example, use `subjectName = ":.context1:test-subject"` to reference the subject named `test-subject` in the `context1` context, and use `subjectName = "test-subject"` to reference the subject named `test-subject` in the `default` context.
	//
	// > **Note:** To configure a config at the context level, affecting all subjects created within that context, use the following naming pattern: `:.contextName:`. For example, to set the global configuration for the `context1` context, use `subjectName = ":.context1:"`.
	SubjectName string `pulumi:"subjectName"`
}

// The set of arguments for constructing a SubjectConfig resource.
type SubjectConfigArgs struct {
	// The subject name that this subject is an alias for. Any reference to this subject will be replaced by the alias. See [Subject Aliases](https://docs.confluent.io/platform/current/schema-registry/fundamentals/index.html#subject-aliases) for more details.
	//
	// > **Note:** To create an alias for a subject, create a new subject config where `subjectName` is the alias and `alias` points to the real subject. For example, to create an alias `short-name` that points to subject `very-long-subject-name`, set `subjectName = "short-name"` and `alias = "very-long-subject-name"`.
	Alias pulumi.StringPtrInput
	// The Compatibility Group of the specified subject.
	CompatibilityGroup pulumi.StringPtrInput
	// The Compatibility Level of the specified subject. Accepted values are: `BACKWARD`, `BACKWARD_TRANSITIVE`, `FORWARD`, `FORWARD_TRANSITIVE`, `FULL`, `FULL_TRANSITIVE`, and `NONE`. See the [Compatibility Types](https://docs.confluent.io/platform/current/schema-registry/avro.html#compatibility-types) for more details.
	CompatibilityLevel pulumi.StringPtrInput
	// The Cluster API Credentials.
	Credentials SubjectConfigCredentialsPtrInput
	// Whether schemas are automatically normalized when registered or passed during lookups.
	Normalize pulumi.BoolPtrInput
	// The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
	RestEndpoint          pulumi.StringPtrInput
	SchemaRegistryCluster SubjectConfigSchemaRegistryClusterPtrInput
	// The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`.
	//
	// > **Note:** If you want to reference the subject that is located in a custom context, use the following naming pattern: `:.contextName:subjectName`. For example, use `subjectName = ":.context1:test-subject"` to reference the subject named `test-subject` in the `context1` context, and use `subjectName = "test-subject"` to reference the subject named `test-subject` in the `default` context.
	//
	// > **Note:** To configure a config at the context level, affecting all subjects created within that context, use the following naming pattern: `:.contextName:`. For example, to set the global configuration for the `context1` context, use `subjectName = ":.context1:"`.
	SubjectName pulumi.StringInput
}

func (SubjectConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*subjectConfigArgs)(nil)).Elem()
}

type SubjectConfigInput interface {
	pulumi.Input

	ToSubjectConfigOutput() SubjectConfigOutput
	ToSubjectConfigOutputWithContext(ctx context.Context) SubjectConfigOutput
}

func (*SubjectConfig) ElementType() reflect.Type {
	return reflect.TypeOf((**SubjectConfig)(nil)).Elem()
}

func (i *SubjectConfig) ToSubjectConfigOutput() SubjectConfigOutput {
	return i.ToSubjectConfigOutputWithContext(context.Background())
}

func (i *SubjectConfig) ToSubjectConfigOutputWithContext(ctx context.Context) SubjectConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubjectConfigOutput)
}

// SubjectConfigArrayInput is an input type that accepts SubjectConfigArray and SubjectConfigArrayOutput values.
// You can construct a concrete instance of `SubjectConfigArrayInput` via:
//
//	SubjectConfigArray{ SubjectConfigArgs{...} }
type SubjectConfigArrayInput interface {
	pulumi.Input

	ToSubjectConfigArrayOutput() SubjectConfigArrayOutput
	ToSubjectConfigArrayOutputWithContext(context.Context) SubjectConfigArrayOutput
}

type SubjectConfigArray []SubjectConfigInput

func (SubjectConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SubjectConfig)(nil)).Elem()
}

func (i SubjectConfigArray) ToSubjectConfigArrayOutput() SubjectConfigArrayOutput {
	return i.ToSubjectConfigArrayOutputWithContext(context.Background())
}

func (i SubjectConfigArray) ToSubjectConfigArrayOutputWithContext(ctx context.Context) SubjectConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubjectConfigArrayOutput)
}

// SubjectConfigMapInput is an input type that accepts SubjectConfigMap and SubjectConfigMapOutput values.
// You can construct a concrete instance of `SubjectConfigMapInput` via:
//
//	SubjectConfigMap{ "key": SubjectConfigArgs{...} }
type SubjectConfigMapInput interface {
	pulumi.Input

	ToSubjectConfigMapOutput() SubjectConfigMapOutput
	ToSubjectConfigMapOutputWithContext(context.Context) SubjectConfigMapOutput
}

type SubjectConfigMap map[string]SubjectConfigInput

func (SubjectConfigMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SubjectConfig)(nil)).Elem()
}

func (i SubjectConfigMap) ToSubjectConfigMapOutput() SubjectConfigMapOutput {
	return i.ToSubjectConfigMapOutputWithContext(context.Background())
}

func (i SubjectConfigMap) ToSubjectConfigMapOutputWithContext(ctx context.Context) SubjectConfigMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubjectConfigMapOutput)
}

type SubjectConfigOutput struct{ *pulumi.OutputState }

func (SubjectConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubjectConfig)(nil)).Elem()
}

func (o SubjectConfigOutput) ToSubjectConfigOutput() SubjectConfigOutput {
	return o
}

func (o SubjectConfigOutput) ToSubjectConfigOutputWithContext(ctx context.Context) SubjectConfigOutput {
	return o
}

// The subject name that this subject is an alias for. Any reference to this subject will be replaced by the alias. See [Subject Aliases](https://docs.confluent.io/platform/current/schema-registry/fundamentals/index.html#subject-aliases) for more details.
//
// > **Note:** To create an alias for a subject, create a new subject config where `subjectName` is the alias and `alias` points to the real subject. For example, to create an alias `short-name` that points to subject `very-long-subject-name`, set `subjectName = "short-name"` and `alias = "very-long-subject-name"`.
func (o SubjectConfigOutput) Alias() pulumi.StringOutput {
	return o.ApplyT(func(v *SubjectConfig) pulumi.StringOutput { return v.Alias }).(pulumi.StringOutput)
}

// The Compatibility Group of the specified subject.
func (o SubjectConfigOutput) CompatibilityGroup() pulumi.StringOutput {
	return o.ApplyT(func(v *SubjectConfig) pulumi.StringOutput { return v.CompatibilityGroup }).(pulumi.StringOutput)
}

// The Compatibility Level of the specified subject. Accepted values are: `BACKWARD`, `BACKWARD_TRANSITIVE`, `FORWARD`, `FORWARD_TRANSITIVE`, `FULL`, `FULL_TRANSITIVE`, and `NONE`. See the [Compatibility Types](https://docs.confluent.io/platform/current/schema-registry/avro.html#compatibility-types) for more details.
func (o SubjectConfigOutput) CompatibilityLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *SubjectConfig) pulumi.StringOutput { return v.CompatibilityLevel }).(pulumi.StringOutput)
}

// The Cluster API Credentials.
func (o SubjectConfigOutput) Credentials() SubjectConfigCredentialsPtrOutput {
	return o.ApplyT(func(v *SubjectConfig) SubjectConfigCredentialsPtrOutput { return v.Credentials }).(SubjectConfigCredentialsPtrOutput)
}

// Whether schemas are automatically normalized when registered or passed during lookups.
func (o SubjectConfigOutput) Normalize() pulumi.BoolOutput {
	return o.ApplyT(func(v *SubjectConfig) pulumi.BoolOutput { return v.Normalize }).(pulumi.BoolOutput)
}

// The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
func (o SubjectConfigOutput) RestEndpoint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubjectConfig) pulumi.StringPtrOutput { return v.RestEndpoint }).(pulumi.StringPtrOutput)
}

func (o SubjectConfigOutput) SchemaRegistryCluster() SubjectConfigSchemaRegistryClusterPtrOutput {
	return o.ApplyT(func(v *SubjectConfig) SubjectConfigSchemaRegistryClusterPtrOutput { return v.SchemaRegistryCluster }).(SubjectConfigSchemaRegistryClusterPtrOutput)
}

// The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`.
//
// > **Note:** If you want to reference the subject that is located in a custom context, use the following naming pattern: `:.contextName:subjectName`. For example, use `subjectName = ":.context1:test-subject"` to reference the subject named `test-subject` in the `context1` context, and use `subjectName = "test-subject"` to reference the subject named `test-subject` in the `default` context.
//
// > **Note:** To configure a config at the context level, affecting all subjects created within that context, use the following naming pattern: `:.contextName:`. For example, to set the global configuration for the `context1` context, use `subjectName = ":.context1:"`.
func (o SubjectConfigOutput) SubjectName() pulumi.StringOutput {
	return o.ApplyT(func(v *SubjectConfig) pulumi.StringOutput { return v.SubjectName }).(pulumi.StringOutput)
}

type SubjectConfigArrayOutput struct{ *pulumi.OutputState }

func (SubjectConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SubjectConfig)(nil)).Elem()
}

func (o SubjectConfigArrayOutput) ToSubjectConfigArrayOutput() SubjectConfigArrayOutput {
	return o
}

func (o SubjectConfigArrayOutput) ToSubjectConfigArrayOutputWithContext(ctx context.Context) SubjectConfigArrayOutput {
	return o
}

func (o SubjectConfigArrayOutput) Index(i pulumi.IntInput) SubjectConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SubjectConfig {
		return vs[0].([]*SubjectConfig)[vs[1].(int)]
	}).(SubjectConfigOutput)
}

type SubjectConfigMapOutput struct{ *pulumi.OutputState }

func (SubjectConfigMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SubjectConfig)(nil)).Elem()
}

func (o SubjectConfigMapOutput) ToSubjectConfigMapOutput() SubjectConfigMapOutput {
	return o
}

func (o SubjectConfigMapOutput) ToSubjectConfigMapOutputWithContext(ctx context.Context) SubjectConfigMapOutput {
	return o
}

func (o SubjectConfigMapOutput) MapIndex(k pulumi.StringInput) SubjectConfigOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SubjectConfig {
		return vs[0].(map[string]*SubjectConfig)[vs[1].(string)]
	}).(SubjectConfigOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SubjectConfigInput)(nil)).Elem(), &SubjectConfig{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubjectConfigArrayInput)(nil)).Elem(), SubjectConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubjectConfigMapInput)(nil)).Elem(), SubjectConfigMap{})
	pulumi.RegisterOutputType(SubjectConfigOutput{})
	pulumi.RegisterOutputType(SubjectConfigArrayOutput{})
	pulumi.RegisterOutputType(SubjectConfigMapOutput{})
}
