// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package confluentcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-confluentcloud/sdk/v2/go/confluentcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ### Option #1: Manage multiple Schema Registry clusters in the same Pulumi Stack
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-confluentcloud/sdk/v2/go/confluentcloud"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			invokeFile, err := std.File(ctx, map[string]interface{}{
//				"input": "./schemas/avro/purchase.avsc",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = confluentcloud.NewSchema(ctx, "avro-purchase", &confluentcloud.SchemaArgs{
//				SchemaRegistryCluster: &confluentcloud.SchemaSchemaRegistryClusterArgs{
//					Id: pulumi.Any(essentials.Id),
//				},
//				RestEndpoint: pulumi.Any(essentials.RestEndpoint),
//				SubjectName:  pulumi.String("avro-purchase-value"),
//				Format:       pulumi.String("AVRO"),
//				Schema:       invokeFile.Result,
//				Credentials: &confluentcloud.SchemaCredentialsArgs{
//					Key:    pulumi.String("<Schema Registry API Key for data.confluent_schema_registry_cluster.essentials>"),
//					Secret: pulumi.String("<Schema Registry API Secret for data.confluent_schema_registry_cluster.essentials>"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Option #2: Manage a single Schema Registry cluster in the same Pulumi Stack
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-confluentcloud/sdk/v2/go/confluentcloud"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			invokeFile, err := std.File(ctx, map[string]interface{}{
//				"input": "./schemas/avro/purchase.avsc",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = confluentcloud.NewSchema(ctx, "avro-purchase", &confluentcloud.SchemaArgs{
//				SubjectName: pulumi.String("avro-purchase-value"),
//				Format:      pulumi.String("AVRO"),
//				Schema:      invokeFile.Result,
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Getting Started
//
// The following end-to-end examples might help to get started with `Schema` resource:
// * single-event-types-avro-schema
// * single-event-types-proto-schema
// * single-event-types-proto-schema-with-alias
// * multiple-event-types-avro-schema
// * multiple-event-types-proto-schema
// * field-level-encryption-schema
//
// ## Additional Examples
//
// ### Default Option A: Manage the latest schema version only. The resource instance always points to the latest schema version by supporting in-place updates
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-confluentcloud/sdk/v2/go/confluentcloud"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			invokeFile, err := std.File(ctx, map[string]interface{}{
//				"input": "./schemas/avro/purchase.avsc",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			// confluent_schema.avro-purchase points to v1.
//			_, err = confluentcloud.NewSchema(ctx, "avro-purchase", &confluentcloud.SchemaArgs{
//				SubjectName: pulumi.String("avro-purchase-value"),
//				Format:      pulumi.String("AVRO"),
//				Schema:      invokeFile.Result,
//				Metadata: &confluentcloud.SchemaMetadataArgs{
//					Properties: pulumi.StringMap{
//						"owner": pulumi.String("Bob Jones"),
//						"email": pulumi.String("bob@acme.com"),
//					},
//					Sensitives: pulumi.StringArray{
//						pulumi.String("s1"),
//						pulumi.String("s2"),
//					},
//					Tags: confluentcloud.SchemaMetadataTagArray{
//						&confluentcloud.SchemaMetadataTagArgs{
//							Key: pulumi.String("tag1"),
//							Values: pulumi.StringArray{
//								pulumi.String("PII"),
//							},
//						},
//						&confluentcloud.SchemaMetadataTagArgs{
//							Key: pulumi.String("tag2"),
//							Values: pulumi.StringArray{
//								pulumi.String("PIIIII"),
//							},
//						},
//					},
//				},
//				Ruleset: &confluentcloud.SchemaRulesetArgs{
//					DomainRules: confluentcloud.SchemaRulesetDomainRuleArray{
//						&confluentcloud.SchemaRulesetDomainRuleArgs{
//							Name: pulumi.String("encryptPII"),
//							Kind: pulumi.String("TRANSFORM"),
//							Type: pulumi.String("ENCRYPT"),
//							Mode: pulumi.String("WRITEREAD"),
//							Tags: pulumi.StringArray{
//								pulumi.String("PII"),
//							},
//							Params: pulumi.StringMap{
//								"encrypt.kek.name": pulumi.String("testkek2"),
//							},
//						},
//						&confluentcloud.SchemaRulesetDomainRuleArgs{
//							Name: pulumi.String("encrypt"),
//							Kind: pulumi.String("TRANSFORM"),
//							Type: pulumi.String("ENCRYPT"),
//							Mode: pulumi.String("WRITEREAD"),
//							Tags: pulumi.StringArray{
//								pulumi.String("PIIIII"),
//							},
//							Params: pulumi.StringMap{
//								"encrypt.kek.name": pulumi.String("testkek2"),
//							},
//						},
//					},
//					MigrationRules: confluentcloud.SchemaRulesetMigrationRuleArray{
//						&confluentcloud.SchemaRulesetMigrationRuleArgs{
//							Name: pulumi.String("encrypt"),
//							Kind: pulumi.String("TRANSFORM"),
//							Type: pulumi.String("ENCRYPT"),
//							Mode: pulumi.String("WRITEREAD"),
//							Tags: pulumi.StringArray{
//								pulumi.String("PIM"),
//							},
//							Params: pulumi.StringMap{
//								"encrypt.kek.name": pulumi.String("testkekM"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// You can import a Schema by using the Schema Registry cluster ID, Subject name, and unique identifier (or `latest` when `recreate_on_update = false`) of the Schema in the format `<Schema Registry cluster ID>/<Subject name>/<Schema identifier>`, for example:
//
// Option A: recreate_on_update = false (by default)
//
// $ export IMPORT_SCHEMA_REGISTRY_API_KEY="<schema_registry_api_key>"
//
// $ export IMPORT_SCHEMA_REGISTRY_API_SECRET="<schema_registry_api_secret>"
//
// $ export IMPORT_SCHEMA_REGISTRY_REST_ENDPOINT="<schema_registry_rest_endpoint>"
//
// ```sh
// $ pulumi import confluentcloud:index/schema:Schema my_schema_1 lsrc-abc123/test-subject/latest
// ```
//
// Option B: recreate_on_update = true
//
// $ export IMPORT_SCHEMA_REGISTRY_API_KEY="<schema_registry_api_key>"
//
// $ export IMPORT_SCHEMA_REGISTRY_API_SECRET="<schema_registry_api_secret>"
//
// $ export IMPORT_SCHEMA_REGISTRY_REST_ENDPOINT="<schema_registry_rest_endpoint>"
//
// ```sh
// $ pulumi import confluentcloud:index/schema:Schema my_schema_1 lsrc-abc123/test-subject/100003
// ```
//
// !> **Warning:** Do not forget to delete terminal command history afterwards for security purposes.
type Schema struct {
	pulumi.CustomResourceState

	// The Cluster API Credentials.
	Credentials SchemaCredentialsPtrOutput `pulumi:"credentials"`
	// The format of the Schema.
	Format pulumi.StringOutput `pulumi:"format"`
	// Controls whether a schema should be soft or hard deleted. Set it to `true` if you want to hard delete a schema on destroy. Defaults to `false` (soft delete).
	HardDelete pulumi.BoolPtrOutput `pulumi:"hardDelete"`
	Metadata   SchemaMetadataOutput `pulumi:"metadata"`
	// Controls whether a schema should be recreated on update.
	RecreateOnUpdate pulumi.BoolPtrOutput `pulumi:"recreateOnUpdate"`
	// The REST endpoint of the Schema Registry cluster. For example, for public networking: `https://psrc-00000.us-central1.gcp.confluent.cloud`. In the case of private networking, the endpoint might look like `https://lsrc-abc123.pr1jy6.us-east-2.aws.confluent.cloud`. You can construct it using either:
	// - `data.confluent_schema_registry_cluster.essentials.private_regional_rest_endpoints["us-east-2"]`, or
	// - `https://${data.confluent_schema_registry_cluster.essentials.id}${data.confluent_network.main.endpoint_suffix}`
	RestEndpoint pulumi.StringPtrOutput `pulumi:"restEndpoint"`
	Ruleset      SchemaRulesetPtrOutput `pulumi:"ruleset"`
	// The definition of the Schema.
	Schema pulumi.StringOutput `pulumi:"schema"`
	// (Required Integer) The globally unique ID of the Schema, for example, `100003`. If the same schema is registered under a different subject, the same identifier will be returned. However, the `version` of the schema may be different under different subjects.
	SchemaIdentifier pulumi.IntOutput `pulumi:"schemaIdentifier"`
	// The list of references to other Schemas.
	SchemaReferences         SchemaSchemaReferenceArrayOutput     `pulumi:"schemaReferences"`
	SchemaRegistryCluster    SchemaSchemaRegistryClusterPtrOutput `pulumi:"schemaRegistryCluster"`
	SkipValidationDuringPlan pulumi.BoolPtrOutput                 `pulumi:"skipValidationDuringPlan"`
	// The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`. Schemas evolve safely, following a compatibility mode defined, under a subject name.
	SubjectName pulumi.StringOutput `pulumi:"subjectName"`
	// (Required Integer) The version of the Schema, for example, `4`.
	Version pulumi.IntOutput `pulumi:"version"`
}

// NewSchema registers a new resource with the given unique name, arguments, and options.
func NewSchema(ctx *pulumi.Context,
	name string, args *SchemaArgs, opts ...pulumi.ResourceOption) (*Schema, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Format == nil {
		return nil, errors.New("invalid value for required argument 'Format'")
	}
	if args.SubjectName == nil {
		return nil, errors.New("invalid value for required argument 'SubjectName'")
	}
	if args.Credentials != nil {
		args.Credentials = pulumi.ToSecret(args.Credentials).(SchemaCredentialsPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"credentials",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Schema
	err := ctx.RegisterResource("confluentcloud:index/schema:Schema", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSchema gets an existing Schema resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSchema(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SchemaState, opts ...pulumi.ResourceOption) (*Schema, error) {
	var resource Schema
	err := ctx.ReadResource("confluentcloud:index/schema:Schema", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Schema resources.
type schemaState struct {
	// The Cluster API Credentials.
	Credentials *SchemaCredentials `pulumi:"credentials"`
	// The format of the Schema.
	Format *string `pulumi:"format"`
	// Controls whether a schema should be soft or hard deleted. Set it to `true` if you want to hard delete a schema on destroy. Defaults to `false` (soft delete).
	HardDelete *bool           `pulumi:"hardDelete"`
	Metadata   *SchemaMetadata `pulumi:"metadata"`
	// Controls whether a schema should be recreated on update.
	RecreateOnUpdate *bool `pulumi:"recreateOnUpdate"`
	// The REST endpoint of the Schema Registry cluster. For example, for public networking: `https://psrc-00000.us-central1.gcp.confluent.cloud`. In the case of private networking, the endpoint might look like `https://lsrc-abc123.pr1jy6.us-east-2.aws.confluent.cloud`. You can construct it using either:
	// - `data.confluent_schema_registry_cluster.essentials.private_regional_rest_endpoints["us-east-2"]`, or
	// - `https://${data.confluent_schema_registry_cluster.essentials.id}${data.confluent_network.main.endpoint_suffix}`
	RestEndpoint *string        `pulumi:"restEndpoint"`
	Ruleset      *SchemaRuleset `pulumi:"ruleset"`
	// The definition of the Schema.
	Schema *string `pulumi:"schema"`
	// (Required Integer) The globally unique ID of the Schema, for example, `100003`. If the same schema is registered under a different subject, the same identifier will be returned. However, the `version` of the schema may be different under different subjects.
	SchemaIdentifier *int `pulumi:"schemaIdentifier"`
	// The list of references to other Schemas.
	SchemaReferences         []SchemaSchemaReference      `pulumi:"schemaReferences"`
	SchemaRegistryCluster    *SchemaSchemaRegistryCluster `pulumi:"schemaRegistryCluster"`
	SkipValidationDuringPlan *bool                        `pulumi:"skipValidationDuringPlan"`
	// The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`. Schemas evolve safely, following a compatibility mode defined, under a subject name.
	SubjectName *string `pulumi:"subjectName"`
	// (Required Integer) The version of the Schema, for example, `4`.
	Version *int `pulumi:"version"`
}

type SchemaState struct {
	// The Cluster API Credentials.
	Credentials SchemaCredentialsPtrInput
	// The format of the Schema.
	Format pulumi.StringPtrInput
	// Controls whether a schema should be soft or hard deleted. Set it to `true` if you want to hard delete a schema on destroy. Defaults to `false` (soft delete).
	HardDelete pulumi.BoolPtrInput
	Metadata   SchemaMetadataPtrInput
	// Controls whether a schema should be recreated on update.
	RecreateOnUpdate pulumi.BoolPtrInput
	// The REST endpoint of the Schema Registry cluster. For example, for public networking: `https://psrc-00000.us-central1.gcp.confluent.cloud`. In the case of private networking, the endpoint might look like `https://lsrc-abc123.pr1jy6.us-east-2.aws.confluent.cloud`. You can construct it using either:
	// - `data.confluent_schema_registry_cluster.essentials.private_regional_rest_endpoints["us-east-2"]`, or
	// - `https://${data.confluent_schema_registry_cluster.essentials.id}${data.confluent_network.main.endpoint_suffix}`
	RestEndpoint pulumi.StringPtrInput
	Ruleset      SchemaRulesetPtrInput
	// The definition of the Schema.
	Schema pulumi.StringPtrInput
	// (Required Integer) The globally unique ID of the Schema, for example, `100003`. If the same schema is registered under a different subject, the same identifier will be returned. However, the `version` of the schema may be different under different subjects.
	SchemaIdentifier pulumi.IntPtrInput
	// The list of references to other Schemas.
	SchemaReferences         SchemaSchemaReferenceArrayInput
	SchemaRegistryCluster    SchemaSchemaRegistryClusterPtrInput
	SkipValidationDuringPlan pulumi.BoolPtrInput
	// The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`. Schemas evolve safely, following a compatibility mode defined, under a subject name.
	SubjectName pulumi.StringPtrInput
	// (Required Integer) The version of the Schema, for example, `4`.
	Version pulumi.IntPtrInput
}

func (SchemaState) ElementType() reflect.Type {
	return reflect.TypeOf((*schemaState)(nil)).Elem()
}

type schemaArgs struct {
	// The Cluster API Credentials.
	Credentials *SchemaCredentials `pulumi:"credentials"`
	// The format of the Schema.
	Format string `pulumi:"format"`
	// Controls whether a schema should be soft or hard deleted. Set it to `true` if you want to hard delete a schema on destroy. Defaults to `false` (soft delete).
	HardDelete *bool           `pulumi:"hardDelete"`
	Metadata   *SchemaMetadata `pulumi:"metadata"`
	// Controls whether a schema should be recreated on update.
	RecreateOnUpdate *bool `pulumi:"recreateOnUpdate"`
	// The REST endpoint of the Schema Registry cluster. For example, for public networking: `https://psrc-00000.us-central1.gcp.confluent.cloud`. In the case of private networking, the endpoint might look like `https://lsrc-abc123.pr1jy6.us-east-2.aws.confluent.cloud`. You can construct it using either:
	// - `data.confluent_schema_registry_cluster.essentials.private_regional_rest_endpoints["us-east-2"]`, or
	// - `https://${data.confluent_schema_registry_cluster.essentials.id}${data.confluent_network.main.endpoint_suffix}`
	RestEndpoint *string        `pulumi:"restEndpoint"`
	Ruleset      *SchemaRuleset `pulumi:"ruleset"`
	// The definition of the Schema.
	Schema *string `pulumi:"schema"`
	// The list of references to other Schemas.
	SchemaReferences         []SchemaSchemaReference      `pulumi:"schemaReferences"`
	SchemaRegistryCluster    *SchemaSchemaRegistryCluster `pulumi:"schemaRegistryCluster"`
	SkipValidationDuringPlan *bool                        `pulumi:"skipValidationDuringPlan"`
	// The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`. Schemas evolve safely, following a compatibility mode defined, under a subject name.
	SubjectName string `pulumi:"subjectName"`
}

// The set of arguments for constructing a Schema resource.
type SchemaArgs struct {
	// The Cluster API Credentials.
	Credentials SchemaCredentialsPtrInput
	// The format of the Schema.
	Format pulumi.StringInput
	// Controls whether a schema should be soft or hard deleted. Set it to `true` if you want to hard delete a schema on destroy. Defaults to `false` (soft delete).
	HardDelete pulumi.BoolPtrInput
	Metadata   SchemaMetadataPtrInput
	// Controls whether a schema should be recreated on update.
	RecreateOnUpdate pulumi.BoolPtrInput
	// The REST endpoint of the Schema Registry cluster. For example, for public networking: `https://psrc-00000.us-central1.gcp.confluent.cloud`. In the case of private networking, the endpoint might look like `https://lsrc-abc123.pr1jy6.us-east-2.aws.confluent.cloud`. You can construct it using either:
	// - `data.confluent_schema_registry_cluster.essentials.private_regional_rest_endpoints["us-east-2"]`, or
	// - `https://${data.confluent_schema_registry_cluster.essentials.id}${data.confluent_network.main.endpoint_suffix}`
	RestEndpoint pulumi.StringPtrInput
	Ruleset      SchemaRulesetPtrInput
	// The definition of the Schema.
	Schema pulumi.StringPtrInput
	// The list of references to other Schemas.
	SchemaReferences         SchemaSchemaReferenceArrayInput
	SchemaRegistryCluster    SchemaSchemaRegistryClusterPtrInput
	SkipValidationDuringPlan pulumi.BoolPtrInput
	// The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`. Schemas evolve safely, following a compatibility mode defined, under a subject name.
	SubjectName pulumi.StringInput
}

func (SchemaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*schemaArgs)(nil)).Elem()
}

type SchemaInput interface {
	pulumi.Input

	ToSchemaOutput() SchemaOutput
	ToSchemaOutputWithContext(ctx context.Context) SchemaOutput
}

func (*Schema) ElementType() reflect.Type {
	return reflect.TypeOf((**Schema)(nil)).Elem()
}

func (i *Schema) ToSchemaOutput() SchemaOutput {
	return i.ToSchemaOutputWithContext(context.Background())
}

func (i *Schema) ToSchemaOutputWithContext(ctx context.Context) SchemaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaOutput)
}

// SchemaArrayInput is an input type that accepts SchemaArray and SchemaArrayOutput values.
// You can construct a concrete instance of `SchemaArrayInput` via:
//
//	SchemaArray{ SchemaArgs{...} }
type SchemaArrayInput interface {
	pulumi.Input

	ToSchemaArrayOutput() SchemaArrayOutput
	ToSchemaArrayOutputWithContext(context.Context) SchemaArrayOutput
}

type SchemaArray []SchemaInput

func (SchemaArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Schema)(nil)).Elem()
}

func (i SchemaArray) ToSchemaArrayOutput() SchemaArrayOutput {
	return i.ToSchemaArrayOutputWithContext(context.Background())
}

func (i SchemaArray) ToSchemaArrayOutputWithContext(ctx context.Context) SchemaArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaArrayOutput)
}

// SchemaMapInput is an input type that accepts SchemaMap and SchemaMapOutput values.
// You can construct a concrete instance of `SchemaMapInput` via:
//
//	SchemaMap{ "key": SchemaArgs{...} }
type SchemaMapInput interface {
	pulumi.Input

	ToSchemaMapOutput() SchemaMapOutput
	ToSchemaMapOutputWithContext(context.Context) SchemaMapOutput
}

type SchemaMap map[string]SchemaInput

func (SchemaMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Schema)(nil)).Elem()
}

func (i SchemaMap) ToSchemaMapOutput() SchemaMapOutput {
	return i.ToSchemaMapOutputWithContext(context.Background())
}

func (i SchemaMap) ToSchemaMapOutputWithContext(ctx context.Context) SchemaMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaMapOutput)
}

type SchemaOutput struct{ *pulumi.OutputState }

func (SchemaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Schema)(nil)).Elem()
}

func (o SchemaOutput) ToSchemaOutput() SchemaOutput {
	return o
}

func (o SchemaOutput) ToSchemaOutputWithContext(ctx context.Context) SchemaOutput {
	return o
}

// The Cluster API Credentials.
func (o SchemaOutput) Credentials() SchemaCredentialsPtrOutput {
	return o.ApplyT(func(v *Schema) SchemaCredentialsPtrOutput { return v.Credentials }).(SchemaCredentialsPtrOutput)
}

// The format of the Schema.
func (o SchemaOutput) Format() pulumi.StringOutput {
	return o.ApplyT(func(v *Schema) pulumi.StringOutput { return v.Format }).(pulumi.StringOutput)
}

// Controls whether a schema should be soft or hard deleted. Set it to `true` if you want to hard delete a schema on destroy. Defaults to `false` (soft delete).
func (o SchemaOutput) HardDelete() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Schema) pulumi.BoolPtrOutput { return v.HardDelete }).(pulumi.BoolPtrOutput)
}

func (o SchemaOutput) Metadata() SchemaMetadataOutput {
	return o.ApplyT(func(v *Schema) SchemaMetadataOutput { return v.Metadata }).(SchemaMetadataOutput)
}

// Controls whether a schema should be recreated on update.
func (o SchemaOutput) RecreateOnUpdate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Schema) pulumi.BoolPtrOutput { return v.RecreateOnUpdate }).(pulumi.BoolPtrOutput)
}

// The REST endpoint of the Schema Registry cluster. For example, for public networking: `https://psrc-00000.us-central1.gcp.confluent.cloud`. In the case of private networking, the endpoint might look like `https://lsrc-abc123.pr1jy6.us-east-2.aws.confluent.cloud`. You can construct it using either:
// - `data.confluent_schema_registry_cluster.essentials.private_regional_rest_endpoints["us-east-2"]`, or
// - `https://${data.confluent_schema_registry_cluster.essentials.id}${data.confluent_network.main.endpoint_suffix}`
func (o SchemaOutput) RestEndpoint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Schema) pulumi.StringPtrOutput { return v.RestEndpoint }).(pulumi.StringPtrOutput)
}

func (o SchemaOutput) Ruleset() SchemaRulesetPtrOutput {
	return o.ApplyT(func(v *Schema) SchemaRulesetPtrOutput { return v.Ruleset }).(SchemaRulesetPtrOutput)
}

// The definition of the Schema.
func (o SchemaOutput) Schema() pulumi.StringOutput {
	return o.ApplyT(func(v *Schema) pulumi.StringOutput { return v.Schema }).(pulumi.StringOutput)
}

// (Required Integer) The globally unique ID of the Schema, for example, `100003`. If the same schema is registered under a different subject, the same identifier will be returned. However, the `version` of the schema may be different under different subjects.
func (o SchemaOutput) SchemaIdentifier() pulumi.IntOutput {
	return o.ApplyT(func(v *Schema) pulumi.IntOutput { return v.SchemaIdentifier }).(pulumi.IntOutput)
}

// The list of references to other Schemas.
func (o SchemaOutput) SchemaReferences() SchemaSchemaReferenceArrayOutput {
	return o.ApplyT(func(v *Schema) SchemaSchemaReferenceArrayOutput { return v.SchemaReferences }).(SchemaSchemaReferenceArrayOutput)
}

func (o SchemaOutput) SchemaRegistryCluster() SchemaSchemaRegistryClusterPtrOutput {
	return o.ApplyT(func(v *Schema) SchemaSchemaRegistryClusterPtrOutput { return v.SchemaRegistryCluster }).(SchemaSchemaRegistryClusterPtrOutput)
}

func (o SchemaOutput) SkipValidationDuringPlan() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Schema) pulumi.BoolPtrOutput { return v.SkipValidationDuringPlan }).(pulumi.BoolPtrOutput)
}

// The name of the subject (in other words, the namespace), representing the subject under which the schema will be registered, for example, `test-subject`. Schemas evolve safely, following a compatibility mode defined, under a subject name.
func (o SchemaOutput) SubjectName() pulumi.StringOutput {
	return o.ApplyT(func(v *Schema) pulumi.StringOutput { return v.SubjectName }).(pulumi.StringOutput)
}

// (Required Integer) The version of the Schema, for example, `4`.
func (o SchemaOutput) Version() pulumi.IntOutput {
	return o.ApplyT(func(v *Schema) pulumi.IntOutput { return v.Version }).(pulumi.IntOutput)
}

type SchemaArrayOutput struct{ *pulumi.OutputState }

func (SchemaArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Schema)(nil)).Elem()
}

func (o SchemaArrayOutput) ToSchemaArrayOutput() SchemaArrayOutput {
	return o
}

func (o SchemaArrayOutput) ToSchemaArrayOutputWithContext(ctx context.Context) SchemaArrayOutput {
	return o
}

func (o SchemaArrayOutput) Index(i pulumi.IntInput) SchemaOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Schema {
		return vs[0].([]*Schema)[vs[1].(int)]
	}).(SchemaOutput)
}

type SchemaMapOutput struct{ *pulumi.OutputState }

func (SchemaMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Schema)(nil)).Elem()
}

func (o SchemaMapOutput) ToSchemaMapOutput() SchemaMapOutput {
	return o
}

func (o SchemaMapOutput) ToSchemaMapOutputWithContext(ctx context.Context) SchemaMapOutput {
	return o
}

func (o SchemaMapOutput) MapIndex(k pulumi.StringInput) SchemaOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Schema {
		return vs[0].(map[string]*Schema)[vs[1].(string)]
	}).(SchemaOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaInput)(nil)).Elem(), &Schema{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaArrayInput)(nil)).Elem(), SchemaArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaMapInput)(nil)).Elem(), SchemaMap{})
	pulumi.RegisterOutputType(SchemaOutput{})
	pulumi.RegisterOutputType(SchemaArrayOutput{})
	pulumi.RegisterOutputType(SchemaMapOutput{})
}
